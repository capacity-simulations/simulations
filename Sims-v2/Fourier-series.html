<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Fourier Series Decomposition</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
<style>
*{margin:0;padding:0;box-sizing:border-box;}
body{background:#0f172a;font-family:-apple-system,BlinkMacSystemFont,'Segoe UI',sans-serif;color:#e2e8f0;overflow:hidden;height:100vh;width:100vw;}

.title-bar{background:rgba(15,23,42,0.95);border-bottom:1px solid rgba(148,163,184,0.18);padding:10px 24px;display:flex;align-items:center;height:44px;flex-shrink:0;}
.title-bar h1{font-size:15px;font-weight:700;color:#f1f5f9;letter-spacing:0.3px;}
.title-bar h1 span{color:#60a5fa;}

.app-container{display:flex;width:100%;height:calc(100vh - 44px);}

.main-area{flex:1;display:flex;flex-direction:column;min-width:0;height:100%;overflow:hidden;}

.equation-bar{background:rgba(15,23,42,0.85);border-bottom:1px solid rgba(148,163,184,0.12);padding:16px 24px;min-height:80px;display:flex;align-items:center;justify-content:safe center;overflow-x:auto;overflow-y:hidden;}
.equation-bar .katex{font-size:1.3em;}
.equation-bar .katex-display{margin:0 auto;flex-shrink:0;}

.panels-container{flex:1;display:flex;flex-direction:column;min-height:0;overflow:hidden;}

.panel-top{position:relative;overflow:hidden;background:rgba(15,23,42,0.6);border-bottom:1px solid rgba(148,163,184,0.08);}
.panel-top-header{position:absolute;top:6px;left:12px;font-size:11px;text-transform:uppercase;letter-spacing:1px;color:#64748b;z-index:5;pointer-events:none;}
.panel-top-inner{display:flex;overflow-x:auto;overflow-y:hidden;padding:28px 8px 8px 8px;gap:8px;height:100%;align-items:stretch;}
.panel-top-inner::-webkit-scrollbar{height:4px;}
.panel-top-inner::-webkit-scrollbar-track{background:transparent;}
.panel-top-inner::-webkit-scrollbar-thumb{background:rgba(148,163,184,0.2);border-radius:2px;}
.term-card{background:rgba(30,41,59,0.5);border:1px solid rgba(148,163,184,0.08);border-radius:6px;padding:6px;flex:0 0 auto;min-width:200px;max-width:260px;display:flex;flex-direction:column;}
.term-card .term-label{font-size:12px;color:#e2e8f0;margin-bottom:3px;font-family:'Courier New',monospace;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;font-weight:600;letter-spacing:0.3px;}
.term-card .term-amplitude{font-size:12px;font-weight:600;color:#fbbf24;margin-bottom:4px;text-align:center;letter-spacing:0.3px;}
.term-card canvas{display:block;width:100%;flex:1;border-radius:3px;min-height:40px;}

.drag-handle-h{height:7px;cursor:ns-resize;background:rgba(148,163,184,0.08);display:flex;align-items:center;justify-content:center;flex-shrink:0;transition:background 0.15s;}
.drag-handle-h:hover,.drag-handle-h.active{background:rgba(59,130,246,0.3);}
.drag-handle-h::after{content:'';width:40px;height:2px;background:rgba(148,163,184,0.25);border-radius:1px;}

.panel-bottom{flex:1;position:relative;overflow:hidden;min-height:100px;}
.panel-bottom canvas{display:block;width:100%;height:100%;}

.right-panel{width:280px;min-width:220px;max-width:400px;background:rgba(15,23,42,0.92);border-left:1px solid rgba(148,163,184,0.12);display:flex;flex-direction:column;overflow-y:auto;padding:16px;gap:20px;}
.right-panel::-webkit-scrollbar{width:4px;}
.right-panel::-webkit-scrollbar-track{background:transparent;}
.right-panel::-webkit-scrollbar-thumb{background:rgba(148,163,184,0.2);border-radius:2px;}

.right-panel .section-title{font-size:13px;font-weight:700;color:#f1f5f9;margin-bottom:10px;display:flex;align-items:center;gap:6px;}
.right-panel .section-title span{color:#60a5fa;}

.toggle-group{display:flex;gap:0;border-radius:6px;overflow:hidden;border:1px solid rgba(148,163,184,0.2);width:100%;}
.toggle-btn{flex:1;padding:8px 10px;font-size:12px;font-weight:600;border:none;cursor:pointer;background:rgba(30,41,59,0.8);color:#94a3b8;transition:all 0.2s;text-align:center;}
.toggle-btn.active{background:#3b82f6;color:#fff;}
.toggle-btn:hover:not(.active){background:rgba(59,130,246,0.2);color:#e2e8f0;}

.control-row{display:flex;flex-direction:column;gap:6px;}
.control-row label{color:#94a3b8;font-size:12px;display:flex;justify-content:space-between;align-items:center;}
.control-row label .val{color:#fbbf24;font-weight:700;font-size:14px;}
.slider{width:100%;height:6px;-webkit-appearance:none;appearance:none;background:rgba(148,163,184,0.15);border-radius:3px;outline:none;cursor:pointer;}
.slider::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;background:#3b82f6;border-radius:50%;cursor:pointer;border:2px solid #1e3a5f;}
.slider::-moz-range-thumb{width:18px;height:18px;background:#3b82f6;border-radius:50%;cursor:pointer;border:2px solid #1e3a5f;}

.info-box{background:rgba(30,41,59,0.3);border:1px solid rgba(148,163,184,0.08);border-radius:8px;padding:12px;font-size:11px;color:#64748b;line-height:1.6;}
.info-box .note-title{color:#94a3b8;font-weight:600;margin-bottom:4px;font-size:12px;}
.info-box em{color:#93c5fd;font-style:normal;}

@media(max-width:800px){
.right-panel{width:220px;min-width:180px;padding:10px;}
}
</style>
</head>
<body>

<div class="title-bar">
  <h1><span>∿</span>&nbsp; Fourier Series Decomposition &mdash; Spatial Waves from Momentum States</h1>
</div>

<div class="app-container">
  <div class="main-area">
    <div class="equation-bar" id="equationBar"></div>
    <div class="panels-container" id="panelsContainer">
      <div class="panel-top" id="panelTop">
        <div class="panel-top-header">Individual Components</div>
        <div class="panel-top-inner" id="termCards"></div>
      </div>
      <div class="drag-handle-h" id="dragHandleH"></div>
      <div class="panel-bottom" id="panelBottom">
        <canvas id="mainCanvas"></canvas>
      </div>
    </div>
  </div>
  <div class="right-panel" id="rightPanel">
    <div>
      <div class="section-title"><span>∿</span> Fourier Series</div>
    </div>
    <div>
      <div class="section-title">Wave Type</div>
      <div class="toggle-group">
        <button class="toggle-btn active" id="btnSquare" onclick="setWaveType('square')">Square</button>
        <button class="toggle-btn" id="btnSawtooth" onclick="setWaveType('sawtooth')">Sawtooth</button>
      </div>
    </div>
    <div class="control-row">
      <label>Number of Terms <span class="val" id="nValue">5</span></label>
      <input type="range" class="slider" id="sliderN" min="1" max="30" value="5" step="1">
    </div>
    <div class="info-box">
      <div class="note-title">ℹ About This Simulation</div>
      This interactive visualization demonstrates how complex waveforms can be constructed by summing simple sine waves — the core idea behind <em>Fourier series</em>.
      <br><br>
      Choose between a <em>square wave</em> or a <em>sawtooth wave</em> and adjust the number of harmonic terms (N) using the slider. The <em>top panel</em> shows each individual sine component with its amplitude and frequency. The <em>bottom panel</em> overlays the partial Fourier sum (colored line) against the ideal target wave (dashed line).
      <br><br>
      As you increase N, the approximation improves. Notice the characteristic overshoot near discontinuities — this is the <em>Gibbs phenomenon</em>, which persists (~9%) even as N→∞.
      <br><br>
      The equation bar at the top displays the current partial sum formula up to N terms.
    </div>
  </div>
</div>

<script>
let waveType = 'square';
let N = 5;
let animPhase = 0;
const xMin = -2 * Math.PI;
const xMax = 2 * Math.PI;
const xRange = xMax - xMin;

// Drag handle state
let isDragging = false;
let panelTopHeight = 0.3;

function initDragHandle() {
  const handle = document.getElementById('dragHandleH');
  const container = document.getElementById('panelsContainer');
  const panelTop = document.getElementById('panelTop');

  function applyLayout() {
    const totalH = container.clientHeight - handle.offsetHeight;
    const topH = Math.max(60, Math.min(totalH - 100, totalH * panelTopHeight));
    panelTop.style.height = topH + 'px';
    panelTop.style.flexShrink = '0';
    panelTop.style.flexGrow = '0';
  }
  applyLayout();

  handle.addEventListener('mousedown', (e) => {
    isDragging = true;
    handle.classList.add('active');
    e.preventDefault();
  });
  window.addEventListener('mousemove', (e) => {
    if (!isDragging) return;
    const rect = container.getBoundingClientRect();
    const y = e.clientY - rect.top;
    panelTopHeight = Math.max(0.08, Math.min(0.7, y / container.clientHeight));
    applyLayout();
  });
  window.addEventListener('mouseup', () => {
    if (isDragging) {
      isDragging = false;
      document.getElementById('dragHandleH').classList.remove('active');
    }
  });

  handle.addEventListener('touchstart', (e) => {
    isDragging = true;
    handle.classList.add('active');
    e.preventDefault();
  }, {passive:false});
  window.addEventListener('touchmove', (e) => {
    if (!isDragging) return;
    const rect = container.getBoundingClientRect();
    const y = e.touches[0].clientY - rect.top;
    panelTopHeight = Math.max(0.08, Math.min(0.7, y / container.clientHeight));
    applyLayout();
  }, {passive:false});
  window.addEventListener('touchend', () => {
    if (isDragging) {
      isDragging = false;
      document.getElementById('dragHandleH').classList.remove('active');
    }
  });

  window.addEventListener('resize', applyLayout);
}

function setWaveType(type) {
  waveType = type;
  document.getElementById('btnSquare').classList.toggle('active', type === 'square');
  document.getElementById('btnSawtooth').classList.toggle('active', type === 'sawtooth');
  buildTermCards();
  updateEquation();
}

document.getElementById('sliderN').addEventListener('input', function() {
  N = parseInt(this.value);
  document.getElementById('nValue').textContent = N;
  buildTermCards();
  updateEquation();
});

function squareWaveTerm(k, x) {
  const n = 2 * k + 1;
  return (4 / (Math.PI * n)) * Math.sin(n * x);
}

function sawtoothWaveTerm(n, x) {
  return (2 / Math.PI) * (Math.pow(-1, n + 1) / n) * Math.sin(n * x);
}

function idealSquare(x) {
  let xn = ((x % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
  if (xn < Math.PI) return 1;
  if (xn > Math.PI) return -1;
  return 0;
}

function idealSawtooth(x) {
  let xn = x;
  xn = xn - 2 * Math.PI * Math.floor((xn + Math.PI) / (2 * Math.PI));
  return xn / Math.PI;
}

function partialSum(x, numTerms) {
  let sum = 0;
  if (waveType === 'square') {
    for (let k = 0; k < numTerms; k++) sum += squareWaveTerm(k, x);
  } else {
    for (let n = 1; n <= numTerms; n++) sum += sawtoothWaveTerm(n, x);
  }
  return sum;
}

function getTermValue(termIndex, x) {
  if (waveType === 'square') return squareWaveTerm(termIndex, x);
  else return sawtoothWaveTerm(termIndex + 1, x);
}

function getTermAmplitude(termIndex) {
  if (waveType === 'square') {
    const n = 2 * termIndex + 1;
    return 4 / (Math.PI * n);
  } else {
    const n = termIndex + 1;
    return 2 / (Math.PI * n);
  }
}

function getTermLabel(termIndex) {
  if (waveType === 'square') {
    const n = 2 * termIndex + 1;
    const coeff = (4 / (Math.PI * n)).toFixed(3);
    const harmStr = n === 1 ? 'x' : `${n}x`;
    return `${coeff}·sin(${harmStr})`;
  } else {
    const n = termIndex + 1;
    const sign = Math.pow(-1, n + 1) > 0 ? '+' : '-';
    const coeff = (2 / (Math.PI * n)).toFixed(3);
    const harmStr = n === 1 ? 'x' : `${n}x`;
    return `${sign === '+' ? '' : '-'}${coeff}·sin(${harmStr})`;
  }
}

function getTermAmplitudeDisplay(termIndex) {
  if (waveType === 'square') {
    const n = 2 * termIndex + 1;
    return `A = ${(4 / (Math.PI * n)).toFixed(4)}`;
  } else {
    const n = termIndex + 1;
    const signChar = Math.pow(-1, n + 1) > 0 ? '' : '-';
    return `A = ${signChar}${(2 / (Math.PI * n)).toFixed(4)}`;
  }
}

function updateEquation() {
  const bar = document.getElementById('equationBar');
  let latex = 'f(x) = ';
  if (waveType === 'square') {
    for (let k = 0; k < N; k++) {
      const n = 2 * k + 1;
      if (k > 0) latex += ' + ';
      const denomStr = n === 1 ? '\\pi' : `${n}\\pi`;
      const argStr = n === 1 ? 'x' : `${n}x`;
      latex += `\\frac{4}{${denomStr}}\\sin(${argStr})`;
      if (k >= 5 && N > 6) { latex += ' + \\cdots'; break; }
    }
  } else {
    for (let n = 1; n <= N; n++) {
      const sign = Math.pow(-1, n + 1);
      if (n > 1) latex += sign > 0 ? ' + ' : ' - ';
      else if (sign < 0) latex += '-';
      const denomStr = n === 1 ? '\\pi' : `${n}\\pi`;
      const argStr = n === 1 ? 'x' : `${n}x`;
      latex += `\\frac{2}{${denomStr}}\\sin(${argStr})`;
      if (n >= 6 && N > 6) { latex += ' + \\cdots'; break; }
    }
  }
  try {
    katex.render(latex, bar, { displayMode: true, throwOnError: false, maxSize: 500 });
  } catch(e) {
    bar.innerHTML = '<span style="color:#93c5fd;font-family:monospace;">' + latex + '</span>';
  }
}

let termCanvases = [];

function buildTermCards() {
  const container = document.getElementById('termCards');
  container.innerHTML = '';
  termCanvases = [];
  for (let i = 0; i < N; i++) {
    const card = document.createElement('div');
    card.className = 'term-card';
    const label = document.createElement('div');
    label.className = 'term-label';
    label.textContent = (waveType === 'square' ? `k=${i}: ` : `n=${i+1}: `) + getTermLabel(i);
    card.appendChild(label);
    
    const ampDiv = document.createElement('div');
    ampDiv.className = 'term-amplitude';
    ampDiv.textContent = getTermAmplitudeDisplay(i);
    card.appendChild(ampDiv);
    
    const cvs = document.createElement('canvas');
    cvs.width = 220;
    cvs.height = 100;
    card.appendChild(cvs);
    container.appendChild(card);
    termCanvases.push(cvs);
  }
  // Draw term canvases once immediately (they are static now)
  drawTermCanvases();
}

function drawTermCanvases() {
  const colors = ['#60a5fa','#34d399','#f472b6','#fbbf24','#a78bfa','#fb923c','#22d3ee','#e879f9','#4ade80','#f87171','#38bdf8','#facc15','#c084fc','#fb7185','#2dd4bf','#a3e635','#818cf8','#f97316','#67e8f9','#d946ef'];
  
  const maxAmpFirst = getTermAmplitude(0);
  const dpr = window.devicePixelRatio || 1;
  
  for (let i = 0; i < termCanvases.length; i++) {
    const cvs = termCanvases[i];
    const rect = cvs.getBoundingClientRect();
    const w = rect.width || 220, h = rect.height || 100;
    cvs.width = w * dpr;
    cvs.height = h * dpr;
    const ctx = cvs.getContext('2d');
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#0f172a';
    ctx.fillRect(0, 0, w, h);
    
    // Padding for axes
    const padL = 32, padR = 8, padT = 6, padB = 18;
    const plotW = w - padL - padR;
    const plotH = h - padT - padB;
    if (plotW < 10 || plotH < 10) continue;
    
    // Y range: use uniform scale based on largest amplitude
    const yMaxVal = maxAmpFirst * 1.15;
    const yMinVal = -yMaxVal;
    const yDataRange = yMaxVal - yMinVal;
    
    function txToScreen(x) { return padL + ((x - xMin) / xRange) * plotW; }
    function tyToScreen(y) { return padT + plotH - ((y - yMinVal) / yDataRange) * plotH; }
    
    // Grid lines
    ctx.strokeStyle = 'rgba(148,163,184,0.07)';
    ctx.lineWidth = 1;
    // Vertical grid at -2π, -π, 0, π, 2π
    const piVals = [-2*Math.PI, -Math.PI, 0, Math.PI, 2*Math.PI];
    piVals.forEach(pv => {
      const sx = txToScreen(pv);
      if (sx >= padL && sx <= padL + plotW) {
        ctx.beginPath(); ctx.moveTo(sx, padT); ctx.lineTo(sx, padT + plotH); ctx.stroke();
      }
    });
    // Horizontal grid
    const yGridStep = yMaxVal > 0.8 ? 0.5 : yMaxVal > 0.4 ? 0.25 : 0.1;
    const yGridStart = Math.ceil(yMinVal / yGridStep) * yGridStep;
    for (let gy = yGridStart; gy <= yMaxVal; gy += yGridStep) {
      const sy = tyToScreen(gy);
      if (sy >= padT && sy <= padT + plotH) {
        ctx.beginPath(); ctx.moveTo(padL, sy); ctx.lineTo(padL + plotW, sy); ctx.stroke();
      }
    }
    
    // Zero line
    ctx.strokeStyle = 'rgba(148,163,184,0.2)';
    ctx.lineWidth = 1;
    const y0 = tyToScreen(0);
    if (y0 >= padT && y0 <= padT + plotH) {
      ctx.beginPath(); ctx.moveTo(padL, y0); ctx.lineTo(padL + plotW, y0); ctx.stroke();
    }
    // Vertical axis line
    const x0 = txToScreen(0);
    if (x0 >= padL && x0 <= padL + plotW) {
      ctx.beginPath(); ctx.moveTo(x0, padT); ctx.lineTo(x0, padT + plotH); ctx.stroke();
    }
    
    // X axis labels
    ctx.fillStyle = '#64748b';
    ctx.font = '8px -apple-system, sans-serif';
    ctx.textAlign = 'center';
    const piLabelsSmall = [{v:-2*Math.PI,l:'-2π'},{v:-Math.PI,l:'-π'},{v:0,l:'0'},{v:Math.PI,l:'π'},{v:2*Math.PI,l:'2π'}];
    piLabelsSmall.forEach(p => {
      const sx = txToScreen(p.v);
      if (sx >= padL - 5 && sx <= padL + plotW + 5) {
        ctx.fillText(p.l, sx, padT + plotH + 12);
      }
    });
    
    // Y axis labels
    ctx.textAlign = 'right';
    for (let gy = yGridStart; gy <= yMaxVal; gy += yGridStep) {
      const sy = tyToScreen(gy);
      if (sy >= padT + 4 && sy <= padT + plotH - 2) {
        ctx.fillText(gy.toFixed(1), padL - 3, sy + 3);
      }
    }
    
    // Draw the sine wave for this term — NO animPhase offset, static
    ctx.strokeStyle = colors[i % colors.length];
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    for (let px = 0; px <= plotW; px++) {
      const x = xMin + (px / plotW) * xRange;
      const y = getTermValue(i, x);
      const screenX = padL + px;
      const screenY = tyToScreen(y);
      if (px === 0) ctx.moveTo(screenX, screenY);
      else ctx.lineTo(screenX, screenY);
    }
    ctx.stroke();
  }
}

function drawMainCanvas() {
  const canvas = document.getElementById('mainCanvas');
  const rect = canvas.parentElement.getBoundingClientRect();
  if (rect.width < 1 || rect.height < 1) return;
  const dpr = window.devicePixelRatio || 1;
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  const w = rect.width;
  const h = rect.height;
  
  ctx.clearRect(0, 0, w, h);
  ctx.fillStyle = '#0f172a';
  ctx.fillRect(0, 0, w, h);
  
  const padL = 55, padR = 20, padT = 30, padB = 40;
  const plotW = w - padL - padR;
  const plotH = h - padT - padB;
  if (plotW < 10 || plotH < 10) return;
  
  // Compute dynamic Y range
  const sampleCount = 500;
  let yMinVal = Infinity, yMaxVal = -Infinity;
  for (let i = 0; i <= sampleCount; i++) {
    const x = xMin + (i / sampleCount) * xRange;
    const ySum = partialSum(x, N);
    let yIdeal;
    if (waveType === 'square') yIdeal = idealSquare(x);
    else yIdeal = idealSawtooth(x);
    const lo = Math.min(ySum, yIdeal);
    const hi = Math.max(ySum, yIdeal);
    if (lo < yMinVal) yMinVal = lo;
    if (hi > yMaxVal) yMaxVal = hi;
  }
  const yPad = Math.max(0.1, (yMaxVal - yMinVal) * 0.12);
  yMinVal -= yPad;
  yMaxVal += yPad;
  const yDataRange = yMaxVal - yMinVal;
  
  function xToScreen(x) { return padL + ((x - xMin) / xRange) * plotW; }
  function yToScreen(y) { return padT + plotH - ((y - yMinVal) / yDataRange) * plotH; }
  
  // Grid
  ctx.strokeStyle = 'rgba(148,163,184,0.07)';
  ctx.lineWidth = 1;
  for (let gx = -6; gx <= 6; gx++) {
    const sx = xToScreen(gx * Math.PI / 2);
    if (sx >= padL && sx <= padL + plotW) {
      ctx.beginPath(); ctx.moveTo(sx, padT); ctx.lineTo(sx, padT + plotH); ctx.stroke();
    }
  }
  const yGridStep = yDataRange > 4 ? 1 : yDataRange > 2 ? 0.5 : 0.25;
  const yGridStart = Math.ceil(yMinVal / yGridStep) * yGridStep;
  for (let gy = yGridStart; gy <= yMaxVal; gy += yGridStep) {
    const sy = yToScreen(gy);
    if (sy >= padT && sy <= padT + plotH) {
      ctx.beginPath(); ctx.moveTo(padL, sy); ctx.lineTo(padL + plotW, sy); ctx.stroke();
    }
  }
  
  // Axes
  ctx.strokeStyle = 'rgba(148,163,184,0.25)';
  ctx.lineWidth = 1;
  const y0Screen = yToScreen(0);
  if (y0Screen >= padT && y0Screen <= padT + plotH) {
    ctx.beginPath(); ctx.moveTo(padL, y0Screen); ctx.lineTo(padL + plotW, y0Screen); ctx.stroke();
  }
  const x0Screen = xToScreen(0);
  if (x0Screen >= padL && x0Screen <= padL + plotW) {
    ctx.beginPath(); ctx.moveTo(x0Screen, padT); ctx.lineTo(x0Screen, padT + plotH); ctx.stroke();
  }
  
  // Axis labels
  ctx.fillStyle = '#64748b';
  ctx.font = '10px -apple-system, sans-serif';
  ctx.textAlign = 'center';
  const piLabels = [{v:-2*Math.PI,l:'-2π'},{v:-Math.PI,l:'-π'},{v:0,l:'0'},{v:Math.PI,l:'π'},{v:2*Math.PI,l:'2π'}];
  piLabels.forEach(p => {
    const sx = xToScreen(p.v);
    if (sx >= padL - 5 && sx <= padL + plotW + 5) {
      ctx.fillText(p.l, sx, padT + plotH + 16);
    }
  });
  ctx.textAlign = 'right';
  for (let gy = yGridStart; gy <= yMaxVal; gy += yGridStep) {
    const sy = yToScreen(gy);
    if (sy >= padT + 5 && sy <= padT + plotH - 5) {
      ctx.fillText(gy.toFixed(1), padL - 6, sy + 3);
    }
  }
  
  // Target wave (dashed)
  ctx.strokeStyle = 'rgba(148,163,184,0.4)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  let prevIdeal = null;
  for (let px = 0; px <= plotW; px++) {
    const x = xMin + (px / plotW) * xRange;
    let y;
    if (waveType === 'square') y = idealSquare(x);
    else y = idealSawtooth(x);
    const sx = padL + px;
    const sy = yToScreen(y);
    if (prevIdeal !== null && Math.abs(y - prevIdeal) > 1) {
      ctx.moveTo(sx, sy);
    } else {
      if (px === 0) ctx.moveTo(sx, sy);
      else ctx.lineTo(sx, sy);
    }
    prevIdeal = y;
  }
  ctx.stroke();
  ctx.setLineDash([]);
  
  // Partial sum line
  const gradient = ctx.createLinearGradient(padL, 0, padL + plotW, 0);
  gradient.addColorStop(0, '#60a5fa');
  gradient.addColorStop(0.5, '#34d399');
  gradient.addColorStop(1, '#f472b6');
  
  ctx.strokeStyle = gradient;
  ctx.lineWidth = 2.5;
  ctx.beginPath();
  for (let px = 0; px <= plotW; px++) {
    const x = xMin + (px / plotW) * xRange;
    const y = partialSum(x, N);
    const sx = padL + px;
    const sy = yToScreen(y);
    if (px === 0) ctx.moveTo(sx, sy);
    else ctx.lineTo(sx, sy);
  }
  ctx.stroke();
  
  // Animated sweep line (time-based, resolution-independent)
  const sweepPeriod = 8;
  const sweepFrac = ((animPhase / 30) / sweepPeriod) % 1;
  const sweepX = padL + sweepFrac * plotW;
  ctx.strokeStyle = 'rgba(96,165,250,0.2)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.moveTo(sweepX, padT);
  ctx.lineTo(sweepX, padT + plotH);
  ctx.stroke();
  
  const sweepDataX = xMin + sweepFrac * xRange;
  const sweepDataY = partialSum(sweepDataX, N);
  const dotX = sweepX;
  const dotY = yToScreen(sweepDataY);
  ctx.fillStyle = '#60a5fa';
  ctx.beginPath();
  ctx.arc(dotX, dotY, 4, 0, 2 * Math.PI);
  ctx.fill();
  ctx.strokeStyle = 'rgba(96,165,250,0.4)';
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.arc(dotX, dotY, 8 + Math.sin(animPhase * 0.1) * 3, 0, 2 * Math.PI);
  ctx.stroke();
  
  // Legend
  const legendX = padL + 10;
  const legendY = padT + 14;
  ctx.font = '11px -apple-system, sans-serif';
  
  ctx.setLineDash([6, 4]);
  ctx.strokeStyle = 'rgba(148,163,184,0.5)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(legendX, legendY); ctx.lineTo(legendX + 24, legendY); ctx.stroke();
  ctx.setLineDash([]);
  ctx.fillStyle = '#94a3b8';
  ctx.textAlign = 'left';
  ctx.fillText(`Target ${waveType} wave`, legendX + 30, legendY + 4);
  
  const legendGrad = ctx.createLinearGradient(legendX, 0, legendX + 24, 0);
  legendGrad.addColorStop(0, '#60a5fa');
  legendGrad.addColorStop(0.5, '#34d399');
  legendGrad.addColorStop(1, '#f472b6');
  ctx.strokeStyle = legendGrad;
  ctx.lineWidth = 2.5;
  ctx.beginPath(); ctx.moveTo(legendX, legendY + 18); ctx.lineTo(legendX + 24, legendY + 18); ctx.stroke();
  ctx.fillStyle = '#e2e8f0';
  ctx.fillText(`Partial sum (N=${N})`, legendX + 30, legendY + 22);
  
  // Title
  ctx.fillStyle = '#94a3b8';
  ctx.font = '12px -apple-system, sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`${waveType === 'square' ? 'Square' : 'Sawtooth'} Wave — ${N} term${N>1?'s':''}`, w / 2, 18);
}

let lastTime = 0;
function animate(time) {
  const dt = Math.min(time - lastTime, 50) / 1000;
  lastTime = time;
  animPhase = (animPhase + dt * 30) % 240000;
  
  drawMainCanvas();
  // Term canvases are now static — they are only redrawn when buildTermCards() is called
  
  requestAnimationFrame(animate);
}

function init() {
  buildTermCards();
  updateEquation();
  initDragHandle();
  requestAnimationFrame(animate);
}

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init);
} else {
  init();
}
</script>
</body>
</html>