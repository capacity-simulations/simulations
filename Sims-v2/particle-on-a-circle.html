<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Particle on a Circle</title>
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0f172a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #e2e8f0;
            overflow: hidden;
            height: 100vh;
        }
        
        .top-bar {
            display: flex;
            align-items: center;
            padding: 12px 24px;
            background: rgba(15, 23, 42, 0.95);
            border-bottom: 1px solid rgba(148, 163, 184, 0.15);
            height: 52px;
            position: relative;
            z-index: 100;
        }
        
        .top-bar-title {
            font-size: 17px;
            font-weight: 700;
            color: #f1f5f9;
            letter-spacing: 0.2px;
        }
        
        .info-icon-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            margin-left: 12px;
        }
        
        .info-icon {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.15);
            border: 1.5px solid rgba(59, 130, 246, 0.4);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 13px;
            font-weight: 700;
            color: #60a5fa;
            font-style: italic;
            font-family: Georgia, 'Times New Roman', serif;
            transition: all 0.2s;
        }
        
        .info-icon:hover {
            background: rgba(59, 130, 246, 0.25);
            border-color: rgba(59, 130, 246, 0.6);
            transform: scale(1.05);
        }
        
        .info-tooltip {
            display: none;
            position: absolute;
            top: 34px;
            left: 0;
            width: 380px;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(16px);
            border: 1px solid rgba(59, 130, 246, 0.25);
            border-radius: 10px;
            padding: 16px;
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        
        .info-icon-wrapper:hover .info-tooltip {
            display: block;
        }
        
        .info-tooltip .info-box {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .info-tooltip .info-box .formula {
            color: #60a5fa;
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .container {
            display: flex;
            height: calc(100vh - 52px);
        }
        
        .main-content {
            flex: 1;
            display: flex;
            padding: 20px;
            gap: 20px;
        }
        
        .panel {
            flex: 1;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
        }
        
        .panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .panel-title-energy {
            font-size: 14px;
            font-weight: 600;
            color: #94a3b8;
            letter-spacing: 0.5px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            min-height: 32px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .panel-title-energy .title-label {
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #94a3b8;
            font-weight: 600;
            font-size: 14px;
            margin-right: 4px;
        }
        
        .panel-title-energy .title-equation {
            display: inline-flex;
            align-items: center;
        }
        
        .panel-title-wavefunction {
            font-size: 14px;
            font-weight: 600;
            color: #94a3b8;
            letter-spacing: 0.5px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            min-height: 32px;
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        
        .panel-title-wavefunction .title-label {
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: #94a3b8;
            font-weight: 600;
            font-size: 14px;
            margin-right: 4px;
        }
        
        .panel-title-wavefunction .title-equation {
            display: inline-flex;
            align-items: center;
        }
        
        .canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        canvas {
            max-width: 100%;
            max-height: 100%;
        }
        
        .control-panel {
            width: 320px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(12px);
            border-left: 1px solid rgba(148, 163, 184, 0.1);
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            overflow-y: auto;
        }
        
        .control-section {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            padding: 15px;
            border: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .control-section h3 {
            font-size: 12px;
            font-weight: 600;
            color: #64748b;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
        }
        
        .control-group {
            margin-bottom: 15px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .control-label span:first-child {
            color: #94a3b8;
        }
        
        .control-value {
            color: #60a5fa;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(59, 130, 246, 0.4);
            transition: transform 0.15s;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }
        
        .btn {
            width: 100%;
            padding: 10px 16px;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .btn-primary {
            background: #3b82f6;
            color: white;
        }
        
        .btn-primary:hover {
            background: #2563eb;
        }
        
        .btn-secondary {
            background: rgba(148, 163, 184, 0.1);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(148, 163, 184, 0.2);
        }
        
        .info-box {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(59, 130, 246, 0.2);
            border-radius: 6px;
            padding: 12px;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .info-box .formula {
            color: #60a5fa;
            text-align: center;
            margin: 10px 0;
            font-size: 14px;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 10px;
            font-size: 12px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        
        .legend-color {
            width: 12px;
            height: 3px;
            border-radius: 2px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 10px;
        }
        
        .stat-item {
            background: rgba(15, 23, 42, 0.5);
            padding: 12px;
            border-radius: 6px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .stat-item .value {
            font-size: 16px;
            font-weight: 600;
            color: #f1f5f9;
        }
        
        .stat-item .label {
            font-size: 11px;
            color: #94a3b8;
        }
        
        .degeneracy-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }
        
        .degeneracy-badge.degenerate {
            background: rgba(251, 191, 36, 0.2);
            color: #fbbf24;
        }
        
        .degeneracy-badge.non-degenerate {
            background: rgba(52, 211, 153, 0.2);
            color: #34d399;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 13px;
            color: #94a3b8;
            cursor: pointer;
        }
        
        .checkbox-group input {
            width: 16px;
            height: 16px;
            accent-color: #3b82f6;
        }
        
        /* MathJax styling */
        .MathJax {
            color: #60a5fa !important;
        }
        
        .info-box .MathJax {
            font-size: 110% !important;
        }
        
        .panel-title-wavefunction .MathJax {
            color: #94a3b8 !important;
        }
        
        .panel-title-wavefunction .title-equation .MathJax {
            color: #60a5fa !important;
        }
        
        .panel-title-energy .MathJax {
            color: #94a3b8 !important;
        }
        
        .panel-title-energy .title-equation .MathJax {
            color: #60a5fa !important;
        }
    </style>
</head>
<body>
    <!-- Top Bar -->
    <div class="top-bar">
        <span class="top-bar-title">Particle on a Circle</span>
        <div class="info-icon-wrapper">
            <div class="info-icon">i</div>
            <div class="info-tooltip">
                <div class="info-box">
                    <strong>Energy Formula:</strong>
                    <div class="formula">\[E_n = \frac{n^2\hbar^2}{2mR^2}\]</div>
                    <strong>Wavefunction:</strong>
                    <div class="formula">\[\psi_n(\phi) = \frac{1}{\sqrt{2\pi}} e^{in\phi}\]</div>
                    <strong>Time Evolution:</strong>
                    <div class="formula">\[\psi_n(\phi, t) = \frac{1}{\sqrt{2\pi}} e^{i(n\phi - E_n t/\hbar)}\]</div>
                    <strong>Angular Momentum:</strong>
                    <div class="formula">\[L_z = n\hbar\]</div>
                    <p style="margin-top: 8px; color: #94a3b8;">States \(\pm n\) have the same energy but <em>opposite</em> angular momentum \(L_z = \pm n\hbar\) (doubly degenerate). The \(n=0\) state is non-degenerate with \(L_z = 0\).</p>
                    <p style="margin-top: 6px; color: #94a3b8;">Using natural units: \(R = 1\), \(\hbar = 1\), \(2m = 1\). So \(E_n = n^2\) and spatial wavelength \(\lambda = 2\pi R / |n|\).</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="container">
        <div class="main-content">
            <!-- Energy Level Panel -->
            <div class="panel">
                <div class="panel-title-energy" id="energyTitle"><span class="title-label">Energy Levels</span><span class="title-equation">\(\displaystyle E_n = \frac{n^2\hbar^2}{2mR^2}\)</span></div>
                <div class="canvas-container">
                    <canvas id="energyCanvas"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #f472b6;"></div>
                        <span>Current Level</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #475569;"></div>
                        <span>Other Levels</span>
                    </div>
                </div>
            </div>
            
            <!-- Wavefunction Panel -->
            <div class="panel">
                <div class="panel-title-wavefunction" id="wavefunctionTitle"><span class="title-label">Wavefunction</span><span class="title-equation">\(\displaystyle \psi_{1}(\phi) = \frac{1}{\sqrt{2\pi}}\, e^{i(1)\phi}\)</span></div>
                <div class="canvas-container">
                    <canvas id="wavefunctionCanvas"></canvas>
                </div>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #60a5fa;"></div>
                        <span>Real Part</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #34d399;"></div>
                        <span>Imaginary Part</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: #fbbf24; opacity: 0.5;"></div>
                        <span>\(|\psi|^2\)</span>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Control Panel -->
        <div class="control-panel">
            <div class="control-section">
                <h3>Quantum Number</h3>
                <div class="control-group">
                    <div class="control-label">
                        <span>Energy Level \(n\)</span>
                        <span class="control-value" id="nValue">1</span>
                    </div>
                    <input type="range" class="slider" id="nSlider" min="-15" max="15" value="1">
                </div>
                <div style="text-align: center; margin-top: 10px;">
                    <span class="degeneracy-badge degenerate" id="degeneracyBadge">Doubly Degenerate (±n)</span>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Display Mode</h3>
                <button class="btn btn-primary" id="toggleDisplay">Show on Ring</button>
                <div style="margin-top: 10px;">
                    <label class="checkbox-group">
                        <input type="checkbox" id="showProbability" checked>
                        Show Probability Density \(|\psi|^2\)
                    </label>
                </div>
                <div style="margin-top: 8px;">
                    <label class="checkbox-group">
                        <input type="checkbox" id="animatePhase" checked>
                        Animate Time Evolution
                    </label>
                </div>
            </div>
            
            <div class="control-section">
                <h3>Animation</h3>
                <div class="control-group">
                    <div class="control-label">
                        <span>Time Speed</span>
                        <span class="control-value" id="speedValue">1.0x</span>
                    </div>
                    <input type="range" class="slider" id="speedSlider" min="0" max="3" step="0.1" value="1">
                </div>
            </div>
            
            <div class="control-section">
                <h3>Current State</h3>
                <div class="stats-grid">
                    <div class="stat-item">
                        <span class="label">Ring Radius \(R\)</span>
                        <span class="value" id="radiusValue">1</span>
                    </div>
                    <div class="stat-item">
                        <span class="label">Energy \(E_n\)</span>
                        <span class="value" id="energyValue">1 ℏ²/2mR²</span>
                    </div>
                    <div class="stat-item">
                        <span class="label">Spatial Wavelength \(\lambda\)</span>
                        <span class="value" id="wavelengthValue">2πR</span>
                    </div>
                    <div class="stat-item">
                        <span class="label">Angular Momentum \(L_z\)</span>
                        <span class="value" id="angularMomentumValue">1ℏ</span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Canvas setup
        const energyCanvas = document.getElementById('energyCanvas');
        const wavefunctionCanvas = document.getElementById('wavefunctionCanvas');
        const energyCtx = energyCanvas.getContext('2d');
        const waveCtx = wavefunctionCanvas.getContext('2d');
        
        // Physical constants (natural units)
        const R = 1; // Ring radius
        
        // State
        let n = 1;
        let showOnRing = false;
        let showProbability = true;
        let animatePhase = true;
        let timeSpeed = 1;
        let time = 0;
        let lastFrameTime = performance.now();
        
        // DOM elements
        const nSlider = document.getElementById('nSlider');
        const nValueDisplay = document.getElementById('nValue');
        const degeneracyBadge = document.getElementById('degeneracyBadge');
        const toggleDisplayBtn = document.getElementById('toggleDisplay');
        const showProbabilityCheckbox = document.getElementById('showProbability');
        const animatePhaseCheckbox = document.getElementById('animatePhase');
        const speedSlider = document.getElementById('speedSlider');
        const speedValueDisplay = document.getElementById('speedValue');
        const energyValueDisplay = document.getElementById('energyValue');
        const wavelengthValueDisplay = document.getElementById('wavelengthValue');
        const angularMomentumDisplay = document.getElementById('angularMomentumValue');
        const wavefunctionTitle = document.getElementById('wavefunctionTitle');
        const energyTitle = document.getElementById('energyTitle');
        
        // Slider range for dynamic energy diagram
        const SLIDER_MAX = 15;
        
        // Resize canvases
        function resizeCanvases() {
            const energyContainer = energyCanvas.parentElement;
            const waveContainer = wavefunctionCanvas.parentElement;
            
            energyCanvas.width = energyContainer.clientWidth;
            energyCanvas.height = energyContainer.clientHeight;
            
            wavefunctionCanvas.width = waveContainer.clientWidth;
            wavefunctionCanvas.height = waveContainer.clientHeight;
        }
        
        // Update the wavefunction panel title with LaTeX
        function updateWavefunctionTitle() {
            let equationStr;
            if (animatePhase) {
                if (n === 0) {
                    equationStr = '\\(\\displaystyle \\psi_{0}(\\phi, t) = \\frac{1}{\\sqrt{2\\pi}}\\)';
                } else {
                    const nStr = n < 0 ? `(${n})` : `${n}`;
                    const enStr = `${n * n}`;
                    equationStr = `\\(\\displaystyle \\psi_{${n}}(\\phi, t) = \\frac{1}{\\sqrt{2\\pi}}\\, e^{i(${nStr}\\phi - ${enStr}\\,t)}\\)`;
                }
            } else {
                if (n === 0) {
                    equationStr = '\\(\\displaystyle \\psi_{0}(\\phi) = \\frac{1}{\\sqrt{2\\pi}}\\)';
                } else {
                    const nStr = n < 0 ? `(${n})` : `${n}`;
                    equationStr = `\\(\\displaystyle \\psi_{${n}}(\\phi) = \\frac{1}{\\sqrt{2\\pi}}\\, e^{i${nStr}\\phi}\\)`;
                }
            }
            wavefunctionTitle.innerHTML = `<span class="title-label">Wavefunction</span><span class="title-equation">${equationStr}</span>`;
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([wavefunctionTitle]);
            }
        }
        
        // Update stats display
        function updateStats() {
            const absN = Math.abs(n);
            const energyVal = absN * absN;
            energyValueDisplay.textContent = `${energyVal} ℏ²/2mR²`;

            if (absN === 0) {
                wavelengthValueDisplay.textContent = '∞ (uniform)';
                angularMomentumDisplay.textContent = '0';
            } else {
                if (absN === 1) {
                    wavelengthValueDisplay.textContent = `2π ≈ ${(2 * Math.PI * R).toFixed(2)}`;
                } else {
                    wavelengthValueDisplay.textContent = `2π/${absN} ≈ ${(2 * Math.PI * R / absN).toFixed(2)}`;
                }
                angularMomentumDisplay.textContent = `${n}ℏ`;
            }

            if (n === 0) {
                degeneracyBadge.innerHTML = 'Non-Degenerate (n=0, L<sub>z</sub>=0)';
                degeneracyBadge.className = 'degeneracy-badge non-degenerate';
            } else {
                degeneracyBadge.innerHTML = `Doubly Degenerate (±${Math.abs(n)}, L<sub>z</sub>=±${Math.abs(n)}ℏ)`;
                degeneracyBadge.className = 'degeneracy-badge degenerate';
            }
            
            // Update wavefunction panel title
            updateWavefunctionTitle();
            
            // Re-render MathJax
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise();
            }
        }
        
        // Energy diagram with fixed E=0 / E=1 overlap
        function drawEnergyLevels() {
            const w = energyCanvas.width;
            const h = energyCanvas.height;
            const paddingLeft = 80;
            const paddingRight = 70;
            const paddingTop = 20;
            const paddingBottom = 40;

            energyCtx.fillStyle = '#0f172a';
            energyCtx.fillRect(0, 0, w, h);

            // Draw axis
            energyCtx.strokeStyle = '#475569';
            energyCtx.lineWidth = 2;
            energyCtx.beginPath();
            energyCtx.moveTo(paddingLeft, paddingTop);
            energyCtx.lineTo(paddingLeft, h - paddingBottom);
            energyCtx.stroke();

            const maxN = SLIDER_MAX;
            const maxEnergy = maxN * maxN; // 225
            const graphHeight = h - paddingTop - paddingBottom;
            
            // Minimum pixel spacing between E=0 and E=1 levels
            const minSpacingE0E1 = 25; // pixels
            
            // With pure linear scaling, the spacing between E=0 and E=1 would be:
            // (1 / maxEnergy) * graphHeight
            const linearSpacing01 = (1 / maxEnergy) * graphHeight;
            
            // We need an offset if the linear spacing is too small
            // We'll add a fixed pixel offset at the bottom for E=0 to E=1 gap
            // and then linearly scale E=1 to E=maxEnergy in the remaining space
            const needsOffset = linearSpacing01 < minSpacingE0E1;
            const extraOffset = needsOffset ? (minSpacingE0E1 - linearSpacing01) : 0;
            
            // E=0 is at the very bottom
            // E=1 is at extraOffset pixels above E=0
            // E=1 to E=maxEnergy maps linearly to the remaining space
            
            function energyToY(energy) {
                if (energy === 0) {
                    return h - paddingBottom;
                }
                // For energy >= 1, we place E=1 at (h - paddingBottom - minSpacingE0E1) if offset needed
                // and then scale linearly from E=1 to E=maxEnergy in the remaining space above
                const e0Y = h - paddingBottom;
                const e1Y = e0Y - (linearSpacing01 + extraOffset); // E=1 position
                
                if (energy <= 1) {
                    // Interpolate between E=0 and E=1
                    return e0Y - energy * (linearSpacing01 + extraOffset);
                }
                
                // For energy > 1, linearly map from E=1 to E=maxEnergy
                // E=1 -> e1Y, E=maxEnergy -> paddingTop
                const remainingHeight = e1Y - paddingTop;
                const remainingEnergyRange = maxEnergy - 1;
                return e1Y - ((energy - 1) / remainingEnergyRange) * remainingHeight;
            }

            // Draw energy levels for n = 0 to maxN
            for (let level = 0; level <= maxN; level++) {
                const energy = level * level;
                const y = energyToY(energy);

                const isCurrentLevel = Math.abs(n) === level;

                // Skip drawing very closely spaced high levels (but always draw current)
                if (level > 10 && level % 2 !== 0 && !isCurrentLevel) continue;

                energyCtx.strokeStyle = isCurrentLevel ? '#f472b6' : '#475569';
                energyCtx.lineWidth = isCurrentLevel ? 3 : 1;
                energyCtx.beginPath();
                energyCtx.moveTo(paddingLeft - 10, y);
                energyCtx.lineTo(w - paddingRight, y);
                energyCtx.stroke();

                energyCtx.fillStyle = isCurrentLevel ? '#f472b6' : '#94a3b8';
                energyCtx.font = isCurrentLevel ? 'bold 11px sans-serif' : '10px sans-serif';
                energyCtx.textAlign = 'right';
                const nLabel = level === 0 ? 'n=0' : `n=±${level}`;
                energyCtx.fillText(nLabel, paddingLeft - 15, y + 4);

                energyCtx.fillStyle = isCurrentLevel ? '#f472b6' : '#64748b';
                energyCtx.font = isCurrentLevel ? 'bold 10px sans-serif' : '9px sans-serif';
                energyCtx.textAlign = 'left';
                energyCtx.fillText(`E=${energy}`, w - paddingRight + 8, y + 4);

                if (isCurrentLevel) {
                    energyCtx.shadowColor = '#f472b6';
                    energyCtx.shadowBlur = 10;
                    energyCtx.strokeStyle = '#f472b6';
                    energyCtx.lineWidth = 3;
                    energyCtx.beginPath();
                    energyCtx.moveTo(paddingLeft - 10, y);
                    energyCtx.lineTo(w - paddingRight, y);
                    energyCtx.stroke();
                    energyCtx.shadowBlur = 0;

                    energyCtx.fillStyle = '#f472b6';
                    energyCtx.beginPath();
                    energyCtx.moveTo(w - paddingRight + 5, y);
                    energyCtx.lineTo(w - paddingRight - 5, y - 6);
                    energyCtx.lineTo(w - paddingRight - 5, y + 6);
                    energyCtx.closePath();
                    energyCtx.fill();
                }
            }

            // Y axis label
            energyCtx.save();
            energyCtx.translate(15, h / 2);
            energyCtx.rotate(-Math.PI / 2);
            energyCtx.fillStyle = '#94a3b8';
            energyCtx.font = '11px sans-serif';
            energyCtx.textAlign = 'center';
            energyCtx.fillText('Energy (ℏ²/2mR²)', 0, 0);
            energyCtx.restore();
        }
        
        // Draw wavefunction on regular plot
        function drawWavefunctionPlot() {
            const w = wavefunctionCanvas.width;
            const h = wavefunctionCanvas.height;
            const padding = 50;
            
            waveCtx.fillStyle = '#0f172a';
            waveCtx.fillRect(0, 0, w, h);
            
            const plotW = w - 2 * padding;
            const plotH = h - 2 * padding;
            const centerY = h / 2;
            
            const normalization = 1 / Math.sqrt(2 * Math.PI);
            const visualScale = (plotH / 2) * 0.6 / normalization;
            
            // Draw axes
            waveCtx.strokeStyle = '#475569';
            waveCtx.lineWidth = 1;
            
            // X axis
            waveCtx.beginPath();
            waveCtx.moveTo(padding, centerY);
            waveCtx.lineTo(w - padding, centerY);
            waveCtx.stroke();
            
            // Y axis
            waveCtx.beginPath();
            waveCtx.moveTo(padding, padding);
            waveCtx.lineTo(padding, h - padding);
            waveCtx.stroke();
            
            waveCtx.fillStyle = '#94a3b8';
            waveCtx.font = '11px sans-serif';
            waveCtx.textAlign = 'center';
            
            // X axis labels (0 to 2π)
            const xLabels = ['0', 'π/2', 'π', '3π/2', '2π'];
            for (let i = 0; i < xLabels.length; i++) {
                const x = padding + (i / 4) * plotW;
                waveCtx.fillText(xLabels[i], x, h - padding + 20);
                
                waveCtx.beginPath();
                waveCtx.moveTo(x, centerY - 5);
                waveCtx.lineTo(x, centerY + 5);
                waveCtx.stroke();
            }
            
            waveCtx.fillText('φ', w / 2, h - 15);
            
            waveCtx.save();
            waveCtx.translate(18, centerY);
            waveCtx.rotate(-Math.PI / 2);
            waveCtx.fillStyle = '#94a3b8';
            waveCtx.font = '11px sans-serif';
            waveCtx.textAlign = 'center';
            waveCtx.fillText('ψ(φ)', 0, 0);
            waveCtx.restore();
            
            // Draw Y-axis scale markers
            const normY_pos = centerY - normalization * visualScale;
            const normY_neg = centerY + normalization * visualScale;
            waveCtx.fillStyle = '#64748b';
            waveCtx.font = '9px sans-serif';
            waveCtx.textAlign = 'right';
            waveCtx.fillText('1/√2π', padding - 5, normY_pos + 3);
            waveCtx.fillText('-1/√2π', padding - 5, normY_neg + 3);
            waveCtx.strokeStyle = '#64748b';
            waveCtx.beginPath();
            waveCtx.moveTo(padding - 3, normY_pos);
            waveCtx.lineTo(padding + 3, normY_pos);
            waveCtx.moveTo(padding - 3, normY_neg);
            waveCtx.lineTo(padding + 3, normY_neg);
            waveCtx.stroke();
            
            // Draw probability density
            if (showProbability) {
                const probVal = 1 / (2 * Math.PI);
                const probVisualHeight = probVal * visualScale;
                const probY = centerY - probVisualHeight;
                
                waveCtx.fillStyle = 'rgba(251, 191, 36, 0.15)';
                waveCtx.beginPath();
                waveCtx.moveTo(padding, centerY);
                waveCtx.lineTo(padding, probY);
                waveCtx.lineTo(w - padding, probY);
                waveCtx.lineTo(w - padding, centerY);
                waveCtx.closePath();
                waveCtx.fill();
                
                waveCtx.strokeStyle = 'rgba(251, 191, 36, 0.6)';
                waveCtx.lineWidth = 2;
                waveCtx.beginPath();
                waveCtx.moveTo(padding, probY);
                waveCtx.lineTo(w - padding, probY);
                waveCtx.stroke();
                
                waveCtx.fillStyle = 'rgba(251, 191, 36, 0.7)';
                waveCtx.font = '9px sans-serif';
                waveCtx.textAlign = 'left';
                waveCtx.fillText('|ψ|² = 1/2π', w - padding + 5, probY + 3);
            }
            
            const phase = animatePhase ? time * timeSpeed : 0;
            
            // Draw real part
            waveCtx.strokeStyle = '#60a5fa';
            waveCtx.lineWidth = 2.5;
            waveCtx.beginPath();
            
            for (let i = 0; i <= plotW; i++) {
                const phi = (i / plotW) * 2 * Math.PI;
                const real = normalization * Math.cos(n * phi - n * n * phase);
                const y = centerY - real * visualScale;
                
                if (i === 0) {
                    waveCtx.moveTo(padding + i, y);
                } else {
                    waveCtx.lineTo(padding + i, y);
                }
            }
            waveCtx.stroke();
            
            // Draw imaginary part
            waveCtx.strokeStyle = '#34d399';
            waveCtx.lineWidth = 2.5;
            waveCtx.beginPath();
            
            for (let i = 0; i <= plotW; i++) {
                const phi = (i / plotW) * 2 * Math.PI;
                const imag = normalization * Math.sin(n * phi - n * n * phase);
                const y = centerY - imag * visualScale;
                
                if (i === 0) {
                    waveCtx.moveTo(padding + i, y);
                } else {
                    waveCtx.lineTo(padding + i, y);
                }
            }
            waveCtx.stroke();
        }
        
        // Draw wavefunction on ring
        function drawWavefunctionRing() {
            const w = wavefunctionCanvas.width;
            const h = wavefunctionCanvas.height;
            
            waveCtx.fillStyle = '#0f172a';
            waveCtx.fillRect(0, 0, w, h);
            
            const centerX = w / 2;
            const centerY = h / 2;
            const baseRadius = Math.min(w, h) * 0.3;
            const normalization = 1 / Math.sqrt(2 * Math.PI);
            const displacementScale = baseRadius * 0.45;
            
            const phase = animatePhase ? time * timeSpeed : 0;
            
            // Draw base circle
            waveCtx.strokeStyle = '#334155';
            waveCtx.lineWidth = 2;
            waveCtx.beginPath();
            waveCtx.arc(centerX, centerY, baseRadius, 0, 2 * Math.PI);
            waveCtx.stroke();
            
            if (showProbability) {
                const probVal = 1 / (2 * Math.PI);
                const bandHalfWidth = probVal * displacementScale;
                
                waveCtx.fillStyle = 'rgba(251, 191, 36, 0.1)';
                waveCtx.beginPath();
                waveCtx.arc(centerX, centerY, baseRadius + bandHalfWidth, 0, 2 * Math.PI);
                waveCtx.arc(centerX, centerY, baseRadius - bandHalfWidth, 0, 2 * Math.PI, true);
                waveCtx.fill();
                
                waveCtx.strokeStyle = 'rgba(251, 191, 36, 0.25)';
                waveCtx.lineWidth = 1;
                waveCtx.beginPath();
                waveCtx.arc(centerX, centerY, baseRadius + bandHalfWidth, 0, 2 * Math.PI);
                waveCtx.stroke();
                waveCtx.beginPath();
                waveCtx.arc(centerX, centerY, baseRadius - bandHalfWidth, 0, 2 * Math.PI);
                waveCtx.stroke();
            }
            
            // Draw real part on ring
            waveCtx.strokeStyle = '#60a5fa';
            waveCtx.lineWidth = 3;
            waveCtx.beginPath();
            
            const numPoints = 360;
            for (let i = 0; i <= numPoints; i++) {
                const phi = (i / numPoints) * 2 * Math.PI;
                const real = normalization * Math.cos(n * phi - n * n * phase);
                const r = baseRadius + real * displacementScale;
                
                const x = centerX + r * Math.cos(phi - Math.PI / 2);
                const y = centerY + r * Math.sin(phi - Math.PI / 2);
                
                if (i === 0) {
                    waveCtx.moveTo(x, y);
                } else {
                    waveCtx.lineTo(x, y);
                }
            }
            waveCtx.stroke();
            
            // Draw imaginary part on ring
            waveCtx.strokeStyle = '#34d399';
            waveCtx.lineWidth = 3;
            waveCtx.beginPath();
            
            for (let i = 0; i <= numPoints; i++) {
                const phi = (i / numPoints) * 2 * Math.PI;
                const imag = normalization * Math.sin(n * phi - n * n * phase);
                const r = baseRadius + imag * displacementScale;
                
                const x = centerX + r * Math.cos(phi - Math.PI / 2);
                const y = centerY + r * Math.sin(phi - Math.PI / 2);
                
                if (i === 0) {
                    waveCtx.moveTo(x, y);
                } else {
                    waveCtx.lineTo(x, y);
                }
            }
            waveCtx.stroke();
            
            // Draw angle markers
            waveCtx.fillStyle = '#64748b';
            waveCtx.font = '11px sans-serif';
            waveCtx.textAlign = 'center';
            
            const angles = [
                { angle: 0, label: '0' },
                { angle: Math.PI / 2, label: 'π/2' },
                { angle: Math.PI, label: 'π' },
                { angle: 3 * Math.PI / 2, label: '3π/2' }
            ];
            
            angles.forEach(({ angle, label }) => {
                const markerR = baseRadius + displacementScale * 1.3;
                const x = centerX + markerR * Math.cos(angle - Math.PI / 2);
                const y = centerY + markerR * Math.sin(angle - Math.PI / 2);
                waveCtx.fillText(label, x, y + 4);
            });
            
            // Draw center dot
            waveCtx.fillStyle = '#475569';
            waveCtx.beginPath();
            waveCtx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
            waveCtx.fill();
            
            waveCtx.fillStyle = '#64748b';
            waveCtx.font = '10px sans-serif';
            waveCtx.textAlign = 'center';
            waveCtx.fillText('R = 1', centerX, centerY + 16);
        }
        
        // Animation loop
        function animate(currentTime) {
            const deltaTime = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;
            
            time += deltaTime;
            
            drawEnergyLevels();
            
            if (showOnRing) {
                drawWavefunctionRing();
            } else {
                drawWavefunctionPlot();
            }
            
            requestAnimationFrame(animate);
        }
        
        // Event listeners
        nSlider.addEventListener('input', (e) => {
            n = parseInt(e.target.value);
            nValueDisplay.textContent = n;
            updateStats();
        });
        
        toggleDisplayBtn.addEventListener('click', () => {
            showOnRing = !showOnRing;
            toggleDisplayBtn.textContent = showOnRing ? 'Show on Plot' : 'Show on Ring';
        });
        
        showProbabilityCheckbox.addEventListener('change', (e) => {
            showProbability = e.target.checked;
        });
        
        animatePhaseCheckbox.addEventListener('change', (e) => {
            animatePhase = e.target.checked;
            updateWavefunctionTitle();
        });
        
        speedSlider.addEventListener('input', (e) => {
            timeSpeed = parseFloat(e.target.value);
            speedValueDisplay.textContent = timeSpeed.toFixed(1) + 'x';
        });
        
        window.addEventListener('resize', resizeCanvases);
        
        // Initialize
        resizeCanvases();
        updateStats();
        requestAnimationFrame(animate);
    </script>
</body>
</html>