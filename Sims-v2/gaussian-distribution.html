<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Distribution Simulator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: #0f172a; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            color: #e2e8f0;
        }
        
        .title-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 280px;
            height: 50px;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            display: flex;
            align-items: center;
            padding: 0 30px;
            z-index: 1000;
        }
        
        .title {
            font-size: 18px;
            font-weight: 600;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .title-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .info-icon-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            margin-left: 12px;
        }
        
        .info-icon {
            width: 22px;
            height: 22px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 600;
            color: #60a5fa;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .info-icon:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.6);
        }
        
        .info-tooltip {
            position: absolute;
            top: 35px;
            left: 50%;
            transform: translateX(-50%);
            width: 380px;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 20px;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        .info-icon-container:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
        }
        
        .info-tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(148, 163, 184, 0.2);
        }
        
        .info-tooltip::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid rgba(15, 23, 42, 0.98);
        }
        
        .info-tooltip-title {
            color: #f1f5f9;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .info-tooltip-text {
            color: #94a3b8;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .info-tooltip .formula-container {
            margin-top: 15px;
            padding: 12px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            text-align: center;
        }
        
        .info-tooltip .formula-label {
            color: #64748b;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        
        .info-tooltip .formula-container .katex {
            color: #e2e8f0;
        }
        
        .right-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 280px;
            height: 100vh;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(12px);
            border-left: 1px solid rgba(148, 163, 184, 0.1);
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .panel-section {
            margin-bottom: 25px;
        }
        
        .panel-section-title {
            color: #94a3b8;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .stat-group {
            display: flex;
            gap: 20px;
            font-size: 13px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            flex: 1;
        }
        
        .stat-label {
            color: #64748b;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            color: #f1f5f9;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            font-size: 14px;
        }
        
        .control {
            margin-bottom: 15px;
        }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            margin-bottom: 6px;
        }
        
        .control-label {
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-value {
            color: #60a5fa;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #3b82f6, #60a5fa);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }
        
        .slider.sigma::-webkit-slider-thumb {
            background: linear-gradient(135deg, #8b5cf6, #a78bfa);
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
        }
        
        .slider.rate::-webkit-slider-thumb {
            background: linear-gradient(135deg, #22c55e, #4ade80);
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.4);
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            flex: 1;
            padding: 10px 16px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            color: #60a5fa;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        .btn.active {
            background: #3b82f6;
            color: white;
        }
        
        #canvas-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 280px;
            bottom: 0;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .info-label {
            color: #64748b;
        }
        
        .info-value {
            color: #f1f5f9;
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .legend-item:last-child {
            margin-bottom: 0;
        }
        
        .legend-color {
            width: 24px;
            height: 4px;
            border-radius: 2px;
        }
        
        .legend-text {
            color: #94a3b8;
            font-size: 12px;
        }

        /* NARRATION PANEL */
        .narration-panel {
            background: rgba(30, 41, 59, 0.7);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-bottom: 25px;
        }
        .narration-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 8px 12px;
            background: rgba(59, 130, 246, 0.06);
            border-bottom: 1px solid rgba(148, 163, 184, 0.08);
        }
        .narration-header-left {
            display: flex;
            align-items: center;
            gap: 7px;
        }
        .narr-icon { font-size: 12px; }
        .narration-header-left span {
            font-size: 10px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .narration-controls {
            display: flex;
            gap: 3px;
            align-items: center;
        }
        .narr-btn {
            width: 26px;
            height: 26px;
            border-radius: 50%;
            border: 1px solid rgba(148, 163, 184, 0.2);
            background: rgba(15, 23, 42, 0.6);
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            transition: all 0.2s;
            padding: 0;
        }
        .narr-btn:hover {
            border-color: rgba(59, 130, 246, 0.5);
            color: #60a5fa;
            background: rgba(59, 130, 246, 0.1);
        }
        .narr-btn.active {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.4);
            color: #60a5fa;
        }
        .narration-progress {
            height: 2px;
            background: rgba(148, 163, 184, 0.1);
        }
        .narration-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            width: 0%;
            transition: width 0.3s linear;
        }
        .narration-body {
            padding: 10px 12px;
            min-height: 52px;
            display: flex;
            align-items: center;
        }
        .narration-text {
            font-size: 11.5px;
            color: #cbd5e1;
            line-height: 1.55;
            margin: 0;
        }
        .narration-text .hl {
            color: #60a5fa;
            font-weight: 600;
        }
        .narration-text .hl-purple {
            color: #a78bfa;
            font-weight: 600;
        }
        .narration-text .hl-green {
            color: #4ade80;
            font-weight: 600;
        }
        .narration-text .hl-yellow {
            color: #fbbf24;
            font-weight: 600;
        }
        .narration-text .hl-red {
            color: #f87171;
            font-weight: 600;
        }
        .narr-step-dots {
            display: flex;
            justify-content: center;
            gap: 5px;
            padding: 5px 12px 8px;
        }
        .narr-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: rgba(148, 163, 184, 0.2);
            transition: all 0.3s;
            cursor: pointer;
        }
        .narr-dot.active {
            background: #60a5fa;
            box-shadow: 0 0 5px rgba(96, 165, 250, 0.5);
        }
        .narr-dot.completed {
            background: rgba(148, 163, 184, 0.4);
        }
    </style>
</head>
<body>
    <div class="title-bar">
        <div class="title">
            <div class="title-icon">üìä</div>
            <span>Gaussian Distribution Simulator</span>
            <div class="info-icon-container">
                <div class="info-icon">i</div>
                <div class="info-tooltip">
                    <div class="info-tooltip-title">About the Simulation</div>
                    <p class="info-tooltip-text">
                        This interactive visualization demonstrates the Gaussian (Normal) distribution, one of the most important probability distributions in statistics. 
                        <br><br>
                        A measurement window below the x-axis shows where random samples are being measured. Each measurement appears as a green marker that flashes at a random position within the distribution range. The position is determined by the Gaussian probability distribution using the Box-Muller transform.
                        <br><br>
                        As measurements accumulate, they form a histogram (green bars) that converges to the theoretical bell curve (blue line). The height of each bar represents how frequently that region has been measured.
                        <br><br>
                        The shaded regions show the standard deviation intervals: 1œÉ (green, 68.27%), 2œÉ (yellow, 95.45%), and 3œÉ (red, 99.73%) of data falls within these regions.
                        <br><br>
                        Adjust the mean (Œº) to shift the distribution's center, or change the standard deviation (œÉ) to control its spread. The sample rate controls how many measurements are taken per second (1-100).
                    </p>
                    <div class="formula-container">
                        <div class="formula-label">Gaussian PDF Formula</div>
                        <div id="gaussianFormula"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="right-panel">
        <!-- NARRATION PANEL -->
        <div class="narration-panel" id="narration-panel">
            <div class="narration-header">
                <div class="narration-header-left">
                    <div class="narr-icon">üîä</div>
                    <span>Simulation Context</span>
                </div>
                <div class="narration-controls">
                    <button class="narr-btn" id="narr-back" title="Previous step">‚è™</button>
                    <button class="narr-btn" id="narr-play" title="Play">‚ñ∂</button>
                    <button class="narr-btn" id="narr-pause" title="Pause">‚è∏</button>
                </div>
            </div>
            <div class="narration-progress">
                <div class="narration-progress-bar" id="narr-progress-bar"></div>
            </div>
            <div class="narration-body">
                <p class="narration-text" id="narration-text"></p>
            </div>
            <div class="narr-step-dots" id="narr-dots"></div>
        </div>

        <div class="panel-section">
            <div class="panel-section-title">Statistics</div>
            <div class="stat-group">
                <div class="stat">
                    <span class="stat-label">Samples</span>
                    <span class="stat-value" id="sampleCount">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Time (s)</span>
                    <span class="stat-value" id="elapsedTime">0.0</span>
                </div>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-section-title">Controls</div>
            <div class="control">
                <div class="control-header">
                    <span class="control-label">Mean (Œº)</span>
                    <span class="control-value" id="muValue">0.00</span>
                </div>
                <input type="range" class="slider" id="muSlider" min="-3" max="3" step="0.1" value="0">
            </div>
            
            <div class="control">
                <div class="control-header">
                    <span class="control-label">Std Dev (œÉ)</span>
                    <span class="control-value" id="sigmaValue">1.00</span>
                </div>
                <input type="range" class="slider sigma" id="sigmaSlider" min="0.2" max="3" step="0.1" value="1">
            </div>
            
            <div class="control">
                <div class="control-header">
                    <span class="control-label">Sample Rate (measurements/sec)</span>
                    <span class="control-value" id="rateValue">10</span>
                </div>
                <input type="range" class="slider rate" id="rateSlider" min="1" max="100" step="1" value="10">
            </div>
            
            <div class="btn-group">
                <button class="btn" id="resetBtn">Reset</button>
                <button class="btn" id="pauseBtn">Pause</button>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-section-title">Distribution Stats</div>
            <div class="info-row">
                <span class="info-label">Mean (Œº):</span>
                <span class="info-value" id="infoMu">0.00</span>
            </div>
            <div class="info-row">
                <span class="info-label">Std Dev (œÉ):</span>
                <span class="info-value" id="infoSigma">1.00</span>
            </div>
            <div class="info-row">
                <span class="info-label">Variance (œÉ¬≤):</span>
                <span class="info-value" id="infoVariance">1.00</span>
            </div>
            <div class="info-row">
                <span class="info-label">Peak Height:</span>
                <span class="info-value" id="infoPeak">0.399</span>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-section-title">Legend</div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(90deg, #3b82f6, #60a5fa);"></div>
                <span class="legend-text">PDF Curve</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8BD282;"></div>
                <span class="legend-text">Sample Histogram</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #22c55e;"></div>
                <span class="legend-text">Measurement Marker</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(34, 197, 94, 0.3);"></div>
                <span class="legend-text">1œÉ Region (68.27%)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(251, 191, 36, 0.3);"></div>
                <span class="legend-text">2œÉ Region (95.45%)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(239, 68, 68, 0.3);"></div>
                <span class="legend-text">3œÉ Region (99.73%)</span>
            </div>
        </div>
    </div>
    
    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>
    
    <script>
        // Render the Gaussian formula using KaTeX
        document.addEventListener('DOMContentLoaded', function() {
            katex.render(
                "f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2}",
                document.getElementById('gaussianFormula'),
                { displayMode: true, throwOnError: false }
            );
        });
        
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // Parameters - default sample rate is now 10 measurements/second
        let mu = 0;
        let sigma = 1;
        let sampleRate = 10; // Default: 10 measurements per second
        let isPaused = false;
        
        // X-axis range - increased from -5,5 to -10,10
        const xMin = -10;
        const xMax = 10;
        const xRange = xMax - xMin; // 20
        
        // Animation state
        let histogram = new Array(80).fill(0); // Increased bins for wider range
        let totalSamples = 0;
        let sampleAccumulator = 0;
        let totalElapsedTime = 0;
        
        // Measurement window state
        let measurementWindowHeight = 70; // Height of the measurement window below x-axis
        let currentMeasurement = null; // Current measurement marker {x, value, alpha, life}
        let measurementFlashes = []; // Array of flash effects
        
        // Canvas dimensions
        let width, height;
        let graphLeft, graphRight, graphTop, graphBottom;
        let graphWidth, graphHeight;
        let measurementTop, measurementBottom; // Measurement window bounds
        let measurementLeft, measurementRight; // Extended measurement window horizontal bounds
        
        function resize() {
            width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;
            
            graphLeft = 90;
            graphRight = w - 50;
            graphTop = 70;
            graphBottom = h - 130 - measurementWindowHeight; // Increased space for x-axis label below axis
            graphWidth = graphRight - graphLeft;
            graphHeight = graphBottom - graphTop;
            
            // Measurement window bounds - moved down to accommodate x-axis label
            measurementTop = graphBottom + 55;
            measurementBottom = h - 35;
            
            // Extended measurement window horizontal bounds (20 pixels wider on each side)
            measurementLeft = graphLeft - 20;
            measurementRight = graphRight + 20;
        }
        
        // Gaussian PDF
        function gaussian(x, mu, sigma) {
            const coeff = 1 / (sigma * Math.sqrt(2 * Math.PI));
            const exponent = -0.5 * Math.pow((x - mu) / sigma, 2);
            return coeff * Math.exp(exponent);
        }
        
        // Box-Muller transform for generating Gaussian samples
        // Uses do-while to ensure u1 is never exactly 0 (avoids log(0) = -Infinity)
        function generateGaussianSample() {
            let u1, u2;
            do {
                u1 = Math.random();
            } while (u1 === 0);
            u2 = Math.random();

            const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mu + sigma * z;
        }
        
        // Convert x value to canvas x
        function xToCanvas(x) {
            return graphLeft + ((x - xMin) / xRange) * graphWidth;
        }
        
        // Convert y value to canvas y
        function yToCanvas(y, maxY) {
            return graphBottom - (y / maxY) * graphHeight;
        }
        
        // Get histogram bin for x value
        function getBin(x) {
            const bin = Math.floor(((x - xMin) / xRange) * histogram.length);
            return Math.max(0, Math.min(histogram.length - 1, bin));
        }
        
        // Reset histogram and measurements
        function resetHistogram() {
            histogram = new Array(80).fill(0);
            totalSamples = 0;
            sampleAccumulator = 0;
            totalElapsedTime = 0;
            currentMeasurement = null;
            measurementFlashes = [];
            previousTime = null;
        }
        
        function drawGrid() {
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.1)';
            ctx.lineWidth = 1;
            
            // Vertical grid lines - every 2 units for wider range
            for (let x = xMin; x <= xMax; x += 2) {
                const canvasX = xToCanvas(x);
                ctx.beginPath();
                ctx.moveTo(canvasX, graphTop);
                ctx.lineTo(canvasX, graphBottom);
                ctx.stroke();
            }
            
            // Horizontal grid lines ‚Äî step matches y-axis labels
            const maxY = getDynamicMaxY();
            const gridYStep = maxY <= 0.5 ? 0.1 : (maxY <= 1.0 ? 0.2 : 0.5);
            for (let y = 0; y <= maxY; y += gridYStep) {
                const canvasY = yToCanvas(y, maxY);
                ctx.beginPath();
                ctx.moveTo(graphLeft, canvasY);
                ctx.lineTo(graphRight, canvasY);
                ctx.stroke();
            }
        }
        
        // Draw standard deviation regions
        function drawStdDevRegions() {
            const maxY = getDynamicMaxY();
            
            // 3œÉ region (outermost) - red
            drawSigmaRegion(3, 'rgba(239, 68, 68, 0.15)', 'rgba(239, 68, 68, 0.5)');
            
            // 2œÉ region - yellow/amber
            drawSigmaRegion(2, 'rgba(251, 191, 36, 0.15)', 'rgba(251, 191, 36, 0.5)');
            
            // 1œÉ region (innermost) - green
            drawSigmaRegion(1, 'rgba(34, 197, 94, 0.2)', 'rgba(34, 197, 94, 0.6)');
        }
        
        function drawSigmaRegion(numSigma, fillColor, strokeColor) {
            const maxY = getDynamicMaxY();
            const leftBound = mu - numSigma * sigma;
            const rightBound = mu + numSigma * sigma;
            
            // Clamp to visible range
            const xMinClamped = Math.max(xMin, leftBound);
            const xMaxClamped = Math.min(xMax, rightBound);
            
            if (xMinClamped >= xMaxClamped) return; // Region is outside visible area
            
            ctx.beginPath();
            ctx.moveTo(xToCanvas(xMinClamped), graphBottom);
            
            // Draw along the curve
            for (let x = xMinClamped; x <= xMaxClamped; x += 0.05) {
                const y = gaussian(x, mu, sigma);
                const canvasY = yToCanvas(y, maxY);
                ctx.lineTo(xToCanvas(x), canvasY);
            }
            
            // Close the path
            ctx.lineTo(xToCanvas(xMaxClamped), graphBottom);
            ctx.closePath();
            
            ctx.fillStyle = fillColor;
            ctx.fill();
            
            // Draw vertical boundary lines for the region
            ctx.strokeStyle = strokeColor;
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            
            if (leftBound >= xMin) {
                ctx.beginPath();
                ctx.moveTo(xToCanvas(leftBound), graphTop);
                ctx.lineTo(xToCanvas(leftBound), graphBottom);
                ctx.stroke();
            }
            
            if (rightBound <= xMax) {
                ctx.beginPath();
                ctx.moveTo(xToCanvas(rightBound), graphTop);
                ctx.lineTo(xToCanvas(rightBound), graphBottom);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        // Draw sigma labels at the top
        function drawSigmaLabels() {
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            
            // Draw labels for each sigma boundary
            const sigmaLabels = [
                { sigma: -3, label: '-3œÉ', color: 'rgba(239, 68, 68, 0.9)' },
                { sigma: -2, label: '-2œÉ', color: 'rgba(251, 191, 36, 0.9)' },
                { sigma: -1, label: '-1œÉ', color: 'rgba(34, 197, 94, 0.9)' },
                { sigma: 1, label: '+1œÉ', color: 'rgba(34, 197, 94, 0.9)' },
                { sigma: 2, label: '+2œÉ', color: 'rgba(251, 191, 36, 0.9)' },
                { sigma: 3, label: '+3œÉ', color: 'rgba(239, 68, 68, 0.9)' }
            ];
            
            const oneSigmaPixels = (sigma / xRange) * graphWidth;
            for (const item of sigmaLabels) {
                const x = mu + item.sigma * sigma;
                if (x >= xMin && x <= xMax) {
                    if (oneSigmaPixels < 12 && Math.abs(item.sigma) === 3) continue;
                    if (oneSigmaPixels < 8 && Math.abs(item.sigma) === 2) continue;
                    if (oneSigmaPixels < 6) continue;
                    const canvasX = xToCanvas(x);
                    ctx.fillStyle = item.color;
                    ctx.fillText(item.label, canvasX, graphTop - 12);
                }
            }
            
            // Draw Œº label at mean
            if (mu >= xMin && mu <= xMax) {
                ctx.fillStyle = 'rgba(96, 165, 250, 0.95)';
                ctx.font = 'bold 13px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillText('Œº', xToCanvas(mu), graphTop - 12);
            }
        }
        
        function drawAxes() {
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
            ctx.lineWidth = 2;
            
            // X axis
            ctx.beginPath();
            ctx.moveTo(graphLeft, graphBottom);
            ctx.lineTo(graphRight, graphBottom);
            ctx.stroke();
            
            // Y axis
            ctx.beginPath();
            ctx.moveTo(graphLeft, graphTop);
            ctx.lineTo(graphLeft, graphBottom);
            ctx.stroke();
            
            // X-axis coordinate labels - positioned below the axis, every 2 units
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            
            for (let x = xMin; x <= xMax; x += 2) {
                const canvasX = xToCanvas(x);
                ctx.fillText(x.toString(), canvasX, graphBottom + 22);
            }
            
            // X-axis title - positioned below the coordinate labels
            ctx.fillStyle = '#f1f5f9';
            ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('x', (graphLeft + graphRight) / 2, graphBottom + 45);
            
            // Y-axis labels - more prominent
            ctx.textAlign = 'right';
            ctx.font = 'bold 13px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#e2e8f0';
            const maxY = getDynamicMaxY();
            // Calculate appropriate step size based on maxY
            const yStep = maxY <= 0.5 ? 0.1 : (maxY <= 1.0 ? 0.2 : 0.5);
            for (let y = 0; y <= maxY; y += yStep) {
                const canvasY = yToCanvas(y, maxY);
                ctx.fillText(y.toFixed(1), graphLeft - 12, canvasY + 5);
            }
            
            // Y-axis title - more prominent
            ctx.fillStyle = '#f1f5f9';
            ctx.font = 'bold 16px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.save();
            ctx.translate(28, (graphTop + graphBottom) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Probability Density', 0, 0);
            ctx.restore();
        }
        
        // Calculate dynamic Y-axis maximum based on current sigma
        // For small sigma, peak can exceed 0.5, so we scale dynamically
        function getDynamicMaxY() {
            const theoreticalPeak = 1 / (sigma * Math.sqrt(2 * Math.PI));
            // Add 10% headroom above theoretical peak, minimum of 0.5
            return Math.max(0.5, theoreticalPeak * 1.1);
        }

        function drawHistogram() {
            if (totalSamples === 0) return;

            const maxY = getDynamicMaxY();
            const binWidth = graphWidth / histogram.length;
            const binXWidth = xRange / histogram.length;
            
            // Changed to new green color #8BD282
            ctx.fillStyle = 'rgba(139, 210, 130, 0.3)';
            ctx.strokeStyle = 'rgba(139, 210, 130, 0.6)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < histogram.length; i++) {
                if (histogram[i] === 0) continue;
                
                // Convert count to density
                const density = (histogram[i] / totalSamples) / binXWidth;
                const barHeight = (density / maxY) * graphHeight;
                const x = graphLeft + i * binWidth;
                const y = graphBottom - barHeight;
                
                ctx.fillRect(x, y, binWidth - 1, barHeight);
                ctx.strokeRect(x, y, binWidth - 1, barHeight);
            }
        }
        
        function drawGaussianCurve() {
            const maxY = getDynamicMaxY();
            
            // Draw curve line with glow
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            for (let px = graphLeft; px <= graphRight; px++) {
                const x = xMin + ((px - graphLeft) / graphWidth) * xRange;
                const y = gaussian(x, mu, sigma);
                const canvasY = yToCanvas(y, maxY);
                
                if (px === graphLeft) {
                    ctx.moveTo(px, canvasY);
                } else {
                    ctx.lineTo(px, canvasY);
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw mean line
            const meanX = xToCanvas(mu);
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(meanX, graphTop);
            ctx.lineTo(meanX, graphBottom);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Draw the measurement window below the x-axis
        function drawMeasurementWindow() {
            const windowHeight = measurementBottom - measurementTop;
            
            // Draw measurement window background with extended horizontal bounds
            ctx.fillStyle = 'rgba(30, 41, 59, 0.9)';
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.4)';
            ctx.lineWidth = 2;
            
            // Rounded rectangle for measurement window - using extended bounds
            const radius = 10;
            ctx.beginPath();
            ctx.moveTo(measurementLeft + radius, measurementTop);
            ctx.lineTo(measurementRight - radius, measurementTop);
            ctx.quadraticCurveTo(measurementRight, measurementTop, measurementRight, measurementTop + radius);
            ctx.lineTo(measurementRight, measurementBottom - radius);
            ctx.quadraticCurveTo(measurementRight, measurementBottom, measurementRight - radius, measurementBottom);
            ctx.lineTo(measurementLeft + radius, measurementBottom);
            ctx.quadraticCurveTo(measurementLeft, measurementBottom, measurementLeft, measurementBottom - radius);
            ctx.lineTo(measurementLeft, measurementTop + radius);
            ctx.quadraticCurveTo(measurementLeft, measurementTop, measurementLeft + radius, measurementTop);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw "MEASUREMENT WINDOW" label - positioned at top left, above the tick marks area
            ctx.fillStyle = '#22c55e';
            ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('üìç MEASUREMENT WINDOW', measurementLeft + 10, measurementTop + 14);
            
            // Draw tick marks aligned with x-axis - positioned lower to avoid label overlap, every 2 units
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
            ctx.lineWidth = 1;
            const tickStartY = measurementTop + 22;
            for (let x = xMin; x <= xMax; x += 2) {
                const canvasX = xToCanvas(x);
                ctx.beginPath();
                ctx.moveTo(canvasX, tickStartY);
                ctx.lineTo(canvasX, tickStartY + 8);
                ctx.stroke();
                
                // Add small coordinate labels in measurement window
                ctx.fillStyle = 'rgba(148, 163, 184, 0.6)';
                ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(x.toString(), canvasX, tickStartY + 18);
            }
            
            // Draw measurement flashes (fading circles) - GREEN
            const markerCenterY = (measurementTop + measurementBottom) / 2 + 12;
            for (const flash of measurementFlashes) {
                const canvasX = xToCanvas(flash.value);
                
                // Draw expanding ring - GREEN
                ctx.beginPath();
                ctx.arc(canvasX, markerCenterY, flash.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(34, 197, 94, ${flash.alpha * 0.5})`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw center glow - GREEN
                const gradient = ctx.createRadialGradient(canvasX, markerCenterY, 0, canvasX, markerCenterY, 15);
                gradient.addColorStop(0, `rgba(34, 197, 94, ${flash.alpha})`);
                gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(canvasX, markerCenterY, 15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw current measurement marker - GREEN
            if (currentMeasurement) {
                const canvasX = xToCanvas(currentMeasurement.value);
                
                // Draw vertical line from measurement to histogram - GREEN
                ctx.strokeStyle = `rgba(34, 197, 94, ${currentMeasurement.alpha * 0.3})`;
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(canvasX, measurementTop);
                ctx.lineTo(canvasX, graphBottom);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw marker diamond - GREEN
                ctx.fillStyle = `rgba(34, 197, 94, ${currentMeasurement.alpha})`;
                ctx.beginPath();
                const size = 8;
                ctx.moveTo(canvasX, markerCenterY - size);
                ctx.lineTo(canvasX + size, markerCenterY);
                ctx.lineTo(canvasX, markerCenterY + size);
                ctx.lineTo(canvasX - size, markerCenterY);
                ctx.closePath();
                ctx.fill();
                
                // Draw glow around marker - GREEN
                ctx.shadowColor = '#22c55e';
                ctx.shadowBlur = 15 * currentMeasurement.alpha;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Draw value label - GREEN
                ctx.fillStyle = `rgba(34, 197, 94, ${currentMeasurement.alpha})`;
                ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(currentMeasurement.value.toFixed(2), canvasX, markerCenterY + 24);
            }
        }
        
        function updateMeasurements() {
            // Update current measurement fade
            if (currentMeasurement) {
                currentMeasurement.life--;
                currentMeasurement.alpha = Math.max(0, currentMeasurement.life / 30);
                if (currentMeasurement.life <= 0) {
                    currentMeasurement = null;
                }
            }
            
            // Update flash effects
            for (let i = measurementFlashes.length - 1; i >= 0; i--) {
                const flash = measurementFlashes[i];
                flash.life--;
                flash.alpha = flash.life / flash.maxLife;
                flash.radius += 2; // Expand the ring
                if (flash.life <= 0) {
                    measurementFlashes.splice(i, 1);
                }
            }
        }
        
        function addSamples(deltaTime) {
            if (isPaused) return;
            
            // Calculate how many samples to add based on sample rate and elapsed time
            sampleAccumulator += sampleRate * deltaTime;
            
            // Add whole number of samples
            const samplesToAdd = Math.floor(sampleAccumulator);
            sampleAccumulator -= samplesToAdd;
            
            for (let i = 0; i < samplesToAdd; i++) {
                const value = generateGaussianSample();
                totalSamples++;
                
                if (value >= xMin && value <= xMax) {
                    const bin = getBin(value);
                    histogram[bin]++;
                    
                    currentMeasurement = {
                        value: value,
                        alpha: 1,
                        life: 30
                    };
                    
                    if (measurementFlashes.length < 15) {
                        measurementFlashes.push({
                            value: value,
                            alpha: 1,
                            radius: 5,
                            life: 20,
                            maxLife: 20
                        });
                    }
                }
            }
        }
        
        function updateStats() {
            document.getElementById('sampleCount').textContent = totalSamples.toLocaleString();
            document.getElementById('elapsedTime').textContent = totalElapsedTime.toFixed(1);
            document.getElementById('infoMu').textContent = mu.toFixed(2);
            document.getElementById('infoSigma').textContent = sigma.toFixed(2);
            document.getElementById('infoVariance').textContent = (sigma * sigma).toFixed(2);
            document.getElementById('infoPeak').textContent = gaussian(mu, mu, sigma).toFixed(3);
        }
        
        function draw() {
            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;
            
            // Clear canvas
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, w, h);
            
            drawGrid();
            drawStdDevRegions();
            drawHistogram();
            drawGaussianCurve();
            drawSigmaLabels();
            drawAxes();
            drawMeasurementWindow();
        }
        
        let previousTime = null;
        
        function animate(currentTime) {
            if (previousTime === null) {
                previousTime = currentTime;
                requestAnimationFrame(animate);
                return;
            }
            
            // Calculate delta time in seconds
            let deltaTime = (currentTime - previousTime) / 1000;
            previousTime = currentTime;
            
            // Cap deltaTime to prevent huge bursts after tab switching or lag
            deltaTime = Math.min(deltaTime, 0.1);
            
            // Track total elapsed time (only when not paused)
            if (!isPaused) {
                totalElapsedTime += deltaTime;
            }
            
            // Add samples based on actual elapsed time
            addSamples(deltaTime);
            
            updateMeasurements();
            updateStats();
            draw();
            
            requestAnimationFrame(animate);
        }
        
        // Event listeners
        document.getElementById('muSlider').addEventListener('input', (e) => {
            mu = parseFloat(e.target.value);
            document.getElementById('muValue').textContent = mu.toFixed(2);
            resetHistogram();
        });
        
        document.getElementById('sigmaSlider').addEventListener('input', (e) => {
            sigma = parseFloat(e.target.value);
            document.getElementById('sigmaValue').textContent = sigma.toFixed(2);
            resetHistogram();
        });
        
        document.getElementById('rateSlider').addEventListener('input', (e) => {
            sampleRate = parseInt(e.target.value);
            document.getElementById('rateValue').textContent = sampleRate;
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            resetHistogram();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            isPaused = !isPaused;
            if (!isPaused) {
                previousTime = null;
            }
            e.target.textContent = isPaused ? 'Resume' : 'Pause';
            e.target.classList.toggle('active', isPaused);
        });
        
        window.addEventListener('resize', resize);
        
        // Initialize
        resize();
        requestAnimationFrame(animate);

        // --- NARRATION / VOICEOVER ENGINE ---
        const narrationSteps = [
            {
                text: `Welcome to the <span class="hl">Gaussian Distribution Simulator</span>. The Gaussian ‚Äî also called the normal distribution or bell curve ‚Äî is arguably the most important distribution in all of science, from quantum mechanics to data science.`,
                speech: `Welcome to the Gaussian Distribution Simulator. The Gaussian ‚Äî also called the normal distribution or bell curve ‚Äî is arguably the most important distribution in all of science, from quantum mechanics to data science.`,
                duration: 12000
            },
            {
                text: `Watch the <span class="hl-green">measurement window</span> below the x-axis. Each green flash represents a single random measurement being drawn from the distribution. The position of each sample is determined by the Gaussian probability using the Box-Muller transform.`,
                speech: `Watch the measurement window below the x-axis. Each green flash represents a single random measurement being drawn from the distribution. The position of each sample is determined by the Gaussian probability using the Box-Muller transform.`,
                duration: 12000
            },
            {
                text: `As measurements accumulate, the <span class="hl-green">green histogram bars</span> grow ‚Äî showing how frequently each region has been sampled. Over time, this histogram converges toward the theoretical <span class="hl">blue bell curve</span>. This is the law of large numbers in action.`,
                speech: `As measurements accumulate, the green histogram bars grow ‚Äî showing how frequently each region has been sampled. Over time, this histogram converges toward the theoretical blue bell curve. This is the law of large numbers in action.`,
                duration: 12000
            },
            {
                text: `The <span class="hl">mean mu</span> controls where the peak sits ‚Äî it's the center of the distribution. Try dragging the mu slider to shift the entire bell curve left or right along the x-axis.`,
                speech: `The mean mu controls where the peak sits ‚Äî it's the center of the distribution. Try dragging the mu slider to shift the entire bell curve left or right along the x-axis.`,
                duration: 10000
            },
            {
                text: `The <span class="hl-purple">standard deviation sigma</span> controls the spread. A small sigma gives a tall, narrow peak ‚Äî measurements cluster tightly around the mean. A large sigma gives a wide, flat curve ‚Äî measurements spread out more.`,
                speech: `The standard deviation sigma controls the spread. A small sigma gives a tall, narrow peak ‚Äî measurements cluster tightly around the mean. A large sigma gives a wide, flat curve ‚Äî measurements spread out more.`,
                duration: 12000
            },
            {
                text: `Notice the colored shaded regions: <span class="hl-green">1 sigma</span> (green) captures 68.27% of all data, <span class="hl-yellow">2 sigma</span> (yellow) captures 95.45%, and <span class="hl-red">3 sigma</span> (red) captures 99.73%. These are the famous 68-95-99.7 rule.`,
                speech: `Notice the colored shaded regions: 1 sigma, shown in green, captures 68.27% of all data. 2 sigma, in yellow, captures 95.45%. And 3 sigma, in red, captures 99.73%. These are the famous 68-95-99.7 rule.`,
                duration: 13000
            },
            {
                text: `This is why the Gaussian matters everywhere: measurement errors in a physics lab, heights in a population, thermal velocities of gas molecules ‚Äî they all follow this shape. The <span class="hl">Central Limit Theorem</span> guarantees that averages of many independent effects tend toward a Gaussian.`,
                speech: `This is why the Gaussian matters everywhere: measurement errors in a physics lab, heights in a population, thermal velocities of gas molecules ‚Äî they all follow this shape. The Central Limit Theorem guarantees that averages of many independent effects tend toward a Gaussian.`,
                duration: 14000
            },
            {
                text: `Try increasing the <span class="hl-green">sample rate</span> to 100 measurements per second and watch the histogram rapidly converge to the bell curve. Then reset and try a different sigma to see how the shape changes. The statistics panel tracks everything live.`,
                speech: `Try increasing the sample rate to 100 measurements per second and watch the histogram rapidly converge to the bell curve. Then reset and try a different sigma to see how the shape changes. The statistics panel tracks everything live.`,
                duration: 12000
            }
        ];

        let narration = {
            currentStep: 0,
            isPlaying: false,
            timer: null,
            utterance: null,
            speechSupported: 'speechSynthesis' in window
        };

        function initNarration() {
            const dotsContainer = document.getElementById('narr-dots');
            narrationSteps.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'narr-dot' + (i === 0 ? ' active' : '');
                dot.onclick = () => jumpToStep(i);
                dotsContainer.appendChild(dot);
            });

            document.getElementById('narr-play').onclick = playNarration;
            document.getElementById('narr-pause').onclick = pauseNarration;
            document.getElementById('narr-back').onclick = goBackOneStep;

            showStep(0);
        }

        function showStep(index) {
            narration.currentStep = index;
            document.getElementById('narration-text').innerHTML = narrationSteps[index].text;

            const dots = document.querySelectorAll('.narr-dot');
            dots.forEach((dot, i) => {
                dot.className = 'narr-dot';
                if (i < index) dot.classList.add('completed');
                if (i === index) dot.classList.add('active');
            });

            const progress = (index / (narrationSteps.length - 1)) * 100;
            document.getElementById('narr-progress-bar').style.width = progress + '%';
        }

        function finishNarration() {
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');

            if (narration.speechSupported) window.speechSynthesis.cancel();
            if (narration.timer) { clearTimeout(narration.timer); narration.timer = null; }

            narration.timer = setTimeout(() => {
                narration.currentStep = 0;
                showStep(0);
                document.getElementById('narr-progress-bar').style.width = '0%';
                narration.timer = null;
            }, 1200);
        }

        function speakStep(index) {
            if (!narration.speechSupported) return;
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(narrationSteps[index].speech);
            utterance.rate = 0.92;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Select Samantha voice (priority), fallback to any English voice
            const voices = window.speechSynthesis.getVoices();
            const samantha = voices.find(v => v.name.includes('Samantha'));
            const fallback = voices.find(v => v.lang.startsWith('en') && (v.name.includes('Google') || v.name.includes('Natural') || v.name.includes('Daniel'))) || voices.find(v => v.lang.startsWith('en'));
            utterance.voice = samantha || fallback || null;

            utterance.onend = () => {
                if (!narration.isPlaying) return;
                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) {
                    finishNarration();
                } else {
                    narration.timer = setTimeout(() => {
                        if (narration.isPlaying) { showStep(nextIndex); speakStep(nextIndex); }
                    }, 800);
                }
            };

            narration.utterance = utterance;
            window.speechSynthesis.speak(utterance);
        }

        function playNarration() {
            if (narration.isPlaying) return;
            narration.isPlaying = true;
            document.getElementById('narr-play').classList.add('active');
            document.getElementById('narr-pause').classList.remove('active');

            if (narration.timer) { clearTimeout(narration.timer); narration.timer = null; }

            if (narration.speechSupported) {
                if (window.speechSynthesis.getVoices().length === 0) {
                    window.speechSynthesis.onvoiceschanged = () => speakStep(narration.currentStep);
                } else {
                    speakStep(narration.currentStep);
                }
            } else {
                advanceByTimer();
            }
        }

        function advanceByTimer() {
            if (!narration.isPlaying) return;
            narration.timer = setTimeout(() => {
                if (!narration.isPlaying) return;
                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) { finishNarration(); }
                else { showStep(nextIndex); advanceByTimer(); }
            }, narrationSteps[narration.currentStep].duration);
        }

        function pauseNarration() {
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');
            document.getElementById('narr-pause').classList.add('active');
            if (narration.speechSupported) window.speechSynthesis.cancel();
            if (narration.timer) { clearTimeout(narration.timer); narration.timer = null; }
        }

        function goBackOneStep() {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');
            const prevStep = Math.max(0, narration.currentStep - 1);
            narration.currentStep = prevStep;
            showStep(prevStep);
            if (wasPlaying) playNarration();
        }

        function jumpToStep(index) {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');
            narration.currentStep = index;
            showStep(index);
            if (wasPlaying) playNarration();
        }

        initNarration();
    </script>
</body>
</html>

// made fixes tothe front end and rendering issues