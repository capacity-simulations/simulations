<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gaussian Distribution Simulator</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: #0f172a; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            color: #e2e8f0;
        }
        
        .title-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 280px;
            height: 50px;
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            display: flex;
            align-items: center;
            padding: 0 30px;
            z-index: 1000;
        }
        
        .title {
            font-size: 18px;
            font-weight: 600;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .title-icon {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
        }
        
        .info-icon-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            margin-left: 12px;
        }
        
        .info-icon {
            width: 22px;
            height: 22px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.4);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 13px;
            font-weight: 600;
            color: #60a5fa;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .info-icon:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.6);
        }
        
        .info-tooltip {
            position: absolute;
            top: 35px;
            left: 50%;
            transform: translateX(-50%);
            width: 380px;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 12px;
            padding: 20px;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
        }
        
        .info-icon-container:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
        }
        
        .info-tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid rgba(148, 163, 184, 0.2);
        }
        
        .info-tooltip::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid rgba(15, 23, 42, 0.98);
        }
        
        .info-tooltip-title {
            color: #f1f5f9;
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .info-tooltip-text {
            color: #94a3b8;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .info-tooltip .formula-container {
            margin-top: 15px;
            padding: 12px;
            background: rgba(59, 130, 246, 0.1);
            border-radius: 8px;
            border: 1px solid rgba(59, 130, 246, 0.2);
            text-align: center;
        }
        
        .info-tooltip .formula-label {
            color: #64748b;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }
        
        .info-tooltip .formula-container .katex {
            color: #e2e8f0;
        }
        
        .right-panel {
            position: fixed;
            top: 0;
            right: 0;
            width: 280px;
            height: 100vh;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(12px);
            border-left: 1px solid rgba(148, 163, 184, 0.1);
            padding: 20px;
            overflow-y: auto;
            z-index: 1000;
        }
        
        .panel-section {
            margin-bottom: 25px;
        }
        
        .panel-section-title {
            color: #94a3b8;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .stat-group {
            display: flex;
            gap: 20px;
            font-size: 13px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 2px;
            flex: 1;
        }
        
        .stat-label {
            color: #64748b;
            font-size: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            color: #f1f5f9;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
            font-size: 14px;
        }
        
        .control {
            margin-bottom: 15px;
        }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 11px;
            margin-bottom: 6px;
        }
        
        .control-label {
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .control-value {
            color: #60a5fa;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: linear-gradient(135deg, #3b82f6, #60a5fa);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }
        
        .slider.sigma::-webkit-slider-thumb {
            background: linear-gradient(135deg, #8b5cf6, #a78bfa);
            box-shadow: 0 2px 8px rgba(139, 92, 246, 0.4);
        }
        
        .slider.rate::-webkit-slider-thumb {
            background: linear-gradient(135deg, #22c55e, #4ade80);
            box-shadow: 0 2px 8px rgba(34, 197, 94, 0.4);
        }
        
        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        
        .btn {
            flex: 1;
            padding: 10px 16px;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 6px;
            color: #60a5fa;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }
        
        .btn:hover {
            background: rgba(59, 130, 246, 0.3);
            border-color: rgba(59, 130, 246, 0.5);
        }
        
        .btn.active {
            background: #3b82f6;
            color: white;
        }
        
        #canvas-container {
            position: fixed;
            top: 50px;
            left: 0;
            right: 280px;
            bottom: 0;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 13px;
        }
        
        .info-label {
            color: #64748b;
        }
        
        .info-value {
            color: #f1f5f9;
            font-weight: 500;
            font-variant-numeric: tabular-nums;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 8px;
        }
        
        .legend-item:last-child {
            margin-bottom: 0;
        }
        
        .legend-color {
            width: 24px;
            height: 4px;
            border-radius: 2px;
        }
        
        .legend-text {
            color: #94a3b8;
            font-size: 12px;
        }
    </style>
</head>
<body>
    <div class="title-bar">
        <div class="title">
            <div class="title-icon">ðŸ“Š</div>
            <span>Gaussian Distribution Simulator</span>
            <div class="info-icon-container">
                <div class="info-icon">i</div>
                <div class="info-tooltip">
                    <div class="info-tooltip-title">About the Simulation</div>
                    <p class="info-tooltip-text">
                        This interactive visualization demonstrates the Gaussian (Normal) distribution, one of the most important probability distributions in statistics. 
                        <br><br>
                        A measurement window below the x-axis shows where random samples are being measured. Each measurement appears as a green marker that flashes at a random position within the distribution range. The position is determined by the Gaussian probability distribution using the Box-Muller transform.
                        <br><br>
                        As measurements accumulate, they form a histogram (green bars) that converges to the theoretical bell curve (blue line). The height of each bar represents how frequently that region has been measured.
                        <br><br>
                        The shaded regions show the standard deviation intervals: 1Ïƒ (green, 68.27%), 2Ïƒ (yellow, 95.45%), and 3Ïƒ (red, 99.73%) of data falls within these regions.
                        <br><br>
                        Adjust the mean (Î¼) to shift the distribution's center, or change the standard deviation (Ïƒ) to control its spread. The sample rate controls how many measurements are taken per second (1-100).
                    </p>
                    <div class="formula-container">
                        <div class="formula-label">Gaussian PDF Formula</div>
                        <div id="gaussianFormula"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="right-panel">
        <div class="panel-section">
            <div class="panel-section-title">Statistics</div>
            <div class="stat-group">
                <div class="stat">
                    <span class="stat-label">Samples</span>
                    <span class="stat-value" id="sampleCount">0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Time (s)</span>
                    <span class="stat-value" id="elapsedTime">0.0</span>
                </div>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-section-title">Controls</div>
            <div class="control">
                <div class="control-header">
                    <span class="control-label">Mean (Î¼)</span>
                    <span class="control-value" id="muValue">0.00</span>
                </div>
                <input type="range" class="slider" id="muSlider" min="-3" max="3" step="0.1" value="0">
            </div>
            
            <div class="control">
                <div class="control-header">
                    <span class="control-label">Std Dev (Ïƒ)</span>
                    <span class="control-value" id="sigmaValue">1.00</span>
                </div>
                <input type="range" class="slider sigma" id="sigmaSlider" min="0.2" max="3" step="0.1" value="1">
            </div>
            
            <div class="control">
                <div class="control-header">
                    <span class="control-label">Sample Rate (measurements/sec)</span>
                    <span class="control-value" id="rateValue">10</span>
                </div>
                <input type="range" class="slider rate" id="rateSlider" min="1" max="100" step="1" value="10">
            </div>
            
            <div class="btn-group">
                <button class="btn" id="resetBtn">Reset</button>
                <button class="btn" id="pauseBtn">Pause</button>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-section-title">Distribution Stats</div>
            <div class="info-row">
                <span class="info-label">Mean (Î¼):</span>
                <span class="info-value" id="infoMu">0.00</span>
            </div>
            <div class="info-row">
                <span class="info-label">Std Dev (Ïƒ):</span>
                <span class="info-value" id="infoSigma">1.00</span>
            </div>
            <div class="info-row">
                <span class="info-label">Variance (ÏƒÂ²):</span>
                <span class="info-value" id="infoVariance">1.00</span>
            </div>
            <div class="info-row">
                <span class="info-label">Peak Height:</span>
                <span class="info-value" id="infoPeak">0.399</span>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-section-title">Legend</div>
            <div class="legend-item">
                <div class="legend-color" style="background: linear-gradient(90deg, #3b82f6, #60a5fa);"></div>
                <span class="legend-text">PDF Curve</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #8BD282;"></div>
                <span class="legend-text">Sample Histogram</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #22c55e;"></div>
                <span class="legend-text">Measurement Marker</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(34, 197, 94, 0.3);"></div>
                <span class="legend-text">1Ïƒ Region (68.27%)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(251, 191, 36, 0.3);"></div>
                <span class="legend-text">2Ïƒ Region (95.45%)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: rgba(239, 68, 68, 0.3);"></div>
                <span class="legend-text">3Ïƒ Region (99.73%)</span>
            </div>
        </div>
    </div>
    
    <div id="canvas-container">
        <canvas id="mainCanvas"></canvas>
    </div>
    
    <script>
        // Render the Gaussian formula using KaTeX
        document.addEventListener('DOMContentLoaded', function() {
            katex.render(
                "f(x) = \\frac{1}{\\sigma\\sqrt{2\\pi}} e^{-\\frac{1}{2}\\left(\\frac{x-\\mu}{\\sigma}\\right)^2}",
                document.getElementById('gaussianFormula'),
                { displayMode: true, throwOnError: false }
            );
        });
        
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        // Parameters - default sample rate is now 10 measurements/second
        let mu = 0;
        let sigma = 1;
        let sampleRate = 10; // Default: 10 measurements per second
        let isPaused = false;
        
        // X-axis range - increased from -5,5 to -10,10
        const xMin = -10;
        const xMax = 10;
        const xRange = xMax - xMin; // 20
        
        // Animation state
        let histogram = new Array(80).fill(0); // Increased bins for wider range
        let totalSamples = 0;
        let sampleAccumulator = 0;
        let totalElapsedTime = 0;
        let isFirstFrame = true;
        
        // Measurement window state
        let measurementWindowHeight = 70; // Height of the measurement window below x-axis
        let currentMeasurement = null; // Current measurement marker {x, value, alpha, life}
        let measurementFlashes = []; // Array of flash effects
        
        // Canvas dimensions
        let width, height;
        let graphLeft, graphRight, graphTop, graphBottom;
        let graphWidth, graphHeight;
        let measurementTop, measurementBottom; // Measurement window bounds
        let measurementLeft, measurementRight; // Extended measurement window horizontal bounds
        
        function resize() {
            width = canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            height = canvas.height = canvas.offsetHeight * window.devicePixelRatio;
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;
            
            graphLeft = 90;
            graphRight = w - 50;
            graphTop = 70;
            graphBottom = h - 130 - measurementWindowHeight; // Increased space for x-axis label below axis
            graphWidth = graphRight - graphLeft;
            graphHeight = graphBottom - graphTop;
            
            // Measurement window bounds - moved down to accommodate x-axis label
            measurementTop = graphBottom + 55;
            measurementBottom = h - 35;
            
            // Extended measurement window horizontal bounds (20 pixels wider on each side)
            measurementLeft = graphLeft - 20;
            measurementRight = graphRight + 20;
        }
        
        // Gaussian PDF
        function gaussian(x, mu, sigma) {
            const coeff = 1 / (sigma * Math.sqrt(2 * Math.PI));
            const exponent = -0.5 * Math.pow((x - mu) / sigma, 2);
            return coeff * Math.exp(exponent);
        }
        
        // Box-Muller transform for generating Gaussian samples
        function generateGaussianSample() {
            let u1 = Math.random();
            let u2 = Math.random();
            while (u1 === 0) u1 = Math.random();
            
            const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mu + sigma * z;
        }
        
        // Convert x value to canvas x
        function xToCanvas(x) {
            return graphLeft + ((x - xMin) / xRange) * graphWidth;
        }
        
        // Convert y value to canvas y
        function yToCanvas(y, maxY) {
            return graphBottom - (y / maxY) * graphHeight;
        }
        
        // Get histogram bin for x value
        function getBin(x) {
            const bin = Math.floor(((x - xMin) / xRange) * histogram.length);
            return Math.max(0, Math.min(histogram.length - 1, bin));
        }
        
        // Reset histogram and measurements
        function resetHistogram() {
            histogram = new Array(80).fill(0);
            totalSamples = 0;
            sampleAccumulator = 0;
            totalElapsedTime = 0;
            currentMeasurement = null;
            measurementFlashes = [];
        }
        
        function drawGrid() {
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.1)';
            ctx.lineWidth = 1;
            
            // Vertical grid lines - every 2 units for wider range
            for (let x = xMin; x <= xMax; x += 2) {
                const canvasX = xToCanvas(x);
                ctx.beginPath();
                ctx.moveTo(canvasX, graphTop);
                ctx.lineTo(canvasX, graphBottom);
                ctx.stroke();
            }
            
            // Horizontal grid lines
            const maxY = 0.5;
            for (let y = 0; y <= maxY; y += 0.1) {
                const canvasY = yToCanvas(y, maxY);
                ctx.beginPath();
                ctx.moveTo(graphLeft, canvasY);
                ctx.lineTo(graphRight, canvasY);
                ctx.stroke();
            }
        }
        
        // Draw standard deviation regions
        function drawStdDevRegions() {
            const maxY = 0.5;
            
            // 3Ïƒ region (outermost) - red
            drawSigmaRegion(3, 'rgba(239, 68, 68, 0.15)');
            
            // 2Ïƒ region - yellow/amber
            drawSigmaRegion(2, 'rgba(251, 191, 36, 0.15)');
            
            // 1Ïƒ region (innermost) - green
            drawSigmaRegion(1, 'rgba(34, 197, 94, 0.2)');
        }
        
        function drawSigmaRegion(numSigma, fillColor) {
            const maxY = 0.5;
            const leftBound = mu - numSigma * sigma;
            const rightBound = mu + numSigma * sigma;
            
            // Clamp to visible range
            const xMinClamped = Math.max(xMin, leftBound);
            const xMaxClamped = Math.min(xMax, rightBound);
            
            if (xMinClamped >= xMaxClamped) return; // Region is outside visible area
            
            ctx.beginPath();
            ctx.moveTo(xToCanvas(xMinClamped), graphBottom);
            
            // Draw along the curve
            for (let x = xMinClamped; x <= xMaxClamped; x += 0.05) {
                const y = gaussian(x, mu, sigma);
                const canvasY = yToCanvas(y, maxY);
                ctx.lineTo(xToCanvas(x), canvasY);
            }
            
            // Close the path
            ctx.lineTo(xToCanvas(xMaxClamped), graphBottom);
            ctx.closePath();
            
            ctx.fillStyle = fillColor;
            ctx.fill();
            
            // Draw vertical boundary lines for the region
            ctx.strokeStyle = fillColor.replace('0.15', '0.5').replace('0.2', '0.6');
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            
            if (leftBound >= xMin) {
                ctx.beginPath();
                ctx.moveTo(xToCanvas(leftBound), graphTop);
                ctx.lineTo(xToCanvas(leftBound), graphBottom);
                ctx.stroke();
            }
            
            if (rightBound <= xMax) {
                ctx.beginPath();
                ctx.moveTo(xToCanvas(rightBound), graphTop);
                ctx.lineTo(xToCanvas(rightBound), graphBottom);
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
        }
        
        // Draw sigma labels at the top
        function drawSigmaLabels() {
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            
            // Draw labels for each sigma boundary
            const sigmaLabels = [
                { sigma: -3, label: '-3Ïƒ', color: 'rgba(239, 68, 68, 0.9)' },
                { sigma: -2, label: '-2Ïƒ', color: 'rgba(251, 191, 36, 0.9)' },
                { sigma: -1, label: '-1Ïƒ', color: 'rgba(34, 197, 94, 0.9)' },
                { sigma: 1, label: '+1Ïƒ', color: 'rgba(34, 197, 94, 0.9)' },
                { sigma: 2, label: '+2Ïƒ', color: 'rgba(251, 191, 36, 0.9)' },
                { sigma: 3, label: '+3Ïƒ', color: 'rgba(239, 68, 68, 0.9)' }
            ];
            
            for (const item of sigmaLabels) {
                const x = mu + item.sigma * sigma;
                if (x >= xMin && x <= xMax) {
                    const canvasX = xToCanvas(x);
                    ctx.fillStyle = item.color;
                    ctx.fillText(item.label, canvasX, graphTop - 12);
                }
            }
            
            // Draw Î¼ label at mean
            if (mu >= xMin && mu <= xMax) {
                ctx.fillStyle = 'rgba(96, 165, 250, 0.95)';
                ctx.font = 'bold 13px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillText('Î¼', xToCanvas(mu), graphTop - 12);
            }
        }
        
        function drawAxes() {
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
            ctx.lineWidth = 2;
            
            // X axis
            ctx.beginPath();
            ctx.moveTo(graphLeft, graphBottom);
            ctx.lineTo(graphRight, graphBottom);
            ctx.stroke();
            
            // Y axis
            ctx.beginPath();
            ctx.moveTo(graphLeft, graphTop);
            ctx.lineTo(graphLeft, graphBottom);
            ctx.stroke();
            
            // X-axis coordinate labels - positioned below the axis, every 2 units
            ctx.fillStyle = '#e2e8f0';
            ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            
            for (let x = xMin; x <= xMax; x += 2) {
                const canvasX = xToCanvas(x);
                ctx.fillText(x.toString(), canvasX, graphBottom + 22);
            }
            
            // X-axis title - positioned below the coordinate labels
            ctx.fillStyle = '#f1f5f9';
            ctx.font = 'bold 14px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('x', (graphLeft + graphRight) / 2, graphBottom + 45);
            
            // Y-axis labels - more prominent
            ctx.textAlign = 'right';
            ctx.font = 'bold 13px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#e2e8f0';
            const maxY = 0.5;
            for (let y = 0; y <= maxY; y += 0.1) {
                const canvasY = yToCanvas(y, maxY);
                ctx.fillText(y.toFixed(1), graphLeft - 12, canvasY + 5);
            }
            
            // Y-axis title - more prominent
            ctx.fillStyle = '#f1f5f9';
            ctx.font = 'bold 16px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.save();
            ctx.translate(28, (graphTop + graphBottom) / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.textAlign = 'center';
            ctx.fillText('Probability Density', 0, 0);
            ctx.restore();
        }
        
        function drawHistogram() {
            if (totalSamples === 0) return;
            
            const maxY = 0.5;
            const binWidth = graphWidth / histogram.length;
            const binXWidth = xRange / histogram.length;
            
            // Normalize histogram to match PDF scale
            const maxCount = Math.max(...histogram);
            if (maxCount === 0) return;
            
            // Changed to new green color #8BD282
            ctx.fillStyle = 'rgba(139, 210, 130, 0.3)';
            ctx.strokeStyle = 'rgba(139, 210, 130, 0.6)';
            ctx.lineWidth = 1;
            
            for (let i = 0; i < histogram.length; i++) {
                if (histogram[i] === 0) continue;
                
                // Convert count to density
                const density = (histogram[i] / totalSamples) / binXWidth;
                const barHeight = (density / maxY) * graphHeight;
                const x = graphLeft + i * binWidth;
                const y = graphBottom - barHeight;
                
                ctx.fillRect(x, y, binWidth - 1, barHeight);
                ctx.strokeRect(x, y, binWidth - 1, barHeight);
            }
        }
        
        function drawGaussianCurve() {
            const maxY = 0.5;
            
            // Draw curve line with glow
            ctx.shadowColor = '#3b82f6';
            ctx.shadowBlur = 10;
            ctx.strokeStyle = '#60a5fa';
            ctx.lineWidth = 3;
            
            ctx.beginPath();
            for (let px = graphLeft; px <= graphRight; px++) {
                const x = xMin + ((px - graphLeft) / graphWidth) * xRange;
                const y = gaussian(x, mu, sigma);
                const canvasY = yToCanvas(y, maxY);
                
                if (px === graphLeft) {
                    ctx.moveTo(px, canvasY);
                } else {
                    ctx.lineTo(px, canvasY);
                }
            }
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Draw mean line
            const meanX = xToCanvas(mu);
            ctx.strokeStyle = 'rgba(96, 165, 250, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            ctx.beginPath();
            ctx.moveTo(meanX, graphTop);
            ctx.lineTo(meanX, graphBottom);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        // Draw the measurement window below the x-axis
        function drawMeasurementWindow() {
            const windowHeight = measurementBottom - measurementTop;
            
            // Draw measurement window background with extended horizontal bounds
            ctx.fillStyle = 'rgba(30, 41, 59, 0.9)';
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.4)';
            ctx.lineWidth = 2;
            
            // Rounded rectangle for measurement window - using extended bounds
            const radius = 10;
            ctx.beginPath();
            ctx.moveTo(measurementLeft + radius, measurementTop);
            ctx.lineTo(measurementRight - radius, measurementTop);
            ctx.quadraticCurveTo(measurementRight, measurementTop, measurementRight, measurementTop + radius);
            ctx.lineTo(measurementRight, measurementBottom - radius);
            ctx.quadraticCurveTo(measurementRight, measurementBottom, measurementRight - radius, measurementBottom);
            ctx.lineTo(measurementLeft + radius, measurementBottom);
            ctx.quadraticCurveTo(measurementLeft, measurementBottom, measurementLeft, measurementBottom - radius);
            ctx.lineTo(measurementLeft, measurementTop + radius);
            ctx.quadraticCurveTo(measurementLeft, measurementTop, measurementLeft + radius, measurementTop);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            
            // Draw "MEASUREMENT WINDOW" label - positioned at top left, above the tick marks area
            ctx.fillStyle = '#22c55e';
            ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText('ðŸ“ MEASUREMENT WINDOW', measurementLeft + 10, measurementTop + 14);
            
            // Draw tick marks aligned with x-axis - positioned lower to avoid label overlap, every 2 units
            ctx.strokeStyle = 'rgba(34, 197, 94, 0.3)';
            ctx.lineWidth = 1;
            const tickStartY = measurementTop + 22;
            for (let x = xMin; x <= xMax; x += 2) {
                const canvasX = xToCanvas(x);
                ctx.beginPath();
                ctx.moveTo(canvasX, tickStartY);
                ctx.lineTo(canvasX, tickStartY + 8);
                ctx.stroke();
                
                // Add small coordinate labels in measurement window
                ctx.fillStyle = 'rgba(148, 163, 184, 0.6)';
                ctx.font = '9px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(x.toString(), canvasX, tickStartY + 18);
            }
            
            // Draw measurement flashes (fading circles) - GREEN
            const markerCenterY = (measurementTop + measurementBottom) / 2 + 12;
            for (const flash of measurementFlashes) {
                const canvasX = xToCanvas(flash.value);
                
                // Draw expanding ring - GREEN
                ctx.beginPath();
                ctx.arc(canvasX, markerCenterY, flash.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(34, 197, 94, ${flash.alpha * 0.5})`;
                ctx.lineWidth = 2;
                ctx.stroke();
                
                // Draw center glow - GREEN
                const gradient = ctx.createRadialGradient(canvasX, markerCenterY, 0, canvasX, markerCenterY, 15);
                gradient.addColorStop(0, `rgba(34, 197, 94, ${flash.alpha})`);
                gradient.addColorStop(1, 'rgba(34, 197, 94, 0)');
                ctx.fillStyle = gradient;
                ctx.beginPath();
                ctx.arc(canvasX, markerCenterY, 15, 0, Math.PI * 2);
                ctx.fill();
            }
            
            // Draw current measurement marker - GREEN
            if (currentMeasurement) {
                const canvasX = xToCanvas(currentMeasurement.value);
                
                // Draw vertical line from measurement to histogram - GREEN
                ctx.strokeStyle = `rgba(34, 197, 94, ${currentMeasurement.alpha * 0.3})`;
                ctx.lineWidth = 1;
                ctx.setLineDash([3, 3]);
                ctx.beginPath();
                ctx.moveTo(canvasX, measurementTop);
                ctx.lineTo(canvasX, graphBottom);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw marker diamond - GREEN
                ctx.fillStyle = `rgba(34, 197, 94, ${currentMeasurement.alpha})`;
                ctx.beginPath();
                const size = 8;
                ctx.moveTo(canvasX, markerCenterY - size);
                ctx.lineTo(canvasX + size, markerCenterY);
                ctx.lineTo(canvasX, markerCenterY + size);
                ctx.lineTo(canvasX - size, markerCenterY);
                ctx.closePath();
                ctx.fill();
                
                // Draw glow around marker - GREEN
                ctx.shadowColor = '#22c55e';
                ctx.shadowBlur = 15 * currentMeasurement.alpha;
                ctx.fill();
                ctx.shadowBlur = 0;
                
                // Draw value label - GREEN
                ctx.fillStyle = `rgba(34, 197, 94, ${currentMeasurement.alpha})`;
                ctx.font = 'bold 12px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(currentMeasurement.value.toFixed(2), canvasX, markerCenterY + 24);
            }
        }
        
        function updateMeasurements() {
            // Update current measurement fade
            if (currentMeasurement) {
                currentMeasurement.life--;
                currentMeasurement.alpha = Math.max(0, currentMeasurement.life / 30);
                if (currentMeasurement.life <= 0) {
                    currentMeasurement = null;
                }
            }
            
            // Update flash effects
            for (let i = measurementFlashes.length - 1; i >= 0; i--) {
                const flash = measurementFlashes[i];
                flash.life--;
                flash.alpha = flash.life / flash.maxLife;
                flash.radius += 2; // Expand the ring
                if (flash.life <= 0) {
                    measurementFlashes.splice(i, 1);
                }
            }
        }
        
        function addSamples(deltaTime) {
            if (isPaused) return;
            
            // Calculate how many samples to add based on sample rate and elapsed time
            sampleAccumulator += sampleRate * deltaTime;
            
            // Add whole number of samples
            const samplesToAdd = Math.floor(sampleAccumulator);
            sampleAccumulator -= samplesToAdd;
            
            for (let i = 0; i < samplesToAdd; i++) {
                const value = generateGaussianSample();
                if (value >= xMin && value <= xMax) {
                    // Add to histogram immediately
                    const bin = getBin(value);
                    histogram[bin]++;
                    totalSamples++;
                    
                    // Create measurement marker
                    currentMeasurement = {
                        value: value,
                        alpha: 1,
                        life: 30 // Frames to display
                    };
                    
                    // Add flash effect
                    measurementFlashes.push({
                        value: value,
                        alpha: 1,
                        radius: 5,
                        life: 20,
                        maxLife: 20
                    });
                }
            }
        }
        
        function updateStats() {
            document.getElementById('sampleCount').textContent = totalSamples.toLocaleString();
            document.getElementById('elapsedTime').textContent = totalElapsedTime.toFixed(1);
            document.getElementById('infoMu').textContent = mu.toFixed(2);
            document.getElementById('infoSigma').textContent = sigma.toFixed(2);
            document.getElementById('infoVariance').textContent = (sigma * sigma).toFixed(2);
            document.getElementById('infoPeak').textContent = gaussian(mu, mu, sigma).toFixed(3);
        }
        
        function draw() {
            const w = canvas.offsetWidth;
            const h = canvas.offsetHeight;
            
            // Clear canvas
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, w, h);
            
            drawGrid();
            drawStdDevRegions();
            drawHistogram();
            drawGaussianCurve();
            drawSigmaLabels();
            drawAxes();
            drawMeasurementWindow();
        }
        
        let previousTime = performance.now();
        
        function animate(currentTime) {
            // Calculate delta time in seconds
            let deltaTime = (currentTime - previousTime) / 1000;
            previousTime = currentTime;
            
            // On first frame, cap deltaTime to prevent large initial burst
            if (isFirstFrame) {
                deltaTime = Math.min(deltaTime, 0.016);
                isFirstFrame = false;
            }
            
            // Cap deltaTime to prevent huge bursts after tab switching or lag
            deltaTime = Math.min(deltaTime, 0.1);
            
            // Track total elapsed time (only when not paused)
            if (!isPaused) {
                totalElapsedTime += deltaTime;
            }
            
            // Add samples based on actual elapsed time
            addSamples(deltaTime);
            
            updateMeasurements();
            updateStats();
            draw();
            
            requestAnimationFrame(animate);
        }
        
        // Event listeners
        document.getElementById('muSlider').addEventListener('input', (e) => {
            mu = parseFloat(e.target.value);
            document.getElementById('muValue').textContent = mu.toFixed(2);
            resetHistogram();
        });
        
        document.getElementById('sigmaSlider').addEventListener('input', (e) => {
            sigma = parseFloat(e.target.value);
            document.getElementById('sigmaValue').textContent = sigma.toFixed(2);
            resetHistogram();
        });
        
        document.getElementById('rateSlider').addEventListener('input', (e) => {
            sampleRate = parseInt(e.target.value);
            document.getElementById('rateValue').textContent = sampleRate;
        });
        
        document.getElementById('resetBtn').addEventListener('click', () => {
            resetHistogram();
        });
        
        document.getElementById('pauseBtn').addEventListener('click', (e) => {
            isPaused = !isPaused;
            e.target.textContent = isPaused ? 'Resume' : 'Pause';
            e.target.classList.toggle('active', isPaused);
        });
        
        window.addEventListener('resize', resize);
        
        // Initialize
        resize();
        requestAnimationFrame(animate);
    </script>
</body>
</html>