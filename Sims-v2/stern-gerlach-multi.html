<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Stage Stern-Gerlach Experiment - 3D View</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }

        body { 
            background: #0a0e17; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            overflow: hidden;
            color: #e2e8f0;
        }

        .top-header {
            width: 100%;
            height: 60px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(12px);
            border-bottom: 1px solid rgba(148, 163, 184, 0.15);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding: 0 20px;
            overflow: visible;
            position: relative;
            z-index: 100;
        }

        .title-container {
            display: flex;
            align-items: center;
            gap: 10px;
            overflow: visible;
        }

        .top-header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #f1f5f9;
        }

        .top-header h1 span {
            margin-right: 10px;
        }

        .info-icon-container {
            position: relative;
            display: inline-flex;
            z-index: 1001;
        }

        .info-icon {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: rgba(99, 102, 241, 0.2);
            border: 1.5px solid #6366f1;
            color: #a5b4fc;
            font-size: 13px;
            font-weight: 600;
            font-style: italic;
            font-family: Georgia, serif;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .info-icon:hover {
            background: rgba(99, 102, 241, 0.4);
            color: #fff;
        }

        .info-tooltip {
            position: absolute;
            top: 35px;
            left: 50%;
            transform: translateX(-50%);
            width: 320px;
            background: rgba(15, 23, 42, 0.98);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 10px;
            padding: 14px 16px;
            opacity: 0;
            visibility: hidden;
            transition: all 0.2s ease;
            z-index: 1000;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
        }

        .info-icon-container:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
        }

        .info-tooltip::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid rgba(148, 163, 184, 0.2);
        }

        .info-tooltip::after {
            content: '';
            position: absolute;
            top: -5px;
            left: 50%;
            transform: translateX(-50%);
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 5px solid rgba(15, 23, 42, 0.98);
        }

        .info-tooltip-title {
            font-size: 13px;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .info-tooltip-text {
            color: #94a3b8;
            font-size: 11px;
            line-height: 1.6;
        }

        .info-tooltip-text p {
            margin-bottom: 8px;
        }

        .info-tooltip-text p:last-child {
            margin-bottom: 0;
        }

        .info-tooltip-text strong {
            color: #e2e8f0;
        }

        .top-header p {
            font-size: 12px;
            color: #94a3b8;
            margin-left: 15px;
        }

        .main-container {
            display: flex;
            width: 100vw;
            height: calc(100vh - 60px);
        }

        #canvas-container {
            flex: 1;
            position: relative;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .floating-legend {
            position: absolute;
            top: 15px;
            left: 15px;
            background: rgba(15, 23, 42, 0.75);
            backdrop-filter: blur(8px);
            border: 1px solid rgba(148, 163, 184, 0.15);
            border-radius: 10px;
            padding: 12px 14px;
            z-index: 100;
        }

        .floating-legend-title {
            font-size: 11px;
            font-weight: 600;
            color: #94a3b8;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .floating-legend-items {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .floating-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
            color: #e2e8f0;
        }

        .floating-legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .floating-legend-dot.initial { background: #a3e635; }
        .floating-legend-dot.z-up { background: #f472b6; }
        .floating-legend-dot.z-down { background: #60a5fa; }
        .floating-legend-dot.x-plus { background: #a78bfa; }
        .floating-legend-dot.x-minus { background: #34d399; }

        .right-panel {
            width: 360px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(12px);
            border-left: 1px solid rgba(148, 163, 184, 0.15);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 20px;
            gap: 15px;
        }

        .panel-section {
            background: rgba(30, 41, 59, 0.5);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 12px;
            padding: 16px;
        }

        .panel-section h3 {
            font-size: 14px;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .stat-group {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stat-group.three-cols {
            grid-template-columns: 1fr 1fr 1fr;
        }

        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 10px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            text-align: center;
            min-height: 60px;
        }

        .stat-label {
            color: #94a3b8;
            font-size: 10px;
            white-space: nowrap;
        }

        .stat-value {
            color: #f1f5f9;
            font-weight: 600;
            font-size: 16px;
            font-variant-numeric: tabular-nums;
            min-width: 40px;
            text-align: center;
        }

        .control {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 12px;
        }

        .control:last-child {
            margin-bottom: 0;
        }

        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control label {
            color: #94a3b8;
            font-size: 12px;
        }

        .control-value-display {
            color: #f1f5f9;
            font-weight: 600;
            font-size: 13px;
        }

        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .slider.field-strength::-webkit-slider-thumb {
            background: #f472b6;
        }

        .toggle-control {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-top: 1px solid rgba(148, 163, 184, 0.1);
            margin-top: 4px;
        }

        .toggle-label {
            color: #94a3b8;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toggle-label .icon {
            font-size: 14px;
        }

        .toggle-switch {
            position: relative;
            width: 48px;
            height: 26px;
            background: rgba(148, 163, 184, 0.3);
            border-radius: 13px;
            cursor: pointer;
            transition: background 0.3s;
        }

        .toggle-switch.active {
            background: #3b82f6;
        }

        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 20px;
            height: 20px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }

        .toggle-switch.active::after {
            transform: translateX(22px);
        }

        .toggle-status {
            font-size: 11px;
            color: #f1f5f9;
            font-weight: 600;
            min-width: 30px;
            text-align: right;
        }

        button {
            width: 100%;
            padding: 10px 14px;
            background: #3b82f6;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
            transition: all 0.2s;
            margin-bottom: 8px;
        }

        button:hover {
            background: #2563eb;
            transform: translateY(-1px);
        }

        button:last-child {
            margin-bottom: 0;
        }

        button.danger {
            background: #dc2626;
        }

        button.danger:hover {
            background: #b91c1c;
        }

        button.success {
            background: #059669;
        }

        button.success:hover {
            background: #047857;
        }

        button.warning {
            background: #d97706;
        }

        button.warning:hover {
            background: #b45309;
        }

        button:disabled {
            background: #475569;
            cursor: not-allowed;
            transform: none;
        }

        .stage-config {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid rgba(148, 163, 184, 0.1);
        }

        .stage-config:last-child {
            margin-bottom: 0;
        }

        .stage-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .stage-title {
            font-weight: 600;
            font-size: 13px;
            color: #f1f5f9;
        }

        .stage-title.z-axis {
            color: #f472b6;
        }

        .stage-title.x-axis {
            color: #a78bfa;
        }

        .remove-stage {
            background: transparent;
            border: none;
            color: #ef4444;
            cursor: pointer;
            font-size: 16px;
            padding: 4px 8px;
            margin: 0;
            width: auto;
        }

        .remove-stage:hover {
            color: #dc2626;
            background: rgba(239, 68, 68, 0.1);
            border-radius: 4px;
        }

        .stage-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .stage-control {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .stage-control label {
            font-size: 11px;
            color: #94a3b8;
        }

        select {
            padding: 8px 10px;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 6px;
            color: #f1f5f9;
            font-size: 12px;
            cursor: pointer;
        }

        select:focus {
            outline: none;
            border-color: #3b82f6;
        }

        .info-text {
            color: #94a3b8;
            font-size: 11px;
            line-height: 1.5;
        }

        .legend {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 6px;
            margin-top: 10px;
            padding-top: 10px;
            border-top: 1px solid rgba(148, 163, 184, 0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }

        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }

        .legend-dot.initial { background: #a3e635; }
        .legend-dot.z-up { background: #f472b6; }
        .legend-dot.z-down { background: #60a5fa; }
        .legend-dot.x-plus { background: #a78bfa; }
        .legend-dot.x-minus { background: #34d399; }

        .button-row {
            display: flex;
            gap: 8px;
        }

        .button-row button {
            flex: 1;
            margin-bottom: 0;
        }

        .about-text {
            color: #94a3b8;
            font-size: 11px;
            line-height: 1.6;
        }

        .about-text p {
            margin-bottom: 10px;
        }

        .about-text p:last-child {
            margin-bottom: 0;
        }

        .about-text strong {
            color: #e2e8f0;
        }

        .field-strength-control {
            margin-top: 12px;
            padding-top: 12px;
            border-top: 1px solid rgba(148, 163, 184, 0.1);
        }

        .component-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-bottom: 12px;
            padding: 10px;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            border: 1px dashed rgba(148, 163, 184, 0.3);
        }

        .draggable-component {
            padding: 8px 12px;
            border-radius: 6px;
            cursor: grab;
            font-size: 11px;
            font-weight: 600;
            user-select: none;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .draggable-component:hover {
            transform: scale(1.05);
        }

        .draggable-component:active {
            cursor: grabbing;
        }

        .draggable-component.magnet-z {
            background: linear-gradient(135deg, #f472b6, #ec4899);
            color: white;
        }

        .draggable-component.magnet-x {
            background: linear-gradient(135deg, #a78bfa, #8b5cf6);
            color: white;
        }

        .draggable-component.blocker-plus {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .draggable-component.blocker-minus {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }

        .drop-zone {
            min-height: 60px;
            border: 2px dashed rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-bottom: 10px;
            transition: all 0.2s;
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-items: center;
        }

        .drop-zone.drag-over {
            border-color: #3b82f6;
            background: rgba(59, 130, 246, 0.1);
        }

        .drop-zone.invalid {
            border-color: #ef4444;
            background: rgba(239, 68, 68, 0.1);
        }

        .drop-zone-label {
            width: 100%;
            text-align: center;
            color: #64748b;
            font-size: 11px;
            padding: 5px;
        }

        .dropped-item {
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
            position: relative;
        }

        .dropped-item.magnet-z {
            background: linear-gradient(135deg, #f472b6, #ec4899);
            color: white;
        }

        .dropped-item.magnet-x {
            background: linear-gradient(135deg, #a78bfa, #8b5cf6);
            color: white;
        }

        .dropped-item.blocker-plus {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .dropped-item.blocker-minus {
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            color: white;
        }

        .remove-item {
            background: rgba(0,0,0,0.3);
            border: none;
            color: white;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 0;
            margin: 0;
            line-height: 1;
        }

        .remove-item:hover {
            background: rgba(0,0,0,0.5);
        }

        .stage-1-fixed {
            background: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 10px;
            border: 1px solid rgba(148, 163, 184, 0.1);
        }

        .stage-1-fixed .stage-header {
            margin-bottom: 8px;
        }

        .stage-1-info {
            font-size: 11px;
            color: #94a3b8;
        }

        .physics-note {
            font-size: 10px;
            color: #64748b;
            margin-top: 8px;
            font-style: italic;
            text-align: center;
        }

        /* NARRATION PANEL */
        .narration-panel {
            background: rgba(30, 41, 59, 0.7);
            border: 1.5px solid rgba(99, 102, 241, 0.3);
            border-radius: 12px;
            overflow: visible;
            flex-shrink: 0;
            min-height: 100px;
            box-shadow: 0 2px 12px rgba(99, 102, 241, 0.08);
        }
        .narration-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: rgba(99, 102, 241, 0.1);
            border-bottom: 1px solid rgba(99, 102, 241, 0.15);
            border-radius: 12px 12px 0 0;
        }
        .narration-header-left {
            display: flex;
            align-items: center;
            gap: 7px;
        }
        .narr-icon { font-size: 12px; }
        .narration-header-left span {
            font-size: 10px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .narration-controls {
            display: flex;
            gap: 3px;
            align-items: center;
        }
        .narr-btn {
            width: 26px !important;
            height: 26px;
            min-width: 26px;
            border-radius: 50% !important;
            border: 1px solid rgba(148, 163, 184, 0.2) !important;
            background: rgba(15, 23, 42, 0.6) !important;
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            transition: all 0.2s;
            padding: 0 !important;
            margin: 0 !important;
        }
        .narr-btn:hover {
            border-color: rgba(99, 102, 241, 0.5) !important;
            color: #a5b4fc;
            background: rgba(99, 102, 241, 0.1) !important;
            transform: none;
        }
        .narr-btn.active {
            background: rgba(99, 102, 241, 0.2) !important;
            border-color: rgba(99, 102, 241, 0.4) !important;
            color: #a5b4fc;
        }
        .narration-progress {
            height: 2px;
            background: rgba(148, 163, 184, 0.08);
        }
        .narration-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #6366f1, #a5b4fc);
            width: 0%;
            transition: width 0.3s linear;
        }
        .narration-body {
            padding: 10px 14px;
            min-height: 52px;
            display: flex;
            align-items: center;
        }
        .narration-text {
            font-size: 11.5px;
            color: #cbd5e1;
            line-height: 1.55;
            margin: 0;
        }
        .narration-text .hl {
            color: #a5b4fc;
            font-weight: 600;
        }
        .narration-text .hl-pink {
            color: #f472b6;
            font-weight: 600;
        }
        .narration-text .hl-blue {
            color: #60a5fa;
            font-weight: 600;
        }
        .narration-text .hl-purple {
            color: #a78bfa;
            font-weight: 600;
        }
        .narration-text .hl-green {
            color: #a3e635;
            font-weight: 600;
        }
        .narration-text .hl-red {
            color: #ef4444;
            font-weight: 600;
        }
        .narr-step-dots {
            display: flex;
            justify-content: center;
            gap: 5px;
            padding: 5px 14px 9px;
        }
        .narr-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: rgba(148, 163, 184, 0.2);
            transition: all 0.3s;
            cursor: pointer;
        }
        .narr-dot.active {
            background: #a5b4fc;
            box-shadow: 0 0 5px rgba(165, 180, 252, 0.5);
        }
        .narr-dot.completed {
            background: rgba(148, 163, 184, 0.4);
        }
    </style>
<base target="_blank">
</head>
<body>
    <div class="top-header">
        <div class="title-container">
            <h1><span>‚öõÔ∏è</span> Multi-Stage Stern-Gerlach 3D</h1>
            <div class="info-icon-container">
                <div class="info-icon">i</div>
                <div class="info-tooltip">
                    <div class="info-tooltip-title">‚ÑπÔ∏è About the Simulation</div>
                    <div class="info-tooltip-text">
                        <p>
                            <strong>The Stern-Gerlach experiment</strong> (1922) demonstrated the quantization of angular momentum (spin) in atoms.
                        </p>
                        <p>
                            <strong>Sequential Measurement:</strong> When you measure Z then X then Z, the second Z measurement re-randomizes the spin because X and Z are incompatible observables (ŒîS_x ¬∑ ŒîS_z ‚â• ‚Ñè/2).
                        </p>
                        <p>
                            <strong>Drag & Drop:</strong> Build multi-stage experiments. Blockers select specific spin states for further analysis.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="main-container">
        <div id="canvas-container">
            <canvas id="mainCanvas"></canvas>
            <div class="floating-legend">
                <div class="floating-legend-title">Spin States</div>
                <div class="floating-legend-items">
                    <div class="floating-legend-item">
                        <div class="floating-legend-dot initial"></div>
                        <span>Initial (unpolarized)</span>
                    </div>
                    <div class="floating-legend-item">
                        <div class="floating-legend-dot z-up"></div>
                        <span>Z+ (spin up)</span>
                    </div>
                    <div class="floating-legend-item">
                        <div class="floating-legend-dot z-down"></div>
                        <span>Z‚àí (spin down)</span>
                    </div>
                    <div class="floating-legend-item">
                        <div class="floating-legend-dot x-plus"></div>
                        <span>X+ (spin right)</span>
                    </div>
                    <div class="floating-legend-item">
                        <div class="floating-legend-dot x-minus"></div>
                        <span>X‚àí (spin left)</span>
                    </div>
                </div>
            </div>
        </div>

        <div class="right-panel">
            <!-- NARRATION PANEL -->
            <div class="narration-panel" id="narration-panel">
                <div class="narration-header">
                    <div class="narration-header-left">
                        <div class="narr-icon">üîä</div>
                        <span>Simulation Context</span>
                    </div>
                    <div class="narration-controls">
                        <button class="narr-btn" id="narr-back" title="Previous step">‚è™</button>
                        <button class="narr-btn" id="narr-play" title="Play">‚ñ∂</button>
                        <button class="narr-btn" id="narr-pause" title="Pause">‚è∏</button>
                    </div>
                </div>
                <div class="narration-progress">
                    <div class="narration-progress-bar" id="narr-progress-bar"></div>
                </div>
                <div class="narration-body">
                    <p class="narration-text" id="narration-text"></p>
                </div>
                <div class="narr-step-dots" id="narr-dots"></div>
            </div>

            <div class="panel-section">
                <h3>üìä Detection Statistics</h3>
                <div class="stat-group three-cols">
                    <div class="stat">
                        <span class="stat-label">Total</span>
                        <span class="stat-value" id="totalAtoms">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Detected</span>
                        <span class="stat-value" id="detectedAtoms">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Blocked</span>
                        <span class="stat-value" style="color: #ef4444;" id="blockedAtoms">0</span>
                    </div>
                </div>
                <div class="stat-group" style="margin-top: 10px;">
                    <div class="stat">
                        <span class="stat-label">Total +</span>
                        <span class="stat-value" id="totalPlus">0</span>
                    </div>
                    <div class="stat">
                        <span class="stat-label">Total ‚àí</span>
                        <span class="stat-value" id="totalMinus">0</span>
                    </div>
                </div>
                <div class="physics-note">
                    *Sequential measurements show quantum state collapse
                </div>
            </div>

            <div class="panel-section">
                <h3>üîß Experiment Builder</h3>

                <p class="info-text" style="margin-bottom: 10px;">Drag components to Stage 2 or 3 drop zones:</p>

                <div class="component-palette">
                    <div class="draggable-component magnet-z" draggable="true" data-type="magnet" data-axis="z">
                        üß≤ Z-Magnet
                    </div>
                    <div class="draggable-component magnet-x" draggable="true" data-type="magnet" data-axis="x">
                        üß≤ X-Magnet
                    </div>
                    <div class="draggable-component blocker-plus" draggable="true" data-type="blocker" data-value="plus">
                        üö´ Block +
                    </div>
                    <div class="draggable-component blocker-minus" draggable="true" data-type="blocker" data-value="minus">
                        üö´ Block ‚àí
                    </div>
                </div>

                <div class="stage-1-fixed">
                    <div class="stage-header">
                        <span class="stage-title z-axis">Stage 1: Z-Axis (Fixed)</span>
                    </div>
                    <div class="stage-controls">
                        <div class="stage-control">
                            <label>Orientation</label>
                            <select id="stage1Axis">
                                <option value="z" selected>Z-Axis (‚Üë‚Üì)</option>
                                <option value="x">X-Axis (‚Üê‚Üí)</option>
                            </select>
                        </div>
                        <div class="stage-control">
                            <label>Blocker</label>
                            <select id="stage1Blocker">
                                <option value="none" selected>None</option>
                                <option value="plus">Block +</option>
                                <option value="minus">Block ‚àí</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="drop-zone" id="dropZone2" data-stage="2">
                    <span class="drop-zone-label">Stage 2: Drop magnet and/or blocker here</span>
                </div>

                <div class="drop-zone" id="dropZone3" data-stage="3">
                    <span class="drop-zone-label">Stage 3: Drop magnet and/or blocker here</span>
                </div>

                <div class="button-row" style="margin-top: 12px;">
                    <button id="reset" class="danger">Reset Stats</button>
                    <button id="clearStages" class="warning">Clear Stages 2-3</button>
                </div>
            </div>

            <div class="panel-section">
                <h3>‚öôÔ∏è Controls</h3>
                <div class="control">
                    <div class="control-header">
                        <label for="emissionRate">Emission Rate</label>
                        <span class="control-value-display"><span id="emissionValue">5</span> /s</span>
                    </div>
                    <input type="range" class="slider" id="emissionRate" min="1" max="15" value="5">
                </div>
                <div class="toggle-control">
                    <div class="toggle-label">
                        <span class="icon">üß≤</span>
                        <span>Magnetic Field</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <!-- Fixed: Changed id to avoid duplicate if reusing IDs -->
                        <div class="toggle-switch active" id="magToggle"></div>
                        <span class="toggle-status" id="magStatus">ON</span>
                    </div>
                </div>
                <div class="field-strength-control">
                    <div class="control">
                        <div class="control-header">
                            <label for="fieldStrength">üîã Field Strength</label>
                            <span class="control-value-display"><span id="fieldStrengthValue">0.50</span> T</span>
                        </div>
                        <input type="range" class="slider field-strength" id="fieldStrength" min="50" max="200" value="50">
                    </div>
                    <div style="display: flex; justify-content: space-between; margin-top: 4px;">
                        <span style="font-size: 10px; color: #64748b;">0.50 T</span>
                        <span style="font-size: 10px; color: #64748b;">2.00 T</span>
                    </div>
                </div>
                <button id="resetSimulation" class="warning" style="margin-top: 12px;">üîÑ Reset Simulation</button>
                <button id="clearScreen" style="background: #6366f1;">üßπ Clear Screen Spots</button>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');

        // High-DPI support
        let dpr = window.devicePixelRatio || 1;
        let width, height;
        let atoms = [];
        let lastEmitTime = 0;
        let lastFrameTime = 0;
        let animationTime = 0;

        // Detection spots on the screen
        let detectionSpots = [];
        const MAX_SPOTS = 500;

        // Statistics
        let stats = {
            total: 0,
            detected: 0,
            blocked: 0,
            totalPlus: 0,
            totalMinus: 0
        };

        // Controls - DEFAULT field strength is 0.5T
        let emissionRate = 5;
        let magneticFieldEnabled = true;
        let fieldStrength = 0.5;

        // Stage system - Stage 1 is fixed, Stages 2-3 are drag-drop
        let stages = [
            { axis: 'z', blocker: 'none' },
            { axis: null, blocker: 'none' },
            { axis: null, blocker: 'none' }
        ];

        const MAX_STAGES = 3;

        // Layout
        let sourceX, detectorX, centerY;
        let stagePositions = [];

        // === PHYSICAL CONSTANTS (Reference) ===
        // Documented here for educational context. The simulation uses a kinematic
        // deflection model scaled for visual clarity rather than SI-unit integration.
        // Physical basis: F = -g_s √ó m_s √ó Œº_B √ó (‚àÇB/‚àÇz), acceleration a = F/m
        //   HBAR = 1.055e-34 J¬∑s, Œº_B = 9.274e-24 J/T, m_Ag = 1.79e-25 kg, g_s ‚âà 2.002
        //   Typical deflection ~1mm over 10cm magnet at ~1000 T/m gradient

        // Deflection amounts in pixels ‚Äî visualization tuning parameters.
        // These scale with fieldStrength so deflection ‚àù field gradient (physically correct).
        // Primary > secondary + tertiary ensures beam groups don't overlap.
        // 120 > 40 + 15 = 55 ‚úì
        let baseDeflectionAmount = 120;
        let scaleFactor = 1.0;

        const COLORS = {
            initial: { hex: '#a3e635', rgba: 'rgba(163, 230, 53, ' },
            zPlus: { hex: '#f472b6', rgba: 'rgba(244, 114, 182, ' },
            zMinus: { hex: '#60a5fa', rgba: 'rgba(96, 165, 250, ' },
            xPlus: { hex: '#a78bfa', rgba: 'rgba(167, 139, 250, ' },
            xMinus: { hex: '#34d399', rgba: 'rgba(52, 211, 153, ' }
        };

        // Browser-safe roundRect polyfill
        function drawRoundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) ctx.fill();
            if (stroke) ctx.stroke();
        }

        function getSpinColor(axis, value) {
            if (axis === null) return COLORS.initial;
            if (axis === 'z') {
                return value > 0 ? COLORS.zPlus : COLORS.zMinus;
            } else {
                return value > 0 ? COLORS.xPlus : COLORS.xMinus;
            }
        }

        function getActiveStages() {
            return stages.filter((s, i) => i === 0 || s.axis !== null);
        }

        function resize() {
            const container = document.getElementById('canvas-container');
            dpr = window.devicePixelRatio || 1;

            // Display size (css pixels)
            width = container.clientWidth;
            height = container.clientHeight;

            // Actual size in memory (scaled for high DPI)
            canvas.width = width * dpr;
            canvas.height = height * dpr;

            // Normalize coordinate system to use css pixels
            ctx.scale(dpr, dpr);

            centerY = height * 0.5;
            calculateStagePositions();
        }

        function calculateStagePositions() {
            stagePositions = [];
            const activeStages = getActiveStages();
            const numStages = activeStages.length;

            if (numStages === 1) {
                scaleFactor = 1.0;
            } else if (numStages === 2) {
                scaleFactor = 0.9;
            } else {
                scaleFactor = 0.75;
            }

            const margin = 50;
            sourceX = width * 0.08;
            detectorX = width * 0.92;

            const availableWidth = detectorX - sourceX - 200;

            const stageWidth = Math.min(100, availableWidth / (numStages * 2.5)) * scaleFactor;

            // Dynamic stage gap that increases with field strength to prevent overlap
            const baseGap = 180;
            const fieldMultiplier = 1 + (fieldStrength - 0.5) * 1.5;
            const stageGap = baseGap * fieldMultiplier * scaleFactor;

            const startX = sourceX + 120 * scaleFactor + 60;

            const totalStagesWidth = numStages * stageWidth + (numStages - 1) * stageGap;
            const maxTotalWidth = availableWidth * 0.9;
            const adjustedTotalWidth = Math.min(totalStagesWidth, maxTotalWidth);
            const adjustedGap = numStages > 1 ? (adjustedTotalWidth - numStages * stageWidth) / (numStages - 1) : 0;

            const stagesStartX = startX + (availableWidth - adjustedTotalWidth) / 4;

            for (let i = 0; i < numStages; i++) {
                const effectiveGap = numStages > 1 ? Math.max(adjustedGap, stageGap * 0.7) : 0;
                const stageStartX = stagesStartX + i * (stageWidth + effectiveGap);
                stagePositions.push({
                    startX: stageStartX,
                    endX: stageStartX + stageWidth,
                    centerX: stageStartX + stageWidth / 2,
                    width: stageWidth
                });
            }
        }

        function addDetectionSpot(y, axis, value) {
            const color = getSpinColor(axis, value);
            const spot = {
                x: detectorX,
                y: y,
                color: color,
                alpha: 1.0,
                size: 3 + Math.random() * 2,
                createdAt: animationTime
            };

            detectionSpots.push(spot);

            if (detectionSpots.length > MAX_SPOTS) {
                detectionSpots.shift();
            }
        }

        function draw3DBox(x, y, w, h, depth, topColor, frontColor, sideColor, highlight = false) {
            const depthX = depth * 0.7;
            const depthY = depth * 0.5;

            ctx.fillStyle = topColor;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + w, y);
            ctx.lineTo(x + w + depthX, y - depthY);
            ctx.lineTo(x + depthX, y - depthY);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = frontColor;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + w, y);
            ctx.lineTo(x + w, y + h);
            ctx.lineTo(x, y + h);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = sideColor;
            ctx.beginPath();
            ctx.moveTo(x + w, y);
            ctx.lineTo(x + w + depthX, y - depthY);
            ctx.lineTo(x + w + depthX, y + h - depthY);
            ctx.lineTo(x + w, y + h);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + w, y);
            ctx.lineTo(x + w + depthX, y - depthY);
            ctx.moveTo(x + w, y);
            ctx.lineTo(x + w, y + h);
            ctx.stroke();

            if (highlight) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(x + 5, y + 5);
                ctx.lineTo(x + w - 5, y + 5);
                ctx.stroke();
            }
        }

        class Atom {
            constructor() {
                this.x = sourceX + 60 * scaleFactor;
                this.y = centerY + (Math.random() - 0.5) * 6 * scaleFactor;
                this.vx = (2.0 + Math.random() * 0.3) * (scaleFactor < 0.8 ? 1.2 : 1.0);
                this.vy = 0;

                this.spinAxis = null;
                this.spinValue = 0;

                this.currentStage = -1;
                this.stageStates = [];
                this.blocked = false;
                this.detected = false;
                this.trail = [];
                this.size = 4 * scaleFactor;
                this.targetY = centerY;
                this.deflecting = false;
                this.deflectionStartX = 0;
                this.stageDeflectionStartY = [];
                this.stageMeasured = [];
            }

            getColor() {
                return getSpinColor(this.spinAxis, this.spinValue);
            }

            measureSpin(stageAxis) {
                if (this.spinAxis === null) {
                    // First measurement
                    this.spinAxis = stageAxis;
                    this.spinValue = Math.random() < 0.5 ? 1 : -1;
                } else if (this.spinAxis === stageAxis) {
                    // Same axis - quantum measurement confirms eigenstate
                    // No change to spinValue
                } else {
                    // Different axis - state collapse to new basis
                    // Loss of previous information (Heisenberg uncertainty principle)
                    this.spinAxis = stageAxis;
                    this.spinValue = Math.random() < 0.5 ? 1 : -1;
                }
            }

            update(dt) {
                if (this.blocked || this.detected) return false;

                // Frame-rate independence: normalize to 60fps reference
                const dtScale = dt / (1/60);

                if (this.trail.length > 40) this.trail.shift();
                this.trail.push({ 
                    x: this.x, 
                    y: this.y, 
                    axis: this.spinAxis,
                    value: this.spinValue
                });

                // Stern-Gerlach deflection: proportional to field gradient
                // F = -g_s √ó m_s √ó Œº_B √ó (‚àÇB/‚àÇz), so deflection ‚àù fieldStrength
                const deflectionAmount = baseDeflectionAmount * fieldStrength * scaleFactor;
                const secondaryDeflection = 40 * fieldStrength * scaleFactor;
                const tertiaryDeflection = 15 * fieldStrength * scaleFactor;

                const activeStages = getActiveStages();

                if (magneticFieldEnabled) {
                    for (let i = 0; i < activeStages.length; i++) {
                        const pos = stagePositions[i];
                        const stage = activeStages[i];

                        if (!stage.axis) continue;

                        // Entering magnet region
                        if (this.x >= pos.centerX && this.currentStage < i && !this.stageMeasured[i]) {
                            this.currentStage = i;
                            this.measureSpin(stage.axis);
                            this.deflecting = true;
                            this.deflectionStartX = pos.centerX;
                            this.stageDeflectionStartY[i] = this.y;
                            this.stageMeasured[i] = true;
                        }

                        // Inside deflection region ‚Äî kinematic trajectory
                        // Uses quadratic easing which matches z ‚àù t¬≤ from constant acceleration
                        if (this.deflecting && this.currentStage === i) {
                            const deflectionEndX = pos.endX + 40 * scaleFactor;
                            if (this.x <= deflectionEndX) {
                                const progress = Math.min(1, (this.x - this.deflectionStartX) / (deflectionEndX - this.deflectionStartX));
                                const easedProgress = progress * progress;

                                let stageDeflection;
                                if (i === 0) {
                                    stageDeflection = deflectionAmount;
                                } else if (i === 1) {
                                    stageDeflection = secondaryDeflection;
                                } else {
                                    stageDeflection = tertiaryDeflection;
                                }

                                this.y = this.stageDeflectionStartY[i] - this.spinValue * stageDeflection * easedProgress;
                            }
                        }

                        // Post-magnet region (blocker position)
                        const blockerX = pos.endX + 80 * scaleFactor;
                        if (this.x > blockerX && this.currentStage === i && !this.stageStates[i]) {
                            this.stageStates[i] = { axis: this.spinAxis, value: this.spinValue };
                            this.deflecting = false;

                            // Apply blocker
                            if (stage.blocker === 'plus' && this.spinValue > 0) {
                                this.blocked = true;
                                stats.blocked++;
                                return false;
                            }
                            if (stage.blocker === 'minus' && this.spinValue < 0) {
                                this.blocked = true;
                                stats.blocked++;
                                return false;
                            }
                        }
                    }
                }

                this.x += this.vx * dtScale;

                if (this.x >= detectorX) {
                    this.detected = true;
                    stats.detected++;
                    if (this.spinValue > 0) {
                        stats.totalPlus++;
                    } else if (this.spinValue < 0) {
                        stats.totalMinus++;
                    }

                    addDetectionSpot(this.y, this.spinAxis, this.spinValue);
                    return false;
                }

                if (this.y < 0 || this.y > height) {
                    return false;
                }

                return true;
            }

            draw() {
                const color = this.getColor();

                if (this.trail.length > 1) {
                    for (let i = 1; i < this.trail.length; i++) {
                        const prev = this.trail[i - 1];
                        const curr = this.trail[i];
                        const alpha = (i / this.trail.length) * 0.4;

                        const trailColor = getSpinColor(curr.axis, curr.value);

                        ctx.beginPath();
                        ctx.moveTo(prev.x, prev.y);
                        ctx.lineTo(curr.x, curr.y);
                        ctx.strokeStyle = trailColor.rgba + alpha + ')';
                        ctx.lineWidth = 2.5 * scaleFactor;
                        ctx.stroke();
                    }
                }

                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fillStyle = color.hex;
                ctx.fill();

                const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.size * 3);
                gradient.addColorStop(0, color.rgba + '0.5)');
                gradient.addColorStop(1, 'transparent');
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * 3, 0, Math.PI * 2);
                ctx.fillStyle = gradient;
                ctx.fill();
            }
        }

        function drawBackground() {
            ctx.fillStyle = '#0a0e17';
            ctx.fillRect(0, 0, width, height);

            ctx.strokeStyle = 'rgba(148, 163, 184, 0.08)';
            ctx.lineWidth = 1;

            const gridSize = 50;
            const horizonY = height * 0.3;

            for (let i = 0; i < 15; i++) {
                const y = horizonY + i * gridSize * (1 + i * 0.1);
                if (y > height) break;
                const alpha = 0.03 + (i / 15) * 0.05;
                ctx.strokeStyle = `rgba(148, 163, 184, ${alpha})`;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }

            for (let x = 0; x < width; x += gridSize) {
                ctx.strokeStyle = 'rgba(148, 163, 184, 0.04)';
                ctx.beginPath();
                ctx.moveTo(x, horizonY);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
        }

        function drawSource() {
            const ovenCX = sourceX;
            const ovenCY = centerY;
            const ovenRadiusX = 30 * scaleFactor;
            const ovenRadiusY = 18 * scaleFactor;
            const ovenHeight = 120 * scaleFactor;

            const heatPulse = 0.5 + 0.4 * Math.sin(animationTime * 0.004);

            const depth3D = 35 * scaleFactor;

            ctx.fillStyle = '#1a1f2e';
            ctx.beginPath();
            ctx.ellipse(ovenCX + depth3D * 0.3, ovenCY - depth3D * 0.15, ovenRadiusX, ovenRadiusY, 0, 0, Math.PI * 2);
            ctx.fill();

            const bodyGradient = ctx.createLinearGradient(ovenCX - ovenRadiusX, 0, ovenCX + ovenRadiusX, 0);
            bodyGradient.addColorStop(0, '#2d3748');
            bodyGradient.addColorStop(0.2, '#4a5568');
            bodyGradient.addColorStop(0.4, '#718096');
            bodyGradient.addColorStop(0.6, '#4a5568');
            bodyGradient.addColorStop(1, '#2d3748');

            ctx.fillStyle = '#1f2937';
            ctx.beginPath();
            ctx.ellipse(ovenCX, ovenCY + ovenHeight / 2, ovenRadiusX, ovenRadiusY, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = bodyGradient;
            ctx.beginPath();
            ctx.moveTo(ovenCX - ovenRadiusX, ovenCY - ovenHeight / 2);
            ctx.lineTo(ovenCX - ovenRadiusX, ovenCY + ovenHeight / 2);
            ctx.ellipse(ovenCX, ovenCY + ovenHeight / 2, ovenRadiusX, ovenRadiusY, 0, Math.PI, 0, true);
            ctx.lineTo(ovenCX + ovenRadiusX, ovenCY - ovenHeight / 2);
            ctx.ellipse(ovenCX, ovenCY - ovenHeight / 2, ovenRadiusX, ovenRadiusY, 0, 0, Math.PI, true);
            ctx.closePath();
            ctx.fill();

            // Heat bands
            for (let i = 0; i < 5; i++) {
                const bandY = ovenCY - ovenHeight / 2 + 20 * scaleFactor + i * 22 * scaleFactor;
                const bandIntensity = heatPulse * (0.3 + 0.2 * Math.sin(animationTime * 0.005 + i));

                if (bandY > ovenCY - ovenHeight / 2 + 10 * scaleFactor && bandY < ovenCY + ovenHeight / 2 - 10 * scaleFactor) {
                    const bandGradient = ctx.createLinearGradient(ovenCX - ovenRadiusX, 0, ovenCX + ovenRadiusX, 0);
                    bandGradient.addColorStop(0, `rgba(251, 146, 60, 0)`);
                    bandGradient.addColorStop(0.3, `rgba(251, 146, 60, ${bandIntensity})`);
                    bandGradient.addColorStop(0.5, `rgba(239, 68, 68, ${bandIntensity * 1.2})`);
                    bandGradient.addColorStop(0.7, `rgba(251, 146, 60, ${bandIntensity})`);
                    bandGradient.addColorStop(1, `rgba(251, 146, 60, 0)`);

                    ctx.fillStyle = bandGradient;
                    ctx.fillRect(ovenCX - ovenRadiusX, bandY - 4 * scaleFactor, ovenRadiusX * 2, 8 * scaleFactor);
                }
            }

            const topGradient = ctx.createRadialGradient(ovenCX, ovenCY - ovenHeight / 2, 0, ovenCX, ovenCY - ovenHeight / 2, ovenRadiusX);
            topGradient.addColorStop(0, `rgba(251, 146, 60, ${heatPulse * 0.6})`);
            topGradient.addColorStop(0.5, '#4a5568');
            topGradient.addColorStop(1, '#2d3748');
            ctx.fillStyle = topGradient;
            ctx.beginPath();
            ctx.ellipse(ovenCX, ovenCY - ovenHeight / 2, ovenRadiusX, ovenRadiusY, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.ellipse(ovenCX, ovenCY - ovenHeight / 2, ovenRadiusX - 3, ovenRadiusY - 2, 0, Math.PI * 1.1, Math.PI * 1.9);
            ctx.stroke();

            // Nozzle
            const nozzleStartX = ovenCX + ovenRadiusX - 5 * scaleFactor;
            const nozzleLength = 45 * scaleFactor;
            const nozzleHeight = 20 * scaleFactor;
            const nozzleDepth = 18 * scaleFactor;

            ctx.fillStyle = '#4a5568';
            ctx.beginPath();
            ctx.moveTo(nozzleStartX, ovenCY - nozzleHeight / 2);
            ctx.lineTo(nozzleStartX + nozzleLength, ovenCY - 6 * scaleFactor);
            ctx.lineTo(nozzleStartX + nozzleLength, ovenCY + 6 * scaleFactor);
            ctx.lineTo(nozzleStartX, ovenCY + nozzleHeight / 2);
            ctx.closePath();
            ctx.fill();

            // Label
            ctx.fillStyle = '#94a3b8';
            ctx.font = `bold ${12 * scaleFactor}px -apple-system, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('Ag Source', ovenCX, ovenCY + ovenHeight / 2 + 25 * scaleFactor);
        }

        function draw3DMagnet(pos, stage, index) {
            const magnetWidth = pos.width;
            // Pole gap scales with field strength for clear beam separation
            const baseGapFromCenter = 140;
            const gapFromCenter = (baseGapFromCenter + (fieldStrength - 0.5) * 60) * scaleFactor;
            const poleHeight = 55 * scaleFactor;
            const depth3D = 40 * scaleFactor;

            const isZAxis = stage.axis === 'z';

            ctx.save();
            if (!magneticFieldEnabled) {
                ctx.globalAlpha = 0.4;
            } else if (index > 0) {
                ctx.globalAlpha = 0.85;
            }

            if (index > 0) {
                // Draw small magnets at deflected positions for subsequent stages
                const deflectionAmount = baseDeflectionAmount * fieldStrength * scaleFactor;
                
                // For stages 2 and 3, we draw N-S pairs that straddle each beam position
                // The magnets need to be sized and spaced to avoid overlap
                
                if (index === 1) {
                    // Stage 2: Two beams from Stage 1
                    // Upper beam at centerY - deflectionAmount
                    // Lower beam at centerY + deflectionAmount
                    const upperBeamY = centerY - deflectionAmount;
                    const lowerBeamY = centerY + deflectionAmount;
                    
                    // Draw a single N-S magnet pair that spans both beams
                    // N pole above the upper beam, S pole below the lower beam
                    drawMiniMagnetPair(pos, stage, upperBeamY, lowerBeamY, index);
                    
                } else if (index === 2) {
                    // Stage 3: Four beams from Stage 2
                    const secondaryDeflection = 40 * fieldStrength * scaleFactor;
                    
                    // Upper pair of beams (from upper Stage 1 beam)
                    const upperUpperY = centerY - deflectionAmount - secondaryDeflection;
                    const upperLowerY = centerY - deflectionAmount + secondaryDeflection;
                    
                    // Lower pair of beams (from lower Stage 1 beam)
                    const lowerUpperY = centerY + deflectionAmount - secondaryDeflection;
                    const lowerLowerY = centerY + deflectionAmount + secondaryDeflection;
                    
                    // Draw two separate N-S magnet pairs
                    drawMiniMagnetPair(pos, stage, upperUpperY, upperLowerY, index);
                    drawMiniMagnetPair(pos, stage, lowerUpperY, lowerLowerY, index);
                }

                // Draw stage label for stages 2 and 3
                ctx.globalAlpha = 1.0;
                const axisLabel = isZAxis ? 'SG-Z' : 'SG-X';
                const axisColor = isZAxis ? '#f472b6' : '#a78bfa';
                
                // Calculate label position (below the lowest magnet)
                // Note: deflectionAmount already defined above
                let lowestY;
                if (index === 1) {
                    lowestY = centerY + deflectionAmount;
                } else {
                    const secondaryDeflection = 40 * fieldStrength * scaleFactor;
                    lowestY = centerY + deflectionAmount + secondaryDeflection;
                }
                
                const miniScale = index === 1 ? 0.4 : 0.32;
                const miniPoleHeight = 45 * scaleFactor * miniScale;
                const miniGap = 15 * scaleFactor * miniScale;
                const labelY = lowestY + miniGap + miniPoleHeight + 25 * scaleFactor;
                
                // Stage label background
                const labelText = `Stage ${index + 1}: ${axisLabel}`;
                ctx.font = `bold ${11 * scaleFactor}px -apple-system, sans-serif`;
                const textWidth = ctx.measureText(labelText).width;
                
                // Draw label pill background
                const pillPadding = 6 * scaleFactor;
                const pillHeight = 18 * scaleFactor;
                const pillWidth = textWidth + pillPadding * 2;
                const pillX = pos.centerX - pillWidth / 2;
                const pillY = labelY - pillHeight / 2;
                
                ctx.fillStyle = 'rgba(15, 23, 42, 0.8)';
                drawRoundRect(ctx, pillX, pillY, pillWidth, pillHeight, 4 * scaleFactor, true, false);
                
                ctx.strokeStyle = axisColor;
                ctx.lineWidth = 1.5 * scaleFactor;
                drawRoundRect(ctx, pillX, pillY, pillWidth, pillHeight, 4 * scaleFactor, false, true);
                
                // Draw label text
                ctx.fillStyle = axisColor;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(labelText, pos.centerX, labelY);
                ctx.textBaseline = 'alphabetic';

                ctx.restore();
                return;
            }

            // North pole (top)
            const northTopY = centerY - gapFromCenter - poleHeight;
            const northBottomY = centerY - gapFromCenter;

            draw3DBox(
                pos.startX, northTopY,
                magnetWidth, poleHeight - 15 * scaleFactor, depth3D,
                '#b91c1c', '#dc2626', '#991b1b', true
            );

            // Knife edge
            const tipHeight = 25 * scaleFactor;
            ctx.fillStyle = '#dc2626';
            ctx.beginPath();
            ctx.moveTo(pos.startX, northBottomY - 15 * scaleFactor);
            ctx.lineTo(pos.endX, northBottomY - 15 * scaleFactor);
            ctx.lineTo(pos.centerX, northBottomY + tipHeight - 15 * scaleFactor);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#b91c1c';
            ctx.beginPath();
            ctx.moveTo(pos.endX, northBottomY - 15 * scaleFactor);
            ctx.lineTo(pos.endX + depth3D * 0.7, northBottomY - 15 * scaleFactor - depth3D * 0.5);
            ctx.lineTo(pos.centerX + depth3D * 0.35, northBottomY + tipHeight - 15 * scaleFactor - depth3D * 0.25);
            ctx.lineTo(pos.centerX, northBottomY + tipHeight - 15 * scaleFactor);
            ctx.closePath();
            ctx.fill();

            // South pole (bottom)
            const southTopY = centerY + gapFromCenter;
            const southBottomY = centerY + gapFromCenter + poleHeight;

            draw3DBox(
                pos.startX, southTopY,
                magnetWidth, poleHeight, depth3D,
                '#1d4ed8', '#2563eb', '#1e40af', true
            );

            // Field lines (visualize gradient)
            if (magneticFieldEnabled) {
                const lineAlpha = 0.15 + 0.1 * fieldStrength;
                ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(0.35, lineAlpha)})`;
                ctx.lineWidth = (1.5 + fieldStrength * 0.5) * scaleFactor;

                const numFieldLines = Math.floor(4 + fieldStrength * 2);
                for (let i = 0; i < numFieldLines; i++) {
                    const t = (i + 1) / (numFieldLines + 1);
                    const startX = pos.startX + magnetWidth * t;
                    const startY = northBottomY + tipHeight - 10 * scaleFactor;
                    const endY = southTopY + 5 * scaleFactor;
                    const curveOffset = (t - 0.5) * 35 * scaleFactor;

                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.bezierCurveTo(
                        startX + curveOffset, startY + (endY - startY) * 0.3,
                        startX + curveOffset * 0.5, startY + (endY - startY) * 0.7,
                        startX, endY
                    );
                    ctx.stroke();

                    // Arrow
                    const midY = (startY + endY) / 2;
                    const arrowX = startX + curveOffset * 0.7;
                    ctx.beginPath();
                    ctx.moveTo(arrowX - 3 * scaleFactor, midY - 4 * scaleFactor);
                    ctx.lineTo(arrowX, midY);
                    ctx.lineTo(arrowX + 3 * scaleFactor, midY - 4 * scaleFactor);
                    ctx.stroke();
                }
            }

            ctx.globalAlpha = 1.0;

            // Labels
            ctx.fillStyle = '#fff';
            ctx.font = `bold ${18 * scaleFactor}px -apple-system, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('N', pos.centerX, northTopY + poleHeight / 2 - 5 * scaleFactor);
            ctx.fillText('S', pos.centerX, southTopY + poleHeight / 2 + 8 * scaleFactor);

            ctx.fillStyle = '#94a3b8';
            ctx.font = `${10 * scaleFactor}px -apple-system, sans-serif`;
            const axisLabel = isZAxis ? 'SG-Z' : 'SG-X';
            const statusLabel = magneticFieldEnabled ? ` (${fieldStrength.toFixed(2)} T)` : ' (OFF)';
            ctx.fillText(`Stage ${index + 1}: ${axisLabel}${statusLabel}`, pos.centerX, southBottomY + 25 * scaleFactor);

            ctx.restore();
        }
        
        // Draw a miniature N-S magnet pair that spans from upperBeamY to lowerBeamY
        function drawMiniMagnetPair(pos, stage, upperBeamY, lowerBeamY, stageIndex) {
            const isZAxis = stage.axis === 'z';
            
            // Miniature version scale
            const miniScale = stageIndex === 1 ? 0.4 : 0.32;
            
            // Dimensions
            const magnetWidth = pos.width * miniScale;
            const poleHeight = 45 * scaleFactor * miniScale;
            const depth3D = 30 * scaleFactor * miniScale;
            const gapFromBeam = 15 * scaleFactor * miniScale; // Small gap between pole tip and beam
            
            // Color scheme: Z-axis uses same red/blue as Stage 1, X-axis uses purple/green
            const northColors = isZAxis 
                ? { top: '#b91c1c', front: '#dc2626', side: '#991b1b' }  // Red (same as Stage 1)
                : { top: '#7c3aed', front: '#8b5cf6', side: '#6d28d9' }; // Purple (X-axis)
            const southColors = isZAxis 
                ? { top: '#1d4ed8', front: '#2563eb', side: '#1e40af' }  // Blue (same as Stage 1)
                : { top: '#059669', front: '#10b981', side: '#047857' }; // Green (X-axis)
            
            const halfWidth = magnetWidth / 2;
            const tipHeight = 12 * scaleFactor * miniScale;
            
            // North pole - positioned above the upper beam
            const northBottomTipY = upperBeamY - gapFromBeam; // Tip of knife edge
            const northBodyBottomY = northBottomTipY - tipHeight;
            const northBodyTopY = northBodyBottomY - (poleHeight - tipHeight);
            
            // Draw north pole body
            draw3DBox(
                pos.centerX - halfWidth, northBodyTopY,
                magnetWidth, poleHeight - tipHeight, depth3D,
                northColors.top, northColors.front, northColors.side, false
            );
            
            // North pole knife edge (triangular tip pointing down)
            ctx.fillStyle = northColors.front;
            ctx.beginPath();
            ctx.moveTo(pos.centerX - halfWidth, northBodyBottomY);
            ctx.lineTo(pos.centerX + halfWidth, northBodyBottomY);
            ctx.lineTo(pos.centerX, northBottomTipY);
            ctx.closePath();
            ctx.fill();
            
            // Knife edge 3D side
            ctx.fillStyle = northColors.side;
            ctx.beginPath();
            ctx.moveTo(pos.centerX + halfWidth, northBodyBottomY);
            ctx.lineTo(pos.centerX + halfWidth + depth3D * 0.7, northBodyBottomY - depth3D * 0.5);
            ctx.lineTo(pos.centerX + depth3D * 0.35, northBottomTipY - depth3D * 0.25);
            ctx.lineTo(pos.centerX, northBottomTipY);
            ctx.closePath();
            ctx.fill();
            
            // South pole - positioned below the lower beam
            const southTopY = lowerBeamY + gapFromBeam;
            const southBottomY = southTopY + poleHeight;
            
            draw3DBox(
                pos.centerX - halfWidth, southTopY,
                magnetWidth, poleHeight, depth3D,
                southColors.top, southColors.front, southColors.side, false
            );
            
            // N/S labels
            ctx.fillStyle = '#fff';
            const fontSize = Math.max(9, 12 * miniScale * scaleFactor);
            ctx.font = `bold ${fontSize}px -apple-system, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('N', pos.centerX, northBodyTopY + (poleHeight - tipHeight) / 2 + 2);
            ctx.fillText('S', pos.centerX, southTopY + poleHeight / 2 + 3);
            
            // Draw subtle field lines between poles
            if (magneticFieldEnabled) {
                const lineAlpha = 0.15;
                ctx.strokeStyle = `rgba(255, 255, 255, ${lineAlpha})`;
                ctx.lineWidth = Math.max(1, 1.5 * scaleFactor * miniScale);
                
                const numLines = 3;
                for (let i = 0; i < numLines; i++) {
                    const t = (i + 1) / (numLines + 1);
                    const startX = pos.centerX - halfWidth + magnetWidth * t;
                    const startY = northBottomTipY;
                    const endY = southTopY;
                    const curveOffset = (t - 0.5) * 20 * scaleFactor * miniScale;
                    
                    ctx.beginPath();
                    ctx.moveTo(startX, startY);
                    ctx.bezierCurveTo(
                        startX + curveOffset, startY + (endY - startY) * 0.3,
                        startX + curveOffset * 0.5, startY + (endY - startY) * 0.7,
                        startX, endY
                    );
                    ctx.stroke();
                    
                    // Small arrow in the middle
                    const midY = (startY + endY) / 2;
                    const arrowX = startX + curveOffset * 0.7;
                    const arrowSize = 2 * scaleFactor * miniScale;
                    ctx.beginPath();
                    ctx.moveTo(arrowX - arrowSize, midY - arrowSize * 1.5);
                    ctx.lineTo(arrowX, midY);
                    ctx.lineTo(arrowX + arrowSize, midY - arrowSize * 1.5);
                    ctx.stroke();
                }
            }
        }

        function drawBlocker(pos, stage, index) {
            if (stage.blocker === 'none') return;

            const blockerX = pos.endX + 80 * scaleFactor;
            const blockerWidth = 16 * scaleFactor;
            const blockerHeight = 35 * scaleFactor;
            const depth3D = 12 * scaleFactor;

            const deflectionAmount = baseDeflectionAmount * fieldStrength * scaleFactor;
            const secondaryDeflection = 40 * fieldStrength * scaleFactor;
            const tertiaryDeflection = 15 * fieldStrength * scaleFactor;

            let blockerPositions = [];

            if (index === 0) {
                // Stage 1: One blocker at ¬±deflectionAmount
                const y = stage.blocker === 'plus' 
                    ? centerY - deflectionAmount - blockerHeight / 2
                    : centerY + deflectionAmount - blockerHeight / 2;
                blockerPositions.push(y);
            } else if (index === 1) {
                // Stage 2: Two blockers (one for each incoming beam)
                if (stage.blocker === 'plus') {
                    blockerPositions.push(centerY - deflectionAmount - secondaryDeflection);
                    blockerPositions.push(centerY + deflectionAmount - secondaryDeflection);
                } else {
                    blockerPositions.push(centerY - deflectionAmount + secondaryDeflection);
                    blockerPositions.push(centerY + deflectionAmount + secondaryDeflection);
                }
            } else if (index === 2) {
                // Stage 3: Four blockers (one for each incoming beam)
                const basePositions = [
                    centerY - deflectionAmount - secondaryDeflection,
                    centerY - deflectionAmount + secondaryDeflection,
                    centerY + deflectionAmount - secondaryDeflection,
                    centerY + deflectionAmount + secondaryDeflection
                ];
                basePositions.forEach(baseY => {
                    const y = stage.blocker === 'plus' 
                        ? baseY - tertiaryDeflection
                        : baseY + tertiaryDeflection;
                    blockerPositions.push(y - blockerHeight / 2);
                });
            }

            blockerPositions.forEach(y => {
                draw3DBlocker(blockerX, y, blockerWidth, blockerHeight, depth3D, stage.blocker);
            });
        }

        function draw3DBlocker(x, y, w, h, depth, type) {
            const pulseIntensity = 0.5 + 0.3 * Math.sin(animationTime * 0.005);

            draw3DBox(x, y, w, h, depth, '#7f1d1d', '#991b1b', '#6b1a1a');

            const warningGlow = ctx.createRadialGradient(x + w/2, y + h/2, 0, x + w/2, y + h/2, 30 * scaleFactor);
            warningGlow.addColorStop(0, `rgba(239, 68, 68, ${pulseIntensity * 0.3})`);
            warningGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = warningGlow;
            ctx.beginPath();
            ctx.arc(x + w/2, y + h/2, 30 * scaleFactor, 0, Math.PI * 2);
            ctx.fill();

            // X mark
            ctx.strokeStyle = '#fca5a5';
            ctx.lineWidth = 2 * scaleFactor;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x + 4 * scaleFactor, y + 8 * scaleFactor);
            ctx.lineTo(x + w - 4 * scaleFactor, y + h - 8 * scaleFactor);
            ctx.moveTo(x + w - 4 * scaleFactor, y + 8 * scaleFactor);
            ctx.lineTo(x + 4 * scaleFactor, y + h - 8 * scaleFactor);
            ctx.stroke();
            ctx.lineCap = 'butt';
        }

        function drawDetector() {
            const detectorWidth = 25 * scaleFactor;
            const screenHeight = height * 0.75;
            const depth3D = 40 * scaleFactor;

            const screenX = detectorX - detectorWidth / 2;
            const screenY = centerY - screenHeight / 2;

            // Side/back 3D
            ctx.fillStyle = '#0f172a';
            ctx.beginPath();
            ctx.moveTo(screenX + detectorWidth, screenY);
            ctx.lineTo(screenX + detectorWidth + depth3D * 0.7, screenY - depth3D * 0.5);
            ctx.lineTo(screenX + detectorWidth + depth3D * 0.7, screenY + screenHeight - depth3D * 0.5);
            ctx.lineTo(screenX + detectorWidth, screenY + screenHeight);
            ctx.closePath();
            ctx.fill();

            ctx.fillStyle = '#1e293b';
            ctx.beginPath();
            ctx.moveTo(screenX, screenY);
            ctx.lineTo(screenX + detectorWidth, screenY);
            ctx.lineTo(screenX + detectorWidth + depth3D * 0.7, screenY - depth3D * 0.5);
            ctx.lineTo(screenX + depth3D * 0.7, screenY - depth3D * 0.5);
            ctx.closePath();
            ctx.fill();

            // Screen face
            const screenGradient = ctx.createLinearGradient(screenX, 0, screenX + detectorWidth, 0);
            screenGradient.addColorStop(0, '#1e293b');
            screenGradient.addColorStop(0.3, '#334155');
            screenGradient.addColorStop(0.7, '#334155');
            screenGradient.addColorStop(1, '#1e293b');

            ctx.fillStyle = screenGradient;
            // Use drawRoundRect for cross-browser compatibility
            drawRoundRect(ctx, screenX, screenY, detectorWidth, screenHeight, 4 * scaleFactor, true, false);

            // Glow
            const surfaceGlow = ctx.createRadialGradient(
                detectorX, centerY, 0,
                detectorX, centerY, screenHeight / 2
            );
            surfaceGlow.addColorStop(0, 'rgba(100, 150, 200, 0.1)');
            surfaceGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = surfaceGlow;
            ctx.fillRect(screenX, screenY, detectorWidth, screenHeight);

            // Border
            ctx.strokeStyle = '#475569';
            ctx.lineWidth = 3 * scaleFactor;
            drawRoundRect(ctx, screenX, screenY, detectorWidth, screenHeight, 4 * scaleFactor, false, true);

            // Label
            ctx.fillStyle = '#94a3b8';
            ctx.font = `${10 * scaleFactor}px -apple-system, sans-serif`;
            ctx.textAlign = 'center';
            ctx.fillText('Detector', detectorX, screenY + screenHeight + 18 * scaleFactor);
        }

        function drawDetectionSpots() {
            for (let i = 0; i < detectionSpots.length; i++) {
                const spot = detectionSpots[i];

                const age = animationTime - spot.createdAt;
                const fadeStart = 8000; // Start fading after 8s
                const fadeDuration = 4000; // Fade over 4s
                let alpha = 1.0;

                if (age > fadeStart) {
                    alpha = Math.max(0.2, 1.0 - (age - fadeStart) / fadeDuration);
                }

                const glowRadius = spot.size * 2.5;
                const spotGlow = ctx.createRadialGradient(
                    spot.x, spot.y, 0,
                    spot.x, spot.y, glowRadius
                );
                spotGlow.addColorStop(0, spot.color.rgba + (alpha * 0.8) + ')');
                spotGlow.addColorStop(0.5, spot.color.rgba + (alpha * 0.4) + ')');
                spotGlow.addColorStop(1, 'transparent');

                ctx.fillStyle = spotGlow;
                ctx.beginPath();
                ctx.arc(spot.x, spot.y, glowRadius, 0, Math.PI * 2);
                ctx.fill();

                ctx.beginPath();
                ctx.arc(spot.x, spot.y, spot.size, 0, Math.PI * 2);
                ctx.fillStyle = spot.color.rgba + alpha + ')';
                ctx.fill();
            }
        }

        function drawBeamPath() {
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;

            const deflectionAmount = baseDeflectionAmount * fieldStrength * scaleFactor;
            const activeStages = getActiveStages();

            // Initial beam to Stage 1
            ctx.strokeStyle = 'rgba(163, 230, 53, 0.3)';
            ctx.beginPath();
            ctx.moveTo(sourceX + 60 * scaleFactor, centerY);
            if (stagePositions.length > 0) {
                ctx.lineTo(stagePositions[0].centerX, centerY);
            } else {
                ctx.lineTo(detectorX, centerY);
            }
            ctx.stroke();

            // Quantum trajectories (expected paths)
            if (magneticFieldEnabled && stagePositions.length >= 1 && activeStages[0].axis) {
                const pos1 = stagePositions[0];

                // Stage 1 splits
                ctx.strokeStyle = 'rgba(244, 114, 182, 0.25)'; // Up
                ctx.beginPath();
                ctx.moveTo(pos1.centerX, centerY);
                ctx.quadraticCurveTo(
                    pos1.endX + 30 * scaleFactor, centerY - deflectionAmount * 0.5,
                    pos1.endX + 60 * scaleFactor, centerY - deflectionAmount
                );
                if (activeStages.length === 1 || stagePositions.length < 2) {
                    ctx.lineTo(detectorX, centerY - deflectionAmount);
                } else {
                    ctx.lineTo(stagePositions[1].startX, centerY - deflectionAmount);
                }
                ctx.stroke();

                ctx.strokeStyle = 'rgba(96, 165, 250, 0.25)'; // Down
                ctx.beginPath();
                ctx.moveTo(pos1.centerX, centerY);
                ctx.quadraticCurveTo(
                    pos1.endX + 30 * scaleFactor, centerY + deflectionAmount * 0.5,
                    pos1.endX + 60 * scaleFactor, centerY + deflectionAmount
                );
                if (activeStages.length === 1 || stagePositions.length < 2) {
                    ctx.lineTo(detectorX, centerY + deflectionAmount);
                } else {
                    ctx.lineTo(stagePositions[1].startX, centerY + deflectionAmount);
                }
                ctx.stroke();
            }

            ctx.setLineDash([]);
        }

        function emitAtom() {
            atoms.push(new Atom());
            stats.total++;
        }

        function updateStats() {
            document.getElementById('totalAtoms').textContent = stats.total;
            document.getElementById('detectedAtoms').textContent = stats.detected;
            document.getElementById('blockedAtoms').textContent = stats.blocked;
            document.getElementById('totalPlus').textContent = stats.totalPlus;
            document.getElementById('totalMinus').textContent = stats.totalMinus;
        }

        function animate(currentTime) {
            // Calculate delta time for frame-rate independence
            if (lastFrameTime === 0) {
                lastFrameTime = currentTime;
                requestAnimationFrame(animate);
                return;
            }
            const dt = (currentTime - lastFrameTime) / 1000;
            lastFrameTime = currentTime;
            const clampedDt = Math.min(dt, 0.033); // Cap at ~30 FPS equivalent

            animationTime = currentTime;

            const emitInterval = 1000 / emissionRate;
            if (currentTime - lastEmitTime > emitInterval) {
                emitAtom();
                lastEmitTime = currentTime;
            }

            drawBackground();
            drawBeamPath();
            drawSource();

            const activeStages = getActiveStages();
            for (let i = 0; i < activeStages.length; i++) {
                const pos = stagePositions[i];
                const stage = activeStages[i];

                if (stage.axis) {
                    draw3DMagnet(pos, stage, i);
                    drawBlocker(pos, stage, i);
                }
            }

            drawDetector();
            drawDetectionSpots();

            atoms = atoms.filter(atom => {
                const alive = atom.update(clampedDt);
                if (!atom.blocked) {
                    atom.draw();
                }
                return alive;
            });

            updateStats();

            requestAnimationFrame(animate);
        }

        function reset() {
            atoms = [];
            detectionSpots = [];
            lastFrameTime = 0;
            stats = {
                total: 0,
                detected: 0,
                blocked: 0,
                totalPlus: 0,
                totalMinus: 0
            };
        }

        function clearScreenSpots() {
            detectionSpots = [];
        }

        function resetSimulation() {
            stages = [
                { axis: 'z', blocker: 'none' },
                { axis: null, blocker: 'none' },
                { axis: null, blocker: 'none' }
            ];
            calculateStagePositions();
            updateDropZones();
            updateStage1Controls();
            reset();
        }

        function clearStages23() {
            stages[1] = { axis: null, blocker: 'none' };
            stages[2] = { axis: null, blocker: 'none' };
            calculateStagePositions();
            updateDropZones();
            reset();
        }

        function toggleMagneticField() {
            magneticFieldEnabled = !magneticFieldEnabled;
            const toggle = document.getElementById('magToggle');
            const status = document.getElementById('magStatus');

            if (magneticFieldEnabled) {
                toggle.classList.add('active');
                status.textContent = 'ON';
                status.style.color = '#f1f5f9';
            } else {
                toggle.classList.remove('active');
                status.textContent = 'OFF';
                status.style.color = '#94a3b8';
            }
        }

        // Drag and Drop functionality
        function initDragAndDrop() {
            const draggables = document.querySelectorAll('.draggable-component');
            const dropZones = document.querySelectorAll('.drop-zone');

            draggables.forEach(draggable => {
                draggable.addEventListener('dragstart', handleDragStart);
                draggable.addEventListener('dragend', handleDragEnd);
            });

            dropZones.forEach(zone => {
                zone.addEventListener('dragover', handleDragOver);
                zone.addEventListener('dragleave', handleDragLeave);
                zone.addEventListener('drop', handleDrop);
            });
        }

        let draggedData = null;

        function handleDragStart(e) {
            draggedData = {
                type: e.target.dataset.type,
                axis: e.target.dataset.axis || null,
                value: e.target.dataset.value || null
            };
            e.target.style.opacity = '0.5';
        }

        function handleDragEnd(e) {
            e.target.style.opacity = '1';
            draggedData = null;
        }

        function handleDragOver(e) {
            e.preventDefault();
            const zone = e.currentTarget;
            const stageIndex = parseInt(zone.dataset.stage) - 1;

            if (canDropInZone(stageIndex, draggedData)) {
                zone.classList.add('drag-over');
                zone.classList.remove('invalid');
            } else {
                zone.classList.add('invalid');
                zone.classList.remove('drag-over');
            }
        }

        function handleDragLeave(e) {
            e.currentTarget.classList.remove('drag-over');
            e.currentTarget.classList.remove('invalid');
        }

        function canDropInZone(stageIndex, data) {
            if (!data) return false;

            const stage = stages[stageIndex];

            // Prevent duplicate types in same stage
            if (data.type === 'magnet' && stage.axis !== null) return false;
            if (data.type === 'blocker' && stage.blocker !== 'none') return false;

            // Stage 3 requires Stage 2 to exist
            if (stageIndex === 2 && stages[1].axis === null) return false;

            return true;
        }

        function handleDrop(e) {
            e.preventDefault();
            const zone = e.currentTarget;
            zone.classList.remove('drag-over');
            zone.classList.remove('invalid');

            const stageIndex = parseInt(zone.dataset.stage) - 1;

            if (!canDropInZone(stageIndex, draggedData)) return;

            if (draggedData.type === 'magnet') {
                stages[stageIndex].axis = draggedData.axis;
            } else if (draggedData.type === 'blocker') {
                stages[stageIndex].blocker = draggedData.value;
            }

            calculateStagePositions();
            updateDropZones();
            reset();
        }

        function updateDropZones() {
            for (let i = 1; i <= 2; i++) {
                const zone = document.getElementById(`dropZone${i + 1}`);
                const stage = stages[i];

                zone.innerHTML = '';
                let hasContent = false;

                if (stage.axis !== null) {
                    const magnetItem = document.createElement('div');
                    magnetItem.className = `dropped-item magnet-${stage.axis}`;
                    magnetItem.innerHTML = `
                        üß≤ ${stage.axis.toUpperCase()}-Magnet
                        <button class="remove-item" data-stage="${i}" data-type="magnet">√ó</button>
                    `;
                    zone.appendChild(magnetItem);
                    hasContent = true;
                }

                if (stage.blocker !== 'none') {
                    const blockerItem = document.createElement('div');
                    blockerItem.className = `dropped-item blocker-${stage.blocker}`;
                    blockerItem.innerHTML = `
                        üö´ Block ${stage.blocker === 'plus' ? '+' : '‚àí'}
                        <button class="remove-item" data-stage="${i}" data-type="blocker">√ó</button>
                    `;
                    zone.appendChild(blockerItem);
                    hasContent = true;
                }

                if (!hasContent) {
                    const label = document.createElement('span');
                    label.className = 'drop-zone-label';
                    if (i === 2 && stages[1].axis === null) {
                        label.textContent = `Stage ${i + 1}: Add magnet to Stage 2 first`;
                        label.style.color = '#64748b';
                    } else {
                        label.textContent = `Stage ${i + 1}: Drop magnet and/or blocker here`;
                    }
                    zone.appendChild(label);
                }
            }

            document.querySelectorAll('.remove-item').forEach(btn => {
                btn.addEventListener('click', handleRemoveItem);
            });
        }

        function handleRemoveItem(e) {
            e.stopPropagation();
            const stageIndex = parseInt(e.target.dataset.stage);
            const type = e.target.dataset.type;

            if (type === 'magnet') {
                stages[stageIndex].axis = null;
                stages[stageIndex].blocker = 'none';

                if (stageIndex === 1) {
                    stages[2].axis = null;
                    stages[2].blocker = 'none';
                }
            } else if (type === 'blocker') {
                stages[stageIndex].blocker = 'none';
            }

            calculateStagePositions();
            updateDropZones();
            reset();
        }

        function updateStage1Controls() {
            document.getElementById('stage1Axis').value = stages[0].axis;
            document.getElementById('stage1Blocker').value = stages[0].blocker;
        }

        // Event listeners
        document.getElementById('emissionRate').addEventListener('input', (e) => {
            emissionRate = parseInt(e.target.value);
            document.getElementById('emissionValue').textContent = emissionRate;
        });

        document.getElementById('magToggle').addEventListener('click', toggleMagneticField);

        document.getElementById('fieldStrength').addEventListener('input', (e) => {
            fieldStrength = parseInt(e.target.value) / 100;
            document.getElementById('fieldStrengthValue').textContent = fieldStrength.toFixed(2);
            calculateStagePositions();
            detectionSpots = [];
            atoms = [];
        });

        document.getElementById('stage1Axis').addEventListener('change', (e) => {
            stages[0].axis = e.target.value;
            calculateStagePositions();
            reset();
        });

        document.getElementById('stage1Blocker').addEventListener('change', (e) => {
            stages[0].blocker = e.target.value;
            reset();
        });

        document.getElementById('reset').addEventListener('click', reset);
        document.getElementById('clearStages').addEventListener('click', clearStages23);
        document.getElementById('resetSimulation').addEventListener('click', resetSimulation);
        document.getElementById('clearScreen').addEventListener('click', clearScreenSpots);

        window.addEventListener('resize', resize);

        // Initialize
        resize();
        initDragAndDrop();
        updateDropZones();
        updateStage1Controls();
        requestAnimationFrame(animate);

        // --- NARRATION / VOICEOVER ENGINE ---
        const narrationSteps = [
            {
                text: `Welcome to the <span class="hl">Multi-Stage Stern-Gerlach</span> simulator. This extends the classic experiment by chaining up to <span class="hl">three stages</span> of magnets and blockers ‚Äî letting you explore what happens when you measure spin along different axes in sequence.`,
                speech: `Welcome to the Multi-Stage Stern-Gerlach simulator. This extends the classic experiment by chaining up to three stages of magnets and blockers ‚Äî letting you explore what happens when you measure spin along different axes in sequence.`,
                duration: 14000
            },
            {
                text: `<span class="hl-green">Green atoms</span> emerge from the source in an unpolarized state. <span class="hl">Stage 1</span> starts as a <span class="hl-pink">Z-magnet</span>, splitting the beam into <span class="hl-pink">Z+</span> (spin up) and <span class="hl-blue">Z‚àí</span> (spin down). You can also switch Stage 1 to X-axis using the orientation dropdown.`,
                speech: `Green atoms emerge from the source in an unpolarized state. Stage 1 starts as a Z-magnet, splitting the beam into Z plus (spin up) and Z minus (spin down). You can also switch Stage 1 to X-axis using the orientation dropdown.`,
                duration: 14000
            },
            {
                text: `To build multi-stage experiments, use the <span class="hl">Experiment Builder</span>. The colored palette has four components: <span class="hl-pink">Z-Magnet</span>, <span class="hl-purple">X-Magnet</span>, <span class="hl-red">Block +</span>, and <span class="hl-blue">Block ‚àí</span>. Drag any component and drop it onto a <span class="hl">Stage 2</span> or <span class="hl">Stage 3</span> drop zone.`,
                speech: `To build multi-stage experiments, use the Experiment Builder. The colored palette has four components: Z-Magnet, X-Magnet, Block plus, and Block minus. Drag any component and drop it onto a Stage 2 or Stage 3 drop zone.`,
                duration: 14000
            },
            {
                text: `Each drop zone accepts one magnet and one blocker. Placed components appear as colored chips ‚Äî click the <span class="hl-red">√ó</span> to remove them. The <span class="hl">"Clear Stages 2-3"</span> button removes everything at once. Stage 1's blocker is set via its own dropdown.`,
                speech: `Each drop zone accepts one magnet and one blocker. Placed components appear as colored chips ‚Äî click the x to remove them. The "Clear Stages 2-3" button removes everything at once. Stage 1's blocker is set via its own dropdown.`,
                duration: 13000
            },
            {
                text: `<span class="hl">Try this first:</span> Set Stage 1's blocker to <span class="hl-red">"Block ‚àí"</span> so only <span class="hl-pink">Z+</span> atoms pass. Then drag a <span class="hl-pink">Z-Magnet</span> to Stage 2. All atoms deflect the same way ‚Äî <em>no splitting</em>. Repeating the same measurement doesn't change the state.`,
                speech: `Try this first: Set Stage 1's blocker to "Block minus" so only Z plus atoms pass. Then drag a Z-Magnet to Stage 2. All atoms deflect the same way ‚Äî no splitting. Repeating the same measurement doesn't change the state.`,
                duration: 15000
            },
            {
                text: `<span class="hl">Now the surprise:</span> Remove the Stage 2 Z-Magnet and drag an <span class="hl-purple">X-Magnet</span> there instead. The Z+ atoms split 50/50 into <span class="hl-purple">X+</span> and <span class="hl-purple">X‚àí</span>. Measuring X <em>completely randomizes</em> what you knew about Z ‚Äî because S<sub>x</sub> and S<sub>z</sub> are <span class="hl">incompatible observables</span>.`,
                speech: `Now the surprise: Remove the Stage 2 Z-Magnet and drag an X-Magnet there instead. The Z plus atoms split 50-50 into X plus and X minus. Measuring X completely randomizes what you knew about Z ‚Äî because S x and S z are incompatible observables.`,
                duration: 15000
            },
            {
                text: `<span class="hl">The punchline:</span> Keep the X-Magnet in Stage 2, then drag a <span class="hl-pink">Z-Magnet</span> to Stage 3. Even though we started with pure Z+ atoms, the final Z-measurement splits them again 50/50! The X-measurement <em>destroyed</em> the Z-information. This is the <span class="hl">uncertainty principle</span>: Œî S<sub>x</sub> ¬∑ Œî S<sub>z</sub> ‚â• ‚Ñè/2.`,
                speech: `The punchline: Keep the X-Magnet in Stage 2, then drag a Z-Magnet to Stage 3. Even though we started with pure Z plus atoms, the final Z-measurement splits them again 50-50! The X-measurement destroyed the Z-information. This is the uncertainty principle: delta S x times delta S z is greater than or equal to h-bar over 2.`,
                duration: 18000
            },
            {
                text: `<span class="hl">Experiment ideas:</span> Add <span class="hl-red">Block +</span> or <span class="hl-blue">Block ‚àí</span> after any magnet to select a single spin state. Try Z ‚Üí X ‚Üí Z with various blockers. Watch the statistics panel to verify 50/50 splits. Toggle the <span class="hl">magnetic field off</span> to see atoms fly straight with no splitting.`,
                speech: `Experiment ideas: Add Block plus or Block minus after any magnet to select a single spin state. Try Z, X, Z with various blockers. Watch the statistics panel to verify 50-50 splits. Toggle the magnetic field off to see atoms fly straight with no splitting.`,
                duration: 15000
            }
        ];

        let narration = {
            currentStep: 0,
            isPlaying: false,
            timer: null,
            utterance: null,
            speechSupported: 'speechSynthesis' in window
        };

        function initNarration() {
            const dotsContainer = document.getElementById('narr-dots');
            narrationSteps.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'narr-dot' + (i === 0 ? ' active' : '');
                dot.onclick = () => jumpToNarrStep(i);
                dotsContainer.appendChild(dot);
            });

            document.getElementById('narr-play').onclick = playNarration;
            document.getElementById('narr-pause').onclick = pauseNarration;
            document.getElementById('narr-back').onclick = goBackOneStep;

            showNarrStep(0);
        }

        function showNarrStep(index) {
            narration.currentStep = index;
            document.getElementById('narration-text').innerHTML = narrationSteps[index].text;

            const dots = document.querySelectorAll('.narr-dot');
            dots.forEach((dot, i) => {
                dot.className = 'narr-dot';
                if (i < index) dot.classList.add('completed');
                if (i === index) dot.classList.add('active');
            });

            const progress = (index / (narrationSteps.length - 1)) * 100;
            document.getElementById('narr-progress-bar').style.width = progress + '%';
        }

        function finishNarration() {
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');
            if (narration.speechSupported) window.speechSynthesis.cancel();
            if (narration.timer) { clearTimeout(narration.timer); narration.timer = null; }

            narration.timer = setTimeout(() => {
                narration.currentStep = 0;
                showNarrStep(0);
                document.getElementById('narr-progress-bar').style.width = '0%';
                narration.timer = null;
            }, 1200);
        }

        function speakNarrStep(index) {
            if (!narration.speechSupported) return;
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(narrationSteps[index].speech);
            utterance.rate = 0.92;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Select Samantha voice (priority), fallback to any English voice
            const voices = window.speechSynthesis.getVoices();
            const samantha = voices.find(v => v.name.includes('Samantha'));
            const fallback = voices.find(v => v.lang.startsWith('en') && (v.name.includes('Google') || v.name.includes('Natural') || v.name.includes('Daniel'))) || voices.find(v => v.lang.startsWith('en'));
            utterance.voice = samantha || fallback || null;

            utterance.onend = () => {
                if (!narration.isPlaying) return;
                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) {
                    finishNarration();
                } else {
                    narration.timer = setTimeout(() => {
                        if (narration.isPlaying) { showNarrStep(nextIndex); speakNarrStep(nextIndex); }
                    }, 800);
                }
            };

            narration.utterance = utterance;
            window.speechSynthesis.speak(utterance);
        }

        function playNarration() {
            if (narration.isPlaying) return;
            narration.isPlaying = true;
            document.getElementById('narr-play').classList.add('active');
            document.getElementById('narr-pause').classList.remove('active');
            if (narration.timer) { clearTimeout(narration.timer); narration.timer = null; }

            if (narration.speechSupported) {
                if (window.speechSynthesis.getVoices().length === 0) {
                    window.speechSynthesis.onvoiceschanged = () => speakNarrStep(narration.currentStep);
                } else {
                    speakNarrStep(narration.currentStep);
                }
            } else {
                advanceNarrByTimer();
            }
        }

        function advanceNarrByTimer() {
            if (!narration.isPlaying) return;
            narration.timer = setTimeout(() => {
                if (!narration.isPlaying) return;
                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) { finishNarration(); }
                else { showNarrStep(nextIndex); advanceNarrByTimer(); }
            }, narrationSteps[narration.currentStep].duration);
        }

        function pauseNarration() {
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');
            document.getElementById('narr-pause').classList.add('active');
            if (narration.speechSupported) window.speechSynthesis.cancel();
            if (narration.timer) { clearTimeout(narration.timer); narration.timer = null; }
        }

        function goBackOneStep() {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');
            const prevStep = Math.max(0, narration.currentStep - 1);
            narration.currentStep = prevStep;
            showNarrStep(prevStep);
            if (wasPlaying) playNarration();
        }

        function jumpToNarrStep(index) {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');
            narration.currentStep = index;
            showNarrStep(index);
            if (wasPlaying) playNarration();
        }

        initNarration();
    </script>
</body>
</html>