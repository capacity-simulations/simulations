<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Double-Slit Experiment</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        :root {
            --bg-color: #111827;
            --panel-bg: #1f2937;
            --accent-blue: #3b82f6;
            --text-main: #f3f4f6;
            --text-muted: #9ca3af;
            --border-color: #374151;
            --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        body { margin: 0; overflow: hidden; background-color: var(--bg-color); font-family: var(--font-family); }

        /* --- TOP TITLE BAR --- */

        .top-bar {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: linear-gradient(135deg, var(--panel-bg) 0%, #111827 100%);
            border-bottom: 2px solid var(--accent-blue);
            display: flex;
            align-items: center;
            justify-content: flex-start;
            padding-left: 30px;
            padding-right: 20px;
            box-sizing: border-box;
            z-index: 200;
            box-shadow: 0 4px 15px rgba(0,0,0,0.4);
        }
        .top-bar h1 {
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--text-main);
            margin: 0;
            letter-spacing: 0.05em;
            white-space: nowrap;
        }
        .top-bar-accent {
            width: 8px;
            height: 8px;
            background: var(--accent-blue);
            border-radius: 50%;
            margin-right: 15px;
            box-shadow: 0 0 10px var(--accent-blue);
            flex-shrink: 0;
        }

        .top-bar-actions {
            margin-left: auto;
            display: flex;
            gap: 10px;
            align-items: center;
            flex-shrink: 0;
        }
        .btn-topbar {
            padding: 8px 16px;
            border: none;
            border-radius: 6px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
        }
        .btn-topbar-toggle {
            background-color: #374151;
            color: white;
        }
        .btn-topbar-toggle:hover { background-color: #4b5563; }
        .btn-topbar-toggle.active {
            background-color: #f59e0b;
            box-shadow: 0 0 10px rgba(245, 158, 11, 0.4);
        }
        .btn-topbar-toggle.active:hover { background-color: #d97706; }
        .btn-topbar-reset {
            background-color: var(--accent-blue);
            color: white;
        }
        .btn-topbar-reset:hover { background-color: #2563eb; }

        /* Info Icon and Tooltip */
        .info-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            margin-left: 12px;
        }
        .info-icon {
            width: 22px;
            height: 22px;
            border-radius: 50%;
            background: var(--accent-blue);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            font-weight: 700;
            font-style: italic;
            font-family: Georgia, serif;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
        }
        .info-icon:hover {
            background: #2563eb;
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.8);
        }
        .info-tooltip {
            position: absolute;
            top: 40px;
            left: 0;
            width: 350px;
            background: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 300;
        }
        .info-container:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .info-tooltip::before {
            content: '';
            position: absolute;
            top: -8px;
            left: 8px;
            width: 0;
            height: 0;
            border-left: 8px solid transparent;
            border-right: 8px solid transparent;
            border-bottom: 8px solid var(--border-color);
        }
        .info-tooltip::after {
            content: '';
            position: absolute;
            top: -6px;
            left: 9px;
            width: 0;
            height: 0;
            border-left: 7px solid transparent;
            border-right: 7px solid transparent;
            border-bottom: 7px solid var(--panel-bg);
        }
        .info-tooltip-title {
            font-size: 0.85rem;
            font-weight: 700;
            color: var(--accent-blue);
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .info-tooltip p {
            font-size: 0.8rem;
            color: var(--text-muted);
            line-height: 1.6;
            margin: 0;
        }
        .info-tooltip .highlight {
            color: var(--accent-blue);
            font-weight: 600;
        }

        #canvas-container { position: fixed; top: 60px; left: 0; width: 100%; height: calc(100% - 60px); z-index: 1; }

        /* --- SIDEBAR --- */
        .sidebar {
            position: fixed; 
            top: 60px; 
            right: 20px; 
            width: 320px;
            background-color: var(--panel-bg);
            border-radius: 0 0 8px 8px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            color: var(--text-main);
            z-index: 100;
            display: flex; flex-direction: column;
            border: 1px solid var(--border-color);
            border-top: 2px solid var(--accent-blue);
            max-height: calc(100vh - 80px);
            overflow-y: auto;
        }

        .header {
            padding: 15px 20px;
            border-bottom: 1px solid var(--border-color);
        }
        .header p { font-size: 0.85rem; color: var(--text-muted); margin: 0; }
        .header-bar { height: 4px; width: 40%; background: var(--accent-blue); margin-top: 10px; border-radius: 2px; }

        .content { padding: 20px; display: flex; flex-direction: column; gap: 20px; }

        .section-title {
            font-size: 0.75rem; font-weight: 700; color: var(--text-muted);
            text-transform: uppercase; letter-spacing: 0.05em; margin-bottom: 10px;
        }

        /* CONTROLS */
        .control-group { margin-bottom: 15px; }
        .control-label { display: flex; justify-content: space-between; font-size: 0.9rem; margin-bottom: 8px; }
        .control-value { color: var(--accent-blue); font-weight: 600; }
        .control-range { font-size: 0.75rem; color: var(--text-muted); margin-top: 4px; display: flex; justify-content: space-between; }

        /* SLIDERS */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 6px; background: #374151; border-radius: 3px; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 18px; width: 18px; border-radius: 50%;
            background: var(--accent-blue); border: 2px solid white; margin-top: -6px;
        }

        /* COMBINED CHART */
        #combined-chart-container {
            background: #111827; border-radius: 6px; padding: 15px 10px 5px 10px;
            height: 200px; border: 1px solid var(--border-color);
        }
        
        /* LEGEND */
        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 10px;
            padding: 8px;
            background: rgba(17, 24, 39, 0.5);
            border-radius: 4px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: var(--text-muted);
        }
        .legend-color {
            width: 16px;
            height: 4px;
            border-radius: 2px;
        }
        .legend-color.detected {
            background: #3b82f6;
        }
        .legend-color.theoretical {
            background: #10b981;
        }
        .legend-color.classical {
            background: #f59e0b;
        }

        .chart-description {
            font-size: 0.75rem;
            color: var(--text-muted);
            margin-top: 8px;
            line-height: 1.4;
            text-align: center;
        }
        .chart-description .highlight {
            color: var(--accent-blue);
            font-weight: 600;
        }

        /* CONTROLS HINT */
        .controls-hint {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: rgba(31, 41, 55, 0.9);
            padding: 12px 16px;
            border-radius: 8px;
            color: var(--text-muted);
            font-size: 0.8rem;
            z-index: 100;
            border: 1px solid var(--border-color);
        }
        .controls-hint strong {
            color: var(--accent-blue);
        }

        /* NARRATION PANEL */
        .narration-panel {
            position: fixed;
            top: 70px;
            left: 20px;
            width: 340px;
            background: rgba(31, 41, 55, 0.95);
            border: 1px solid var(--border-color);
            border-radius: 10px;
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0,0,0,0.4);
            overflow: hidden;
        }
        .narration-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 14px;
            background: rgba(59, 130, 246, 0.08);
            border-bottom: 1px solid var(--border-color);
        }
        .narration-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .narration-header-left .icon {
            width: 20px;
            height: 20px;
            background: var(--accent-blue);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            color: white;
            flex-shrink: 0;
        }
        .narration-header-left span {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .narration-controls {
            display: flex;
            gap: 4px;
            align-items: center;
        }
        .narration-btn {
            width: 28px;
            height: 28px;
            border-radius: 50%;
            border: 1px solid var(--border-color);
            background: var(--panel-bg);
            color: var(--text-muted);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.2s;
            padding: 0;
        }
        .narration-btn:hover {
            border-color: var(--accent-blue);
            color: var(--accent-blue);
            background: rgba(59, 130, 246, 0.1);
        }
        .narration-btn.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            color: white;
        }
        .narration-body {
            padding: 12px 14px;
            max-height: 120px;
            overflow: hidden;
        }
        .narration-text {
            font-size: 0.8rem;
            color: var(--text-main);
            line-height: 1.55;
            margin: 0;
        }
        .narration-text .highlight {
            color: var(--accent-blue);
            font-weight: 600;
        }
        .narration-text .highlight-green {
            color: #10b981;
            font-weight: 600;
        }
        .narration-text .highlight-orange {
            color: #f59e0b;
            font-weight: 600;
        }
        .narration-progress {
            height: 3px;
            background: #374151;
            position: relative;
        }
        .narration-progress-bar {
            height: 100%;
            background: var(--accent-blue);
            width: 0%;
            transition: width 0.3s linear;
            border-radius: 0 2px 2px 0;
        }
        .narration-step-dots {
            display: flex;
            justify-content: center;
            gap: 6px;
            padding: 8px 14px 10px;
        }
        .step-dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background: #374151;
            transition: all 0.3s;
            cursor: pointer;
        }
        .step-dot.active {
            background: var(--accent-blue);
            box-shadow: 0 0 6px rgba(59, 130, 246, 0.5);
        }
        .step-dot.completed {
            background: #6b7280;
        }
    </style>
</head>
<body>

    <!-- TOP TITLE BAR -->
    <div class="top-bar">
        <div class="top-bar-accent"></div>
        <h1>Double Slit Experiment</h1>
        <div class="info-container">
            <div class="info-icon">i</div>
            <div class="info-tooltip">
                <div class="info-tooltip-title">About the Simulation</div>
                <p>
                    The <span class="highlight">double-slit experiment</span> demonstrates wave-particle duality. When particles pass through two slits, they create an <span class="highlight">interference pattern</span> on the detection screen.
                    <br><br>
                    <span class="highlight">Quantum (green):</span> |œà‚ÇÅ + œà‚ÇÇ|¬≤ ‚Äî amplitudes add, then square. The interference fringes arise from constructive/destructive interference.
                    <br><br>
                    <span class="highlight">Classical (orange):</span> P‚ÇÅ + P‚ÇÇ ‚Äî probabilities add directly. Each slit produces a single-slit diffraction pattern; with no interference between slits, we get a smooth envelope.
                    <br><br>
                    Both patterns use the <span class="highlight">same single-slit diffraction</span> physics ‚Äî the difference is whether amplitudes or probabilities combine (Feynman Lectures Vol III, Ch 1).
                </p>
            </div>
        </div>
        <div class="top-bar-actions">
            <button class="btn-topbar btn-topbar-toggle" id="classical-btn">Show Classical Pattern</button>
            <button class="btn-topbar btn-topbar-reset" id="reset-btn">Reset Simulation</button>
        </div>
    </div>

    <div id="canvas-container">
        <canvas id="main-canvas"></canvas>
    </div>

    <div class="controls-hint">
        <strong>üñ±Ô∏è Drag</strong> to rotate | <strong>Scroll</strong> to zoom | <strong>Right-click drag</strong> to pan
    </div>

    <!-- NARRATION PANEL -->
    <div class="narration-panel" id="narration-panel">
        <div class="narration-header">
            <div class="narration-header-left">
                <div class="icon">üîä</div>
                <span>Simulation Context</span>
            </div>
            <div class="narration-controls">
                <button class="narration-btn" id="narr-reset" title="Previous step">‚è™</button>
                <button class="narration-btn" id="narr-play" title="Play">‚ñ∂</button>
                <button class="narration-btn" id="narr-pause" title="Pause">‚è∏</button>
            </div>
        </div>
        <div class="narration-progress">
            <div class="narration-progress-bar" id="narr-progress-bar"></div>
        </div>
        <div class="narration-body">
            <p class="narration-text" id="narration-text"></p>
        </div>
        <div class="narration-step-dots" id="narr-dots"></div>
    </div>

    <div class="sidebar">
        <div class="header">
            <p>Simulator Controls</p>
            <div class="header-bar"></div>
        </div>

        <div class="content">
            <!-- Distribution plot ABOVE controls -->
            <div>
                <div class="section-title">Detection Pattern vs Theoretical Intensity</div>
                <div id="combined-chart-container">
                    <canvas id="combined-chart-canvas"></canvas>
                </div>
                <div class="chart-legend">
                    <div class="legend-item">
                        <div class="legend-color detected"></div>
                        <span>Detected Pattern</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color theoretical"></div>
                        <span>Quantum |œà‚ÇÅ+œà‚ÇÇ|¬≤</span>
                    </div>
                    <div class="legend-item" id="classical-legend" style="display: none;">
                        <div class="legend-color classical"></div>
                        <span>Classical P‚ÇÅ+P‚ÇÇ</span>
                    </div>
                </div>
                <p class="chart-description">
                    <span class="highlight">Quantum:</span> I ‚àù |œà‚ÇÅ + œà‚ÇÇ|¬≤ = cos¬≤(œÄd sinŒ∏/Œª) √ó sinc¬≤(œÄa sinŒ∏/Œª)<br>
                    <span class="highlight">Classical:</span> I ‚àù P‚ÇÅ + P‚ÇÇ (no interference between slits)
                </p>
            </div>

            <div>
                <div class="section-title">Parameters</div>
                <div class="control-group">
                    <div class="control-label"><span>Slit Separation (d)</span><span class="control-value" id="slit-sep-value">800 nm</span></div>
                    <input type="range" id="slit-sep" min="400" max="1600" step="10" value="800">
                    <div class="control-range"><span>400 nm</span><span>1600 nm</span></div>
                </div>
                <div class="control-group">
                    <div class="control-label"><span>Slit Width (a)</span><span class="control-value" id="slit-width-value">200 nm</span></div>
                    <input type="range" id="slit-width" min="100" max="500" step="10" value="200">
                    <div class="control-range"><span>100 nm</span><span>500 nm</span></div>
                </div>
                <div class="control-group" id="wavelength-group">
                    <div class="control-label"><span>Wavelength (Œª)</span><span class="control-value" id="wavelength-value" style="color: #77dd44;">550 nm</span></div>
                    <input type="range" id="wavelength" min="380" max="700" step="5" value="550">
                    <div class="control-range"><span><span style="color:#8b00ff;">‚ñ†</span> 380 nm</span><span>700 nm <span style="color:#ff0000;">‚ñ†</span></span></div>
                </div>
                <div class="control-group">
                    <div class="control-label"><span>Screen Distance (L)</span><span class="control-value" id="screen-dist-value">6000 nm</span></div>
                    <input type="range" id="screen-dist" min="4000" max="8000" step="100" value="6000">
                    <div class="control-range"><span>4000 nm</span><span>8000 nm</span></div>
                </div>
                <div class="control-group">
                    <div class="control-label"><span>Animation Speed</span><span class="control-value" id="rate-value">15</span></div>
                    <input type="range" id="rate" min="5" max="30" step="1" value="15">
                    <div class="control-range"><span>5</span><span>30</span></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- CONFIG ---
        const CONFIG = {
            screenRes: { w: 512, h: 256 },
            sceneWidth: 40,
            screenHeight: 20,
            numIncidentWaves: 8,
            waveSegments: 150,
            sourceZ: 18,
            barrierZ: 0,
            screenDistance: 30  // L: distance from slits to screen
        };

        // --- STATE ---
        // All physical lengths in nm (nanometers) ‚Äî same unit throughout.
        // Visible wavelengths (380‚Äì700 nm) are comparable to slit dimensions
        // (100‚Äì1600 nm), which is the condition for observable interference.
        //
        // Slider nm values map linearly to internal sim units:
        //   sim_value = slider_nm * NM_TO_SIM
        
        const NM_TO_SIM = {
            sep: 4.0 / 800,          // 800 nm default ‚Üí 4.0 sim units
            width: 0.8 / 200,        // 200 nm default ‚Üí 0.8 sim units  
            lambda: 1.5 / 550,       // 550 nm default ‚Üí 1.5 sim units
            screenDist: 30 / 6000    // 6000 nm default ‚Üí 30 sim units
        };

        let state = {
            sep: 800 * NM_TO_SIM.sep,
            slitWidth: 200 * NM_TO_SIM.width,
            lambda: 550 * NM_TO_SIM.lambda,
            animationSpeed: 15,
            hits: new Uint32Array(80),
            classicalHits: new Uint32Array(80),
            detectedCount: 0,
            showClassical: false
        };

        // --- GLOBALS ---
        let scene, camera, renderer, screenTexture, screenContext, screenMesh;
        let classicalOverlayTexture, classicalOverlayContext, classicalOverlayMesh;
        let barrierGroup;
        let combinedChart;
        let incidentWaves = [];
        let secondaryWavesS1 = [];
        let secondaryWavesS2 = [];
        let sourceMarker;
        let slitLabels = [];
        let controls;

        // --- WAVELENGTH ‚Üí COLOR ---
        // Returns {r, g, b} each 0‚Äì1 for the current wavelength slider value (nm)
        function getCurrentWavelengthNM() {
            return parseFloat(document.getElementById('wavelength')?.value || 550);
        }

        function nmToRGB(nm) {
            let r, g, b;
            if (nm >= 380 && nm < 440) { r = -(nm-440)/(440-380); g = 0; b = 1; }
            else if (nm >= 440 && nm < 490) { r = 0; g = (nm-440)/(490-440); b = 1; }
            else if (nm >= 490 && nm < 510) { r = 0; g = 1; b = -(nm-510)/(510-490); }
            else if (nm >= 510 && nm < 580) { r = (nm-510)/(580-510); g = 1; b = 0; }
            else if (nm >= 580 && nm < 645) { r = 1; g = -(nm-645)/(645-580); b = 0; }
            else if (nm >= 645 && nm <= 700) { r = 1; g = 0; b = 0; }
            else { r = 0.4; g = 0.6; b = 1; }
            // Boost brightness so waves are visible against dark background
            const boost = 0.15;
            r = Math.min(1, r + boost);
            g = Math.min(1, g + boost);
            b = Math.min(1, b + boost);
            return { r, g, b };
        }

        function nmToThreeColor(nm) {
            const c = nmToRGB(nm);
            return new THREE.Color(c.r, c.g, c.b);
        }

        function nmToCSSRGBA(nm, alpha) {
            const c = nmToRGB(nm);
            return `rgba(${Math.round(c.r*255)},${Math.round(c.g*255)},${Math.round(c.b*255)},${alpha})`;
        }

        // Lighter/pastel variant for secondary waves from each slit
        function nmToSecondaryColor(nm, shift) {
            const c = nmToRGB(nm);
            // shift towards pink for S1, towards purple for S2
            if (shift === 1) {
                return new THREE.Color(
                    Math.min(1, c.r * 0.7 + 0.3),
                    c.g * 0.5,
                    Math.min(1, c.b * 0.7 + 0.3)
                );
            } else {
                return new THREE.Color(
                    Math.min(1, c.r * 0.5 + 0.2),
                    c.g * 0.4,
                    Math.min(1, c.b * 0.7 + 0.4)
                );
            }
        }

        // Update all existing wave + source colors when wavelength changes
        function updateAllWaveColors() {
            const nm = getCurrentWavelengthNM();
            const col = nmToThreeColor(nm);
            const s1Col = nmToSecondaryColor(nm, 1);
            const s2Col = nmToSecondaryColor(nm, 2);

            // Incident waves
            incidentWaves.forEach(w => { w.mesh.material.color.copy(col); });
            // Secondary waves
            secondaryWavesS1.forEach(w => { w.mesh.material.color.copy(s1Col); });
            secondaryWavesS2.forEach(w => { w.mesh.material.color.copy(s2Col); });
            // Source marker bar + glow
            if (sourceMarker) {
                sourceMarker.children.forEach(child => {
                    if (child.isMesh && child.material) {
                        child.material.color.copy(col);
                    }
                });
            }
        }

        // --- INIT ---
        function init() {
            initThree();
            initCombinedChart();
            initUI();
            initNarration();
            animate();
        }

        function initThree() {
            const canvas = document.getElementById('main-canvas');
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x111827, 60, 150);

            camera = new THREE.PerspectiveCamera(50, window.innerWidth / (window.innerHeight - 60), 0.1, 500);
            camera.position.set(50, 30, 25); 
            camera.lookAt(0, 0, -5);

            renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight - 60);
            renderer.setPixelRatio(window.devicePixelRatio);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = true;
            controls.minDistance = 20;
            controls.maxDistance = 200;
            controls.target.set(0, 0, -5);
            controls.update();

            scene.add(new THREE.AmbientLight(0x404060, 2));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(20, 50, 20);
            scene.add(dirLight);

            const sCanvas = document.createElement('canvas');
            sCanvas.width = CONFIG.screenRes.w;
            sCanvas.height = CONFIG.screenRes.h;
            screenContext = sCanvas.getContext('2d');
            screenContext.fillStyle = '#1e293b';
            screenContext.fillRect(0,0, CONFIG.screenRes.w, CONFIG.screenRes.h);
            
            screenTexture = new THREE.CanvasTexture(sCanvas);
            
            const screenGeo = new THREE.BoxGeometry(CONFIG.sceneWidth, CONFIG.screenHeight, 0.5);
            const screenMat = new THREE.MeshStandardMaterial({ 
                map: screenTexture, 
                roughness: 0.1,
                side: THREE.DoubleSide
            });
            screenMesh = new THREE.Mesh(screenGeo, screenMat);
            screenMesh.position.z = -CONFIG.screenDistance;
            scene.add(screenMesh);

            // Create classical overlay (separate plane in front of screen)
            createClassicalOverlay();

            createSourceMarker();
            createBarrier();
            createSlitLabels();
            createWavefronts();
        }

        function createClassicalOverlay() {
            // Create a separate canvas for the classical pattern overlay
            const overlayCanvas = document.createElement('canvas');
            overlayCanvas.width = CONFIG.screenRes.w;
            overlayCanvas.height = CONFIG.screenRes.h;
            classicalOverlayContext = overlayCanvas.getContext('2d');
            
            classicalOverlayTexture = new THREE.CanvasTexture(overlayCanvas);
            
            const overlayGeo = new THREE.PlaneGeometry(CONFIG.sceneWidth, CONFIG.screenHeight);
            const overlayMat = new THREE.MeshBasicMaterial({ 
                map: classicalOverlayTexture, 
                transparent: true,
                opacity: 1,
                side: THREE.DoubleSide,
                depthWrite: false
            });
            classicalOverlayMesh = new THREE.Mesh(overlayGeo, overlayMat);
            classicalOverlayMesh.position.z = -CONFIG.screenDistance + 0.3; // Slightly in front of the detection screen
            classicalOverlayMesh.visible = false;
            scene.add(classicalOverlayMesh);
            
            // Start with clear overlay (dots accumulate when classical mode is on)
            clearClassicalOverlay();
        }

        function clearClassicalOverlay() {
            const ctx = classicalOverlayContext;
            const w = CONFIG.screenRes.w;
            const h = CONFIG.screenRes.h;
            ctx.clearRect(0, 0, w, h);
            classicalOverlayTexture.needsUpdate = true;
        }

        function createSourceMarker() {
            if (sourceMarker) scene.remove(sourceMarker);
            
            const sourceGroup = new THREE.Group();
            const waveColor = nmToThreeColor(getCurrentWavelengthNM());
            
            const barGeometry = new THREE.BoxGeometry(CONFIG.sceneWidth * 0.8, 1, 0.5);
            const barMaterial = new THREE.MeshBasicMaterial({ 
                color: waveColor,
                transparent: true,
                opacity: 0.9
            });
            const bar = new THREE.Mesh(barGeometry, barMaterial);
            sourceGroup.add(bar);
            
            const glowGeometry = new THREE.BoxGeometry(CONFIG.sceneWidth * 0.85, 2, 1);
            const glowMaterial = new THREE.MeshBasicMaterial({ 
                color: waveColor,
                transparent: true,
                opacity: 0.3
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            sourceGroup.add(glow);
            
            const labelCanvas = document.createElement('canvas');
            labelCanvas.width = 256;
            labelCanvas.height = 64;
            const ctx = labelCanvas.getContext('2d');
            const labelRGB = nmToRGB(getCurrentWavelengthNM());
            ctx.fillStyle = `rgb(${Math.round(labelRGB.r*255)},${Math.round(labelRGB.g*255)},${Math.round(labelRGB.b*255)})`;
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('SOURCE', 128, 40);
            
            const labelTexture = new THREE.CanvasTexture(labelCanvas);
            const labelMaterial = new THREE.SpriteMaterial({ map: labelTexture, transparent: true });
            const labelSprite = new THREE.Sprite(labelMaterial);
            labelSprite.scale.set(8, 2, 1);
            labelSprite.position.y = 3;
            sourceGroup.add(labelSprite);
            
            sourceGroup.position.set(0, 0, CONFIG.sourceZ);
            scene.add(sourceGroup);
            sourceMarker = sourceGroup;
        }

        function createSlitLabels() {
            slitLabels.forEach(label => scene.remove(label));
            slitLabels = [];
            
            const s1Canvas = document.createElement('canvas');
            s1Canvas.width = 128;
            s1Canvas.height = 64;
            let ctx = s1Canvas.getContext('2d');
            ctx.fillStyle = '#f472b6';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('S1', 64, 50);
            
            const s1Texture = new THREE.CanvasTexture(s1Canvas);
            const s1Material = new THREE.SpriteMaterial({ map: s1Texture, transparent: true });
            const s1Sprite = new THREE.Sprite(s1Material);
            s1Sprite.scale.set(5, 2.5, 1);
            s1Sprite.position.set(-state.sep/2, 10, CONFIG.barrierZ);
            scene.add(s1Sprite);
            slitLabels.push(s1Sprite);
            
            const s2Canvas = document.createElement('canvas');
            s2Canvas.width = 128;
            s2Canvas.height = 64;
            ctx = s2Canvas.getContext('2d');
            ctx.fillStyle = '#a78bfa';
            ctx.font = 'bold 48px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('S2', 64, 50);
            
            const s2Texture = new THREE.CanvasTexture(s2Canvas);
            const s2Material = new THREE.SpriteMaterial({ map: s2Texture, transparent: true });
            const s2Sprite = new THREE.Sprite(s2Material);
            s2Sprite.scale.set(5, 2.5, 1);
            s2Sprite.position.set(state.sep/2, 10, CONFIG.barrierZ);
            scene.add(s2Sprite);
            slitLabels.push(s2Sprite);
        }

        function createBarrier() {
            if(barrierGroup) scene.remove(barrierGroup);
            barrierGroup = new THREE.Group();

            const mat = new THREE.MeshStandardMaterial({ color: 0x4b5563, roughness: 0.4 });
            const height = 15;
            const depth = 1;

            const centerW = state.sep - state.slitWidth;
            const sideW = (CONFIG.sceneWidth - centerW - (state.slitWidth * 2)) / 2;

            const center = new THREE.Mesh(new THREE.BoxGeometry(centerW, height, depth), mat);
            const left = new THREE.Mesh(new THREE.BoxGeometry(sideW, height, depth), mat);
            left.position.x = -(centerW/2 + state.slitWidth + sideW/2);
            const right = new THREE.Mesh(new THREE.BoxGeometry(sideW, height, depth), mat);
            right.position.x = (centerW/2 + state.slitWidth + sideW/2);

            barrierGroup.add(center, left, right);
            barrierGroup.position.z = CONFIG.barrierZ;
            scene.add(barrierGroup);
            
            if (slitLabels.length >= 2) {
                slitLabels[0].position.x = -state.sep/2;
                slitLabels[1].position.x = state.sep/2;
            }
        }

        function createWavefronts() {
            incidentWaves.forEach(w => scene.remove(w.mesh));
            incidentWaves = [];
            secondaryWavesS1.forEach(w => scene.remove(w.mesh));
            secondaryWavesS1 = [];
            secondaryWavesS2.forEach(w => scene.remove(w.mesh));
            secondaryWavesS2 = [];

            for (let i = 0; i < CONFIG.numIncidentWaves; i++) {
                const z = CONFIG.sourceZ - i * state.lambda * 2;
                if (z > CONFIG.barrierZ) {
                    createIncidentWave(z);
                }
            }
            
            if (sourceMarker) sourceMarker.visible = true;
            slitLabels.forEach(l => l.visible = true);
        }

        function createIncidentWave(zPos) {
            const points = [];
            const width = CONFIG.sceneWidth * 0.7;
            
            for (let i = 0; i <= CONFIG.waveSegments; i++) {
                const x = (i / CONFIG.waveSegments - 0.5) * width;
                points.push(new THREE.Vector3(x, 0, zPos));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: nmToThreeColor(getCurrentWavelengthNM()), 
                transparent: true,
                opacity: 0.8,
                linewidth: 2
            });
            const line = new THREE.Line(geometry, material);
            
            scene.add(line);
            incidentWaves.push({
                mesh: line,
                z: zPos,
                hasSpawnedSecondary: false,
                opacity: 0.8
            });
        }

        function createSecondaryWaveS1(initialRadius) {
            const slitX = -state.sep / 2;
            const numPoints = 120;
            const points = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const angle = (i / numPoints) * Math.PI - Math.PI/2;
                const x = slitX + initialRadius * Math.sin(angle);
                const z = CONFIG.barrierZ - initialRadius * Math.cos(angle);
                points.push(new THREE.Vector3(x, 0, z));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: nmToSecondaryColor(getCurrentWavelengthNM(), 1),
                transparent: true,
                opacity: 0.7
            });
            const arc = new THREE.Line(geometry, material);
            
            scene.add(arc);
            secondaryWavesS1.push({
                mesh: arc,
                slitX: slitX,
                radius: initialRadius,
                opacity: 0.7
            });
        }

        function createSecondaryWaveS2(initialRadius) {
            const slitX = state.sep / 2;
            const numPoints = 120;
            const points = [];
            
            for (let i = 0; i <= numPoints; i++) {
                const angle = (i / numPoints) * Math.PI - Math.PI/2;
                const x = slitX + initialRadius * Math.sin(angle);
                const z = CONFIG.barrierZ - initialRadius * Math.cos(angle);
                points.push(new THREE.Vector3(x, 0, z));
            }
            
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ 
                color: nmToSecondaryColor(getCurrentWavelengthNM(), 2),
                transparent: true,
                opacity: 0.7
            });
            const arc = new THREE.Line(geometry, material);
            
            scene.add(arc);
            secondaryWavesS2.push({
                mesh: arc,
                slitX: slitX,
                radius: initialRadius,
                opacity: 0.7
            });
        }

        // --- PHYSICS LOOP ---
        function updatePhysics(dt, time) {
            updateWaveMode(dt, time);
        }

        function updateWaveMode(dt, time) {
            const speed = state.animationSpeed;
            const screenZ = -CONFIG.screenDistance;

            const incidentToRemove = [];
            incidentWaves.forEach((wave, index) => {
                wave.z -= speed * dt;
                
                const positions = wave.mesh.geometry.attributes.position.array;
                for (let i = 0; i < positions.length / 3; i++) {
                    positions[i * 3 + 2] = wave.z;
                }
                wave.mesh.geometry.attributes.position.needsUpdate = true;
                
                if (wave.z <= CONFIG.barrierZ && !wave.hasSpawnedSecondary) {
                    wave.hasSpawnedSecondary = true;
                    createSecondaryWaveS1(0.5);
                    createSecondaryWaveS2(0.5);
                }
                
                if (wave.z < CONFIG.barrierZ) {
                    wave.opacity -= dt * 3;
                    wave.mesh.material.opacity = Math.max(0, wave.opacity);
                    
                    if (wave.opacity <= 0) {
                        incidentToRemove.push(index);
                    }
                }
            });

            incidentToRemove.reverse().forEach(index => {
                scene.remove(incidentWaves[index].mesh);
                incidentWaves.splice(index, 1);
            });
            
            const maxZ = incidentWaves.length > 0 
                ? Math.max(...incidentWaves.filter(w => w.z > CONFIG.barrierZ).map(w => w.z))
                : CONFIG.sourceZ - state.lambda * 2;
            
            if (maxZ < CONFIG.sourceZ - state.lambda * 1.5) {
                createIncidentWave(CONFIG.sourceZ);
            }

            const s1ToRemove = [];
            secondaryWavesS1.forEach((wave, index) => {
                wave.radius += speed * dt;
                
                const numPoints = 120;
                const positions = wave.mesh.geometry.attributes.position.array;
                const slitX = -state.sep / 2;
                
                for (let i = 0; i <= numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI - Math.PI/2;
                    positions[i * 3] = slitX + wave.radius * Math.sin(angle);
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = CONFIG.barrierZ - wave.radius * Math.cos(angle);
                }
                wave.mesh.geometry.attributes.position.needsUpdate = true;
                
                const maxRadius = 35;
                wave.opacity = Math.max(0, 0.7 * (1 - wave.radius / maxRadius));
                wave.mesh.material.opacity = wave.opacity;

                if (wave.radius > Math.abs(screenZ - CONFIG.barrierZ) - 2 && !wave.recordedHit) {
                    wave.recordedHit = true;
                    recordInterferenceHits(time);
                }

                if (wave.radius > maxRadius) {
                    s1ToRemove.push(index);
                }
            });

            s1ToRemove.reverse().forEach(index => {
                scene.remove(secondaryWavesS1[index].mesh);
                secondaryWavesS1.splice(index, 1);
            });

            const s2ToRemove = [];
            secondaryWavesS2.forEach((wave, index) => {
                wave.radius += speed * dt;
                
                const numPoints = 120;
                const positions = wave.mesh.geometry.attributes.position.array;
                const slitX = state.sep / 2;
                
                for (let i = 0; i <= numPoints; i++) {
                    const angle = (i / numPoints) * Math.PI - Math.PI/2;
                    positions[i * 3] = slitX + wave.radius * Math.sin(angle);
                    positions[i * 3 + 1] = 0;
                    positions[i * 3 + 2] = CONFIG.barrierZ - wave.radius * Math.cos(angle);
                }
                wave.mesh.geometry.attributes.position.needsUpdate = true;
                
                const maxRadius = 35;
                wave.opacity = Math.max(0, 0.7 * (1 - wave.radius / maxRadius));
                wave.mesh.material.opacity = wave.opacity;

                // Record hits when S2 wave reaches screen (symmetric with S1)
                if (wave.radius > Math.abs(screenZ - CONFIG.barrierZ) - 2 && !wave.recordedHit) {
                    wave.recordedHit = true;
                    recordInterferenceHits(time);
                }

                if (wave.radius > maxRadius) {
                    s2ToRemove.push(index);
                }
            });

            s2ToRemove.reverse().forEach(index => {
                scene.remove(secondaryWavesS2[index].mesh);
                secondaryWavesS2.splice(index, 1);
            });
        }

        function recordInterferenceHits(time) {
            const L = CONFIG.screenDistance;
            const numSamples = 75; // Halved: both S1 and S2 now trigger detection
            const d_half = state.sep / 2;
            
            for (let i = 0; i < numSamples; i++) {
                const x = (Math.random() - 0.5) * CONFIG.sceneWidth;
                
                // Quantum: Full double-slit interference pattern
                // I = |œà‚ÇÅ + œà‚ÇÇ|¬≤ = cos¬≤(œÜ) √ó sinc¬≤(Œ≤)
                const theta = Math.atan(x / L);
                const sinTheta = Math.sin(theta);
                
                // Interference term from path difference between slits
                const phi = (Math.PI * state.sep * sinTheta) / state.lambda;
                const interference = Math.pow(Math.cos(phi), 2);
                
                // Single-slit diffraction envelope
                const beta = (Math.PI * state.slitWidth * sinTheta) / state.lambda;
                let diffraction = 1.0;
                if (Math.abs(beta) > 0.001) {
                    diffraction = Math.pow(Math.sin(beta) / beta, 2);
                }
                
                // Quantum: |œà‚ÇÅ + œà‚ÇÇ|¬≤ ‚àù cos¬≤(œÜ) √ó sinc¬≤(Œ≤)
                // The full formula has a factor of 4, but for Monte Carlo rejection
                // sampling we use the normalized shape (max = 1) as the probability.
                const probability = interference * diffraction;
                
                if (Math.random() < probability) {
                    state.detectedCount++;
                    
                    const tx = ((x / CONFIG.sceneWidth) + 0.5) * CONFIG.screenRes.w;
                    const ty = (0.5 + (Math.random() - 0.5) * 0.3) * CONFIG.screenRes.h;
                    
                    screenContext.globalCompositeOperation = 'lighter';
                    screenContext.beginPath();
                    screenContext.arc(tx, ty, 2, 0, Math.PI * 2);
                    screenContext.fillStyle = nmToCSSRGBA(getCurrentWavelengthNM(), 0.3);
                    screenContext.fill();
                    screenTexture.needsUpdate = true;
                    
                    const bin = Math.floor(((x / CONFIG.sceneWidth) + 0.5) * 80);
                    if (bin >= 0 && bin < 80) state.hits[bin]++;
                }
            }

            // Record classical hits when classical mode is on
            // Classical: P‚ÇÅ‚ÇÇ = P‚ÇÅ + P‚ÇÇ (Feynman Vol III, Fig 1-1)
            // Each slit produces its own single-slit diffraction pattern
            // No interference between slits - probabilities add directly
            if (state.showClassical) {
                for (let i = 0; i < numSamples; i++) {
                    const cx = (Math.random() - 0.5) * CONFIG.sceneWidth;

                    // P‚ÇÅ: Single-slit diffraction from slit 1 at x = -d/2
                    const theta1 = Math.atan((cx + d_half) / L);
                    const beta1 = (Math.PI * state.slitWidth * Math.sin(theta1)) / state.lambda;
                    const p1 = Math.abs(beta1) > 0.001 ? Math.pow(Math.sin(beta1) / beta1, 2) : 1.0;
                    
                    // P‚ÇÇ: Single-slit diffraction from slit 2 at x = +d/2
                    const theta2 = Math.atan((cx - d_half) / L);
                    const beta2 = (Math.PI * state.slitWidth * Math.sin(theta2)) / state.lambda;
                    const p2 = Math.abs(beta2) > 0.001 ? Math.pow(Math.sin(beta2) / beta2, 2) : 1.0;
                    
                    // Classical probability: just add (no interference)
                    // Normalize by 2.0 for consistent sampling rate
                    const classicalProb = (p1 + p2) / 2.0;

                    if (Math.random() < classicalProb) {
                        // Draw orange dot on the classical overlay canvas
                        const tx = ((cx / CONFIG.sceneWidth) + 0.5) * CONFIG.screenRes.w;
                        const ty = (0.5 + (Math.random() - 0.5) * 0.3) * CONFIG.screenRes.h;

                        classicalOverlayContext.globalCompositeOperation = 'lighter';
                        classicalOverlayContext.beginPath();
                        classicalOverlayContext.arc(tx, ty, 2, 0, Math.PI * 2);
                        classicalOverlayContext.fillStyle = 'rgba(245, 158, 11, 0.3)';
                        classicalOverlayContext.fill();
                        classicalOverlayTexture.needsUpdate = true;

                        const cbin = Math.floor(((cx / CONFIG.sceneWidth) + 0.5) * 80);
                        if (cbin >= 0 && cbin < 80) state.classicalHits[cbin]++;
                    }
                }
            }
        }

        // --- COMBINED CHART ---
        function getNormalizedHits() {
            const max = Math.max(...state.hits);
            if (max === 0) return Array(state.hits.length).fill(0);
            return Array.from(state.hits, v => v / max);
        }

        function initCombinedChart() {
            const ctx = document.getElementById('combined-chart-canvas').getContext('2d');
            
            const theoreticalData = generateTheoreticalData();
            
            combinedChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: Array(80).fill(''),
                    datasets: [
                        {
                            type: 'bar',
                            label: 'Detected Pattern',
                            data: getNormalizedHits(),
                            backgroundColor: 'rgba(59, 130, 246, 0.7)',
                            borderWidth: 0,
                            barPercentage: 1.1,
                            categoryPercentage: 1.0,
                            yAxisID: 'y',
                            order: 3
                        },
                        {
                            type: 'line',
                            label: 'Quantum |œà‚ÇÅ+œà‚ÇÇ|¬≤',
                            data: theoreticalData,
                            borderColor: '#10b981',
                            backgroundColor: 'rgba(16, 185, 129, 0.15)',
                            borderWidth: 2.5,
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            yAxisID: 'y',
                            order: 1
                        },
                        {
                            type: 'line',
                            label: 'Classical P‚ÇÅ+P‚ÇÇ',
                            data: generateClassicalData(),
                            borderColor: '#f59e0b',
                            backgroundColor: 'rgba(245, 158, 11, 0.12)',
                            borderWidth: 2.5,
                            borderDash: [6, 4],
                            fill: true,
                            tension: 0.4,
                            pointRadius: 0,
                            yAxisID: 'y',
                            order: 2,
                            hidden: true
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'index',
                        intersect: false
                    },
                    plugins: { 
                        legend: { display: false }, 
                        tooltip: { enabled: false } 
                    },
                    scales: {
                        x: { 
                            display: true, 
                            title: {
                                display: true,
                                text: 'Position (x)',
                                color: '#9ca3af',
                                font: { size: 11, weight: '600' }
                            },
                            ticks: { display: false },
                            grid: { display: false }
                        },
                        y: { 
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Normalized Intensity (I/I‚ÇÄ)',
                                color: '#9ca3af',
                                font: { size: 10, weight: '600' }
                            },
                            min: 0,
                            max: 1.1,
                            grid: { color: 'rgba(255,255,255,0.05)' }, 
                            ticks: { display: false }
                        }
                    },
                    animation: false
                }
            });
        }

        // Generate both quantum and classical patterns with proper normalization
        // Both represent probability distributions with EQUAL total probability (same particle flux)
        // We normalize so quantum peak = 1, then scale classical to have same area
        
        function generateTheoreticalData() {
            const numBins = 80;
            const values = [];
            const L = CONFIG.screenDistance;
            
            for (let i = 0; i < numBins; i++) {
                const x = ((i / numBins) - 0.5) * CONFIG.sceneWidth;
                
                const theta = Math.atan(x / L);
                const sinTheta = Math.sin(theta);
                
                // Interference from double-slit path difference
                const phi = (Math.PI * state.sep * sinTheta) / state.lambda;
                const interference = Math.pow(Math.cos(phi), 2);
                
                // Single-slit diffraction envelope
                const beta = (Math.PI * state.slitWidth * sinTheta) / state.lambda;
                let diffraction = 1.0;
                if (Math.abs(beta) > 0.001) {
                    diffraction = Math.pow(Math.sin(beta) / beta, 2);
                }
                
                values.push(interference * diffraction);
            }
            
            // Normalize to max = 1
            const maxVal = Math.max(...values);
            return values.map(v => v / maxVal);
        }

        // Classical pattern: P‚ÇÅ + P‚ÇÇ (Feynman Vol III, Fig 1-1)
        // Each slit produces single-slit diffraction, no interference between slits
        function generateClassicalData() {
            const numBins = 80;
            const L = CONFIG.screenDistance;
            const d_half = state.sep / 2;
            
            // Generate classical pattern: P‚ÇÅ + P‚ÇÇ
            const classicalRaw = [];
            for (let i = 0; i < numBins; i++) {
                const x = ((i / numBins) - 0.5) * CONFIG.sceneWidth;
                
                // P‚ÇÅ: diffraction from slit 1 at -d/2
                const theta1 = Math.atan((x + d_half) / L);
                const beta1 = (Math.PI * state.slitWidth * Math.sin(theta1)) / state.lambda;
                const p1 = Math.abs(beta1) > 0.001 ? Math.pow(Math.sin(beta1) / beta1, 2) : 1.0;
                
                // P‚ÇÇ: diffraction from slit 2 at +d/2
                const theta2 = Math.atan((x - d_half) / L);
                const beta2 = (Math.PI * state.slitWidth * Math.sin(theta2)) / state.lambda;
                const p2 = Math.abs(beta2) > 0.001 ? Math.pow(Math.sin(beta2) / beta2, 2) : 1.0;
                
                classicalRaw.push(p1 + p2);
            }
            
            // Normalize classical to peak = 0.5 (half of quantum peak = 1.0)
            // Correctly represents classical 2I‚ÇÄ vs quantum 4I‚ÇÄ
            const maxClassical = Math.max(...classicalRaw);
            return classicalRaw.map(v => 0.5 * (v / maxClassical));
        }

        function updateCombinedChart() {
            const theoreticalData = generateTheoreticalData();
            
            combinedChart.data.datasets[1].data = theoreticalData;
            combinedChart.data.datasets[0].data = getNormalizedHits();

            // Update bar color to match current wavelength
            combinedChart.data.datasets[0].backgroundColor = nmToCSSRGBA(getCurrentWavelengthNM(), 0.7);

            // Update classical envelope when visible
            if (state.showClassical) {
                combinedChart.data.datasets[2].data = generateClassicalData();
            }
            
            combinedChart.update('none');
        }

        // --- UI & LOGIC ---
        function initUI() {
            const classicalBtn = document.getElementById('classical-btn');

            classicalBtn.onclick = () => {
                state.showClassical = !state.showClassical;
                
                if (state.showClassical) {
                    classicalBtn.classList.add('active');
                    classicalBtn.textContent = 'Hide Classical Pattern';
                    classicalOverlayMesh.visible = true;
                    // Clear overlay for fresh accumulation
                    clearClassicalOverlay();
                    state.classicalHits.fill(0);
                    // Show classical envelope on chart
                    combinedChart.data.datasets[2].hidden = false;
                    combinedChart.data.datasets[2].data = generateClassicalData();
                    document.getElementById('classical-legend').style.display = 'flex';
                    combinedChart.update('none');
                } else {
                    classicalBtn.classList.remove('active');
                    classicalBtn.textContent = 'Show Classical Pattern';
                    classicalOverlayMesh.visible = false;
                    clearClassicalOverlay();
                    state.classicalHits.fill(0);
                    // Hide classical envelope on chart
                    combinedChart.data.datasets[2].hidden = true;
                    document.getElementById('classical-legend').style.display = 'none';
                    combinedChart.update('none');
                }
            };

            // Use global nmToRGB for CSS color display
            function wavelengthToColor(nm) {
                const c = nmToRGB(nm);
                return `rgb(${Math.round(c.r*255)},${Math.round(c.g*255)},${Math.round(c.b*255)})`;
            }

            function updateSimParams() {
                createBarrier();
                createSlitLabels();
                clearClassicalOverlay();
                state.classicalHits.fill(0);
                resetSim();
                updateCombinedChart();
            }

            document.getElementById('slit-sep').oninput = (e) => {
                const val = parseFloat(e.target.value);
                state.sep = val * NM_TO_SIM.sep;
                document.getElementById('slit-sep-value').textContent = Math.round(val) + ' nm';
                updateSimParams();
            };
            document.getElementById('slit-width').oninput = (e) => {
                const val = parseFloat(e.target.value);
                state.slitWidth = val * NM_TO_SIM.width;
                document.getElementById('slit-width-value').textContent = Math.round(val) + ' nm';
                updateSimParams();
            };
            document.getElementById('wavelength').oninput = (e) => {
                const val = parseFloat(e.target.value);
                state.lambda = val * NM_TO_SIM.lambda;
                const valEl = document.getElementById('wavelength-value');
                valEl.textContent = Math.round(val) + ' nm';
                valEl.style.color = wavelengthToColor(val);
                updateAllWaveColors();
                createSourceMarker();
                updateSimParams();
            };
            document.getElementById('screen-dist').oninput = (e) => {
                const val = parseFloat(e.target.value);
                CONFIG.screenDistance = val * NM_TO_SIM.screenDist;
                document.getElementById('screen-dist-value').textContent = Math.round(val) + ' nm';
                // Update screen mesh positions
                if (screenMesh) screenMesh.position.z = -CONFIG.screenDistance;
                if (classicalOverlayMesh) classicalOverlayMesh.position.z = -CONFIG.screenDistance + 0.3;
                clearClassicalOverlay();
                state.classicalHits.fill(0);
                resetSim();
                updateCombinedChart();
            };
            document.getElementById('rate').oninput = (e) => {
                state.animationSpeed = parseInt(e.target.value);
                document.getElementById('rate-value').textContent = state.animationSpeed;
            };
            document.getElementById('reset-btn').onclick = resetSim;

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / (window.innerHeight - 60);
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight - 60);
            });
        }

        function resetSim() {
            state.detectedCount = 0;
            state.hits.fill(0);
            state.classicalHits.fill(0);
            
            screenContext.globalCompositeOperation = 'source-over';
            screenContext.fillStyle = '#1e293b';
            screenContext.fillRect(0, 0, CONFIG.screenRes.w, CONFIG.screenRes.h);
            screenTexture.needsUpdate = true;

            // Clear classical overlay (dots restart fresh if classical mode is on)
            clearClassicalOverlay();
            
            createWavefronts();
            
            updateCombinedChart();
        }

        function animate(time) {
            requestAnimationFrame(animate);
            const dt = Math.min((time - (animate.lastTime || time))/1000, 0.1) || 0;
            animate.lastTime = time;

            controls.update();

            updatePhysics(dt, time);
            renderer.render(scene, camera);

            if (time - (animate.lastFps || 0) > 250) {
                combinedChart.data.datasets[0].data = getNormalizedHits();
                combinedChart.update('none');
                animate.lastFps = time;
            }
        }

        // --- NARRATION / VOICEOVER ENGINE ---
        // Each step has:
        //   text: displayed HTML (can use symbols like Œª)
        //   speech: plain-text version for TTS (spells out symbols naturally)
        const narrationSteps = [
            {
                text: `Welcome to the <span class="highlight">Double-Slit Experiment</span> ‚Äî the most beautiful experiment in physics. We're about to see why quantum mechanics forces us to rethink what we mean by "particle."`,
                speech: `Welcome to the Double-Slit Experiment ‚Äî the most beautiful experiment in physics. We're about to see why quantum mechanics forces us to rethink what we mean by "particle."`,
                duration: 10000
            },
            {
                text: `A source emits particles ‚Äî photons, electrons, or any quantum object ‚Äî one at a time toward a barrier with <span class="highlight">two narrow slits</span>. Watch the planar wavefronts travel from the source to the barrier.`,
                speech: `A source emits particles ‚Äî photons, electrons, or any quantum object ‚Äî one at a time toward a barrier with two narrow slits. Watch the planar wavefronts travel from the source to the barrier.`,
                duration: 10000
            },
            {
                text: `After passing through the slits, each slit acts as a new source of <span class="highlight">circular wavefronts</span>. These secondary waves spread out and overlap as they travel toward the detection screen.`,
                speech: `After passing through the slits, each slit acts as a new source of circular wavefronts. These secondary waves spread out and overlap as they travel toward the detection screen.`,
                duration: 10000
            },
            {
                text: `On the screen, each particle lands at a <span class="highlight">single, definite point</span> ‚Äî just like a classical particle would. But as thousands of detections accumulate, a striking pattern emerges.`,
                speech: `On the screen, each particle lands at a single, definite point ‚Äî just like a classical particle would. But as thousands of detections accumulate, a striking pattern emerges.`,
                duration: 10000
            },
            {
                text: `<span class="highlight-green">Quantum prediction:</span> the probability is computed as |œà‚ÇÅ + œà‚ÇÇ|¬≤ ‚Äî we add the <em>amplitudes</em> first, then square. This creates alternating bright and dark fringes: an <span class="highlight">interference pattern</span>.`,
                speech: `Quantum prediction: the probability is computed as the absolute square of psi 1 plus psi 2 ‚Äî we add the amplitudes first, then square. This creates alternating bright and dark fringes: an interference pattern.`,
                duration: 12000
            },
            {
                text: `<span class="highlight-orange">Classical prediction:</span> if particles were ordinary bullets, we'd add probabilities directly: P‚ÇÅ + P‚ÇÇ. Try clicking <span class="highlight">"Show Classical Pattern"</span> to see how this smooth, featureless curve differs from the quantum fringes.`,
                speech: `Classical prediction: if particles were ordinary bullets, we'd add probabilities directly: P 1 plus P 2. Try clicking "Show Classical Pattern" to see how this smooth, featureless curve differs from the quantum fringes.`,
                duration: 12000
            },
            {
                text: `The key insight: the <span class="highlight-green">interference fringes</span> appear even when particles arrive <em>one at a time</em>. Each particle somehow "knows" about both slits. This is wave-particle duality ‚Äî the heart of quantum mechanics.`,
                speech: `The key insight: the interference fringes appear even when particles arrive one at a time. Each particle somehow "knows" about both slits. This is wave-particle duality ‚Äî the heart of quantum mechanics.`,
                duration: 12000
            },
            {
                text: `Try adjusting the sliders: change the <span class="highlight">wavelength</span> to see how fringe spacing depends on Œª, or vary the <span class="highlight">slit separation</span> to watch fringes compress and expand. The physics is all in the ratio d/Œª.`,
                speech: `Try adjusting the sliders: change the wavelength to see how fringe spacing depends on lambda, or vary the slit separation to watch fringes compress and expand. The physics is all in the ratio d over lambda.`,
                duration: 11000
            }
        ];

        let narration = {
            currentStep: 0,
            isPlaying: false,
            timer: null,
            utterance: null,
            speechSupported: 'speechSynthesis' in window
        };

        function initNarration() {
            const dotsContainer = document.getElementById('narr-dots');
            narrationSteps.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'step-dot' + (i === 0 ? ' active' : '');
                dot.onclick = () => jumpToStep(i);
                dotsContainer.appendChild(dot);
            });

            document.getElementById('narr-play').onclick = playNarration;
            document.getElementById('narr-pause').onclick = pauseNarration;
            document.getElementById('narr-reset').onclick = goBackOneStep;

            // Show first step text immediately
            showStep(0);
        }

        function showStep(index) {
            narration.currentStep = index;
            const step = narrationSteps[index];
            document.getElementById('narration-text').innerHTML = step.text;

            // Update dots
            const dots = document.querySelectorAll('.step-dot');
            dots.forEach((dot, i) => {
                dot.className = 'step-dot';
                if (i < index) dot.classList.add('completed');
                if (i === index) dot.classList.add('active');
            });

            // Update progress bar
            const progress = (index / (narrationSteps.length - 1)) * 100;
            document.getElementById('narr-progress-bar').style.width = progress + '%';
        }

        function finishNarration() {
            // Called when the last step's speech/timer ends
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');

            if (narration.speechSupported) {
                window.speechSynthesis.cancel();
            }
            if (narration.timer) {
                clearTimeout(narration.timer);
                narration.timer = null;
            }

            // Reset to first slide after a brief pause
            narration.timer = setTimeout(() => {
                narration.currentStep = 0;
                showStep(0);
                document.getElementById('narr-progress-bar').style.width = '0%';
                narration.timer = null;
            }, 1200);
        }

        function speakStep(index) {
            if (!narration.speechSupported) return;
            
            // Cancel any ongoing speech
            window.speechSynthesis.cancel();

            const text = narrationSteps[index].speech;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.92;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Select Samantha voice (priority), fallback to any English voice
            const voices = window.speechSynthesis.getVoices();
            const samantha = voices.find(v => v.name.includes('Samantha'));
            const fallback = voices.find(v => v.lang.startsWith('en') && (v.name.includes('Google') || v.name.includes('Natural') || v.name.includes('Daniel'))) || voices.find(v => v.lang.startsWith('en'));
            utterance.voice = samantha || fallback || null;

            utterance.onend = () => {
                if (!narration.isPlaying) return;

                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) {
                    // Last step just finished ‚Äî stop and reset
                    finishNarration();
                } else {
                    // Advance to next step after a short pause
                    narration.timer = setTimeout(() => {
                        if (narration.isPlaying) {
                            showStep(nextIndex);
                            speakStep(nextIndex);
                        }
                    }, 800);
                }
            };

            narration.utterance = utterance;
            window.speechSynthesis.speak(utterance);
        }

        function playNarration() {
            if (narration.isPlaying) return;
            narration.isPlaying = true;
            document.getElementById('narr-play').classList.add('active');
            document.getElementById('narr-pause').classList.remove('active');

            // If timer is pending (e.g. from finishNarration reset delay), clear it
            if (narration.timer) {
                clearTimeout(narration.timer);
                narration.timer = null;
            }

            if (narration.speechSupported) {
                // Ensure voices are loaded
                if (window.speechSynthesis.getVoices().length === 0) {
                    window.speechSynthesis.onvoiceschanged = () => {
                        speakStep(narration.currentStep);
                    };
                } else {
                    speakStep(narration.currentStep);
                }
            } else {
                // Fallback: timed auto-advance without speech
                advanceByTimer();
            }
        }

        function advanceByTimer() {
            if (!narration.isPlaying) return;
            const step = narrationSteps[narration.currentStep];
            narration.timer = setTimeout(() => {
                if (!narration.isPlaying) return;

                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) {
                    finishNarration();
                } else {
                    showStep(nextIndex);
                    advanceByTimer();
                }
            }, step.duration);
        }

        function pauseNarration() {
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');
            document.getElementById('narr-pause').classList.add('active');

            if (narration.speechSupported) {
                window.speechSynthesis.cancel();
            }
            if (narration.timer) {
                clearTimeout(narration.timer);
                narration.timer = null;
            }
        }

        // Reset button ‚Üí go back one step (not jump to first)
        function goBackOneStep() {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');

            const prevStep = Math.max(0, narration.currentStep - 1);
            narration.currentStep = prevStep;
            showStep(prevStep);

            if (wasPlaying) {
                playNarration();
            }
        }

        function jumpToStep(index) {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');
            narration.currentStep = index;
            showStep(index);
            if (wasPlaying) {
                playNarration();
            }
        }

        window.onload = init;

    </script>
</body>
</html>

// I am adding this comment to see whether this reflects in the git repo.
// This is comment number 2 to check the commit 2
// comment 3 (testing)
