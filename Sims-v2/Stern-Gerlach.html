<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stern-Gerlach Experiment ‚Äî Quantum Spin Measurement</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '\\(', right: '\\)', display: false}]});"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: #0a0a0a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            overflow: hidden;
            color: #e0e0e0;
        }
        
        .top-header {
            width: 100%;
            height: 50px;
            background: #141414;
            border-bottom: 1px solid #2a2a2a;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
        }
        
        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .top-header h1 {
            font-size: 16px;
            font-weight: 500;
            color: #e0e0e0;
        }
        
        .header-subtitle {
            font-size: 11px;
            color: #666;
        }
        
        .header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .year-badge {
            padding: 4px 10px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            font-size: 11px;
            color: #888;
        }
        
        .main-container {
            display: flex;
            width: 100vw;
            height: calc(100vh - 50px);
        }
        
        #canvas-container {
            flex: 1;
            position: relative;
            background: #0a0a0a;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        .right-panel {
            width: 320px;
            background: #141414;
            border-left: 1px solid #2a2a2a;
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            padding: 16px;
            gap: 16px;
        }
        
        .right-panel::-webkit-scrollbar {
            width: 6px;
        }
        
        .right-panel::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .right-panel::-webkit-scrollbar-thumb {
            background: #333;
            border-radius: 3px;
        }
        
        .panel-section {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            padding: 16px;
            flex-shrink: 0;
        }
        
        .panel-section h3 {
            font-size: 11px;
            font-weight: 600;
            color: #888;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        
        .mode-indicator {
            padding: 10px 14px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            text-align: center;
            margin-bottom: 12px;
        }
        
        .mode-indicator.quantum {
            background: rgba(79, 209, 255, 0.1);
            color: #4fd1ff;
            border: 1px solid rgba(79, 209, 255, 0.2);
        }
        
        .mode-indicator.classical {
            background: rgba(255, 179, 71, 0.1);
            color: #ffb347;
            border: 1px solid rgba(255, 179, 71, 0.2);
        }
        
        .stat-group {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
        }
        
        .stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            padding: 10px 8px;
            background: #0a0a0a;
            border-radius: 6px;
            border: 1px solid #2a2a2a;
            text-align: center;
            min-width: 60px;
            flex: 1;
        }
        
        .stat-label {
            color: #666;
            font-size: 9px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        
        .stat-value {
            color: #e0e0e0;
            font-weight: 600;
            font-size: 16px;
            font-variant-numeric: tabular-nums;
        }
        
        .control {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 14px;
        }
        
        .control:last-child {
            margin-bottom: 0;
        }
        
        .control-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .control label {
            color: #888;
            font-size: 12px;
            font-weight: 500;
        }
        
        .control-value-display {
            color: #e0e0e0;
            font-weight: 500;
            font-size: 12px;
        }
        
        .slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: #2a2a2a;
            border-radius: 2px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #e0e0e0;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            background: #fff;
        }
        
        select {
            width: 100%;
            padding: 8px 12px;
            background: #0a0a0a;
            border: 1px solid #333;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 12px;
            font-family: inherit;
        }
        
        select:focus {
            outline: none;
            border-color: #4fd1ff;
        }
        
        button {
            width: 100%;
            padding: 10px 14px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 6px;
            color: #e0e0e0;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            font-family: inherit;
            transition: all 0.2s ease;
            margin-bottom: 10px;
        }
        
        button:hover {
            background: #222;
            border-color: #444;
        }
        
        button:last-child {
            margin-bottom: 0;
        }
        
        button.active {
            background: rgba(255, 179, 71, 0.15);
            border-color: rgba(255, 179, 71, 0.3);
            color: #ffb347;
        }
        
        button.active:hover {
            background: rgba(255, 179, 71, 0.2);
        }
        
        .info-text {
            color: #888;
            font-size: 11px;
            line-height: 1.6;
        }
        
        .info-text strong {
            color: #e0e0e0;
            font-weight: 500;
        }
        
        .legend {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 10px;
            color: #888;
        }
        
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .legend-dot.initial { background: #9dff6b; }
        .legend-dot.classical { background: #ffb347; }
        
        .equation-box {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 12px 12px 8px;
            margin-top: 10px;
            color: #4fd1ff;
            text-align: center;
            font-size: 11px;
        }
        
        .equation-box .katex { color: #4fd1ff; font-size: 11px; }
        
        .beam-legend {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 6px;
            padding: 12px;
            margin-top: 8px;
        }
        
        .beam-legend-title {
            font-size: 10px;
            color: #666;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.03em;
        }
        
        .beam-legend-items {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 150px;
            overflow-y: auto;
        }
        
        .beam-legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 11px;
        }
        
        .beam-legend-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        
        .beam-legend-label {
            color: #aaa;
        }
        
        .beam-legend-count {
            margin-left: auto;
            color: #666;
            font-variant-numeric: tabular-nums;
        }

        /* INFO ICON & TOOLTIP */
        .info-icon-container {
            position: relative;
            display: inline-flex;
            align-items: center;
            margin-left: 12px;
        }
        .info-icon-btn {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #2a2a2a;
            border: 1px solid #444;
            color: #888;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: 700;
            font-style: italic;
            font-family: Georgia, serif;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .info-icon-btn:hover {
            background: rgba(79, 209, 255, 0.15);
            border-color: #4fd1ff;
            color: #4fd1ff;
        }
        .info-tooltip {
            position: absolute;
            top: 34px;
            left: 0;
            width: 330px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 8px;
            padding: 14px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.6);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-8px);
            transition: all 0.25s ease;
            z-index: 300;
        }
        .info-icon-container:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        .info-tooltip::before {
            content: '';
            position: absolute;
            top: -6px;
            left: 7px;
            width: 0;
            height: 0;
            border-left: 6px solid transparent;
            border-right: 6px solid transparent;
            border-bottom: 6px solid #333;
        }
        .info-tooltip::after {
            content: '';
            position: absolute;
            top: -4px;
            left: 8px;
            width: 0;
            height: 0;
            border-left: 5px solid transparent;
            border-right: 5px solid transparent;
            border-bottom: 5px solid #1a1a1a;
        }
        .info-tooltip-title {
            font-size: 10px;
            font-weight: 600;
            color: #4fd1ff;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .info-tooltip-text {
            font-size: 11px;
            color: #999;
            line-height: 1.5;
            margin: 0 0 7px 0;
        }
        .info-tooltip-text strong {
            color: #ccc;
            font-weight: 500;
        }
        .info-tooltip-eq {
            background: #0a0a0a;
            border: 1px solid #2a2a2a;
            border-radius: 4px;
            padding: 10px 10px 6px;
            margin: 8px 0;
            text-align: center;
        }
        .info-tooltip-eq .katex { color: #4fd1ff; font-size: 11px; }
        .info-tooltip-legend {
            display: flex;
            flex-direction: column;
            gap: 4px;
            margin-top: 6px;
        }
        .info-legend-item {
            display: flex;
            align-items: center;
            gap: 7px;
            font-size: 10px;
            color: #888;
        }
        .info-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
            display: inline-block;
        }

        /* NARRATION PANEL ‚Äî in-flow inside right-panel */
        .narration-panel {
            background: #1a1a1a;
            border: 1px solid #2a2a2a;
            border-radius: 8px;
            overflow: hidden;
            flex-shrink: 0;
        }
        .narration-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 9px 12px;
            background: #1a1a1a;
            border-bottom: 1px solid #2a2a2a;
        }
        .narration-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .narration-header-left .narr-icon {
            font-size: 12px;
            flex-shrink: 0;
        }
        .narration-header-left span {
            font-size: 10px;
            font-weight: 600;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .narration-controls {
            display: flex;
            gap: 3px;
            align-items: center;
        }
        .narr-btn {
            width: 26px !important;
            height: 26px;
            min-width: 26px;
            border-radius: 50%;
            border: 1px solid #333;
            background: #1a1a1a;
            color: #888;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            transition: all 0.2s;
            padding: 0 !important;
            margin: 0 !important;
        }
        .narr-btn:hover {
            border-color: #4fd1ff;
            color: #4fd1ff;
            background: rgba(79, 209, 255, 0.08);
        }
        .narr-btn.active {
            background: rgba(79, 209, 255, 0.15);
            border-color: rgba(79, 209, 255, 0.4);
            color: #4fd1ff;
        }
        .narration-progress {
            height: 2px;
            background: #222;
        }
        .narration-progress-bar {
            height: 100%;
            background: #4fd1ff;
            width: 0%;
            transition: width 0.3s linear;
        }
        .narration-body {
            padding: 10px 12px;
            min-height: 56px;
            display: flex;
            align-items: center;
        }
        .narration-text {
            font-size: 11.5px;
            color: #ccc;
            line-height: 1.55;
            margin: 0;
        }
        .narration-text .hl {
            color: #4fd1ff;
            font-weight: 600;
        }
        .narration-text .hl-green {
            color: #9dff6b;
            font-weight: 600;
        }
        .narration-text .hl-orange {
            color: #ffb347;
            font-weight: 600;
        }
        .narration-text .hl-pink {
            color: #ff6b9d;
            font-weight: 600;
        }
        .narr-step-dots {
            display: flex;
            justify-content: center;
            gap: 5px;
            padding: 6px 12px 9px;
        }
        .narr-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: #333;
            transition: all 0.3s;
            cursor: pointer;
        }
        .narr-dot.active {
            background: #4fd1ff;
            box-shadow: 0 0 5px rgba(79, 209, 255, 0.5);
        }
        .narr-dot.completed {
            background: #555;
        }
    </style>
</head>
<body>
    <div class="top-header">
        <div class="header-left">
            <div>
                <h1>Stern-Gerlach Experiment</h1>
                <div class="header-subtitle">Quantum Spin Measurement Simulation</div>
            </div>
            <div class="info-icon-container">
                <div class="info-icon-btn">i</div>
                <div class="info-tooltip">
                    <div class="info-tooltip-title">Physics Explanation</div>
                    <p class="info-tooltip-text">
                        <strong>Quantum Result:</strong> Particles with spin j deflect to exactly (2j+1) positions, corresponding to m<sub>J</sub> = ‚àíj, ‚àíj+1, ‚Ä¶, j‚àí1, j.
                    </p>
                    <p class="info-tooltip-text">
                        <strong>Classical Prediction:</strong> Random magnetic moment orientations would produce a continuous spread of deflections.
                    </p>
                    <p class="info-tooltip-text">
                        <strong>Note:</strong> This simulation assumes g<sub>J</sub> = 1 for simplicity. For silver atoms (original experiment), g<sub>J</sub> ‚âà 2.
                    </p>
                    <div class="info-tooltip-eq">
                        $$F_z = -g_J \, m_J \, \mu_B \, \frac{\partial B}{\partial z}$$
                    </div>
                    <div class="info-tooltip-legend">
                        <span class="info-legend-item"><span class="info-dot" style="background:#9dff6b;"></span> Superposition (before measurement)</span>
                        <span class="info-legend-item"><span class="info-dot" style="background:#ffb347;"></span> Classical continuous distribution</span>
                    </div>
                </div>
            </div>
        </div>
        <div class="header-right">
            <div class="year-badge">Est. 1922</div>
        </div>
    </div>
    
    <div class="main-container">
        <div id="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
        
        <div class="right-panel">
            <!-- NARRATION PANEL at top of control panel -->
            <div class="narration-panel" id="narration-panel">
                <div class="narration-header">
                    <div class="narration-header-left">
                        <div class="narr-icon">üîä</div>
                        <span>Simulation Context</span>
                    </div>
                    <div class="narration-controls">
                        <button class="narr-btn" id="narr-back" title="Previous step">‚è™</button>
                        <button class="narr-btn" id="narr-play" title="Play">‚ñ∂</button>
                        <button class="narr-btn" id="narr-pause" title="Pause">‚è∏</button>
                    </div>
                </div>
                <div class="narration-progress">
                    <div class="narration-progress-bar" id="narr-progress-bar"></div>
                </div>
                <div class="narration-body">
                    <p class="narration-text" id="narration-text"></p>
                </div>
                <div class="narr-step-dots" id="narr-dots"></div>
            </div>

            <div class="panel-section">
                <h3>Detection Statistics</h3>
                <div id="modeIndicator" class="mode-indicator quantum">‚öõ Quantum Mode ‚Äî Discrete Spin States</div>
                <div class="stat-group" id="statGroup">
                    <div class="stat">
                        <span class="stat-label">Total</span>
                        <span class="stat-value" id="totalAtoms">0</span>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <h3>Beam Legend (Live)</h3>
                <div class="beam-legend">
                    <div class="beam-legend-title">m‚±º States (2j+1 = <span id="beamCountDisplay">2</span> beams)</div>
                    <div class="beam-legend-items" id="beamLegendItems">
                        <!-- Dynamically populated -->
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <h3>Apparatus Controls</h3>
                <div class="control">
                    <div class="control-header">
                        <label for="spinSelect">Total Spin (j)</label>
                        <span class="control-value-display">j = <span id="spinValue">1/2</span></span>
                    </div>
                    <select id="spinSelect">
                        <option value="0">j = 0 (1 beam)</option>
                        <option value="0.5" selected>j = 1/2 (2 beams)</option>
                        <option value="1">j = 1 (3 beams)</option>
                        <option value="1.5">j = 3/2 (4 beams)</option>
                        <option value="2">j = 2 (5 beams)</option>
                    </select>
                </div>
                <div class="control">
                    <div class="control-header">
                        <label for="fieldStrength">Magnetic Field Gradient</label>
                        <span class="control-value-display"><span id="fieldValue">5</span> T/m</span>
                    </div>
                    <input type="range" class="slider" id="fieldStrength" min="1" max="10" value="5">
                </div>
                <div class="control">
                    <div class="control-header">
                        <label for="emissionRate">Beam Intensity</label>
                        <span class="control-value-display"><span id="emissionValue">8</span> atoms/s</span>
                    </div>
                    <input type="range" class="slider" id="emissionRate" min="1" max="20" value="8">
                </div>
                <button id="classicalToggle">Switch to Classical Prediction</button>
                <button id="reset">Reset Experiment</button>
            </div>
        </div>
    </div>
    
    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        
        let width, height;
        let atoms = [];
        let totalCount = 0;
        let lastEmitTime = 0;
        let animationTime = 0;
        let lastFrameTime = 0;
        
        // Controls
        let fieldStrength = 5;
        let emissionRate = 8;
        let classicalMode = false;
        let totalSpin = 0.5; // j value
        
        // ‚îÄ‚îÄ‚îÄ Coordinate System ‚îÄ‚îÄ‚îÄ
        // Canvas: origin top-left, x increases right, y increases downward.
        // Physics convention: positive m_j deflects toward stronger field (top of canvas = smaller y).
        //   However, the field gradient is implicitly negative (stronger at top),
        //   so the double-negative means positive m_j ‚Üí positive vy ‚Üí downward on screen.
        // All positions are in pixel-space; physical units are absorbed into FORCE_CONST.
        
        // Layout positions
        let sourceX, magnetStartX, magnetEndX, detectorX, detectorWindowX;
        let magnetTopY, magnetBottomY, centerY;
        let detectorHeight, detectorWindowHeight, detectorWindowWidth;
        
        // Detection data
        let detectionPoints = [];
        let spinCounts = {}; // Track counts per mj value
        
        // Colors for different mj states
        // Colors are assigned by sorting m_j values high-to-low and mapping to array indices.
        // Index 0 = highest mj, index 1 = next highest, etc.
        const SPIN_COLORS = [
            '#ff6b9d', // pink - assigned to highest m_j (deflects most downward on screen)
            '#4da6ff', // blue
            '#9dff6b', // green
            '#ffb347', // orange
            '#c77dff', // purple - assigned to lowest m_j (deflects most upward on screen)
        ];
        
        // Light green color for mj labels on detector screen
        const MJ_LABEL_COLOR = '#9dff6b';
        
        // Colors
        const COLORS = {
            initial: '#9dff6b',
            initialRgba: 'rgba(157, 255, 107, ',
            classical: '#ffb347',
            classicalRgba: 'rgba(255, 179, 71, ',
            quantum: '#4fd1ff',
            hot: '#ff8c3c',
            metal: '#3d4a5c',
            metalLight: '#5a6b80',
            metalDark: '#2a3444'
        };
        
        // Analytically compute expected deflection per unit mj at the detector,
        // derived from the same discrete physics as Atom.update():
        //   total_deflection = a * N_mag * (N_mag + 1) / 2  +  a * N_mag * N_drift
        // where a = fieldStrength * FORCE_CONST * mj, N = frames in each region.
        // Force constant: converts (field_gradient √ó m_j) into pixel-space acceleration
        // Units: [pixels/frame¬≤] per [field_strength] per [unit m_j]
        // This is a visualization tuning parameter, not a physical constant.
        // Physical basis: F = -g_J √ó m_J √ó ¬µ_B √ó (‚àÇB/‚àÇz), then a = F/m
        // The constant absorbs g_J, ¬µ_B/m, and the physics-to-pixel scaling.
        const FORCE_CONST = 0.0014; // Tuned for visual clarity
        const MEAN_VX = 2.4;
        
        function getDeflectionPerMj() {
            const magnetLength = magnetEndX - magnetStartX;
            const driftLength = detectorX - magnetEndX;
            const nMag = magnetLength / MEAN_VX;
            const nDrift = driftLength / MEAN_VX;
            return fieldStrength * FORCE_CONST * nMag * (nMag / 2 + nDrift);
        }
        
        function getMjValues() {
            const values = [];
            for (let mj = -totalSpin; mj <= totalSpin; mj += 1) {
                values.push(mj);
            }
            return values;
        }
        
        // Get color for mj value - higher mj values get earlier colors in the array
        // This ensures colors match the vertical position on screen (higher mj = higher on screen)
        function getColorForMj(mj) {
            const mjValues = getMjValues();
            // Sort from highest to lowest mj (matches screen position: top to bottom)
            const sortedMj = [...mjValues].sort((a, b) => b - a);
            const index = sortedMj.indexOf(mj);
            return SPIN_COLORS[index % SPIN_COLORS.length];
        }
        
        function getColorRgbaForMj(mj, alpha) {
            const color = getColorForMj(mj);
            // Convert hex to rgba
            const r = parseInt(color.slice(1, 3), 16);
            const g = parseInt(color.slice(3, 5), 16);
            const b = parseInt(color.slice(5, 7), 16);
            return `rgba(${r}, ${g}, ${b}, ${alpha})`;
        }
        
        function formatMj(mj) {
            if (mj === 0) return '0';
            if (mj === 0.5) return '+1/2';
            if (mj === -0.5) return '-1/2';
            if (mj === 1.5) return '+3/2';
            if (mj === -1.5) return '-3/2';
            if (mj > 0) return '+' + mj;
            return '' + mj;
        }
        
        function initSpinCounts() {
            spinCounts = {};
            const mjValues = getMjValues();
            mjValues.forEach(mj => {
                spinCounts[mj] = 0;
            });
        }
        
        function resize() {
            const container = document.getElementById('canvas-container');
            const dpr = window.devicePixelRatio || 1;
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width * dpr;
            canvas.height = height * dpr;
            canvas.style.width = width + 'px';
            canvas.style.height = height + 'px';
            ctx.scale(dpr, dpr);
            
            sourceX = width * 0.08;
            magnetStartX = width * 0.25;
            magnetEndX = width * 0.48;
            detectorX = width * 0.64;
            detectorWindowX = width * 0.73;
            centerY = height * 0.5;
            magnetTopY = centerY - height * 0.18;
            magnetBottomY = centerY + height * 0.18;
            
            detectorWindowHeight = height * 0.8;
            detectorWindowWidth = width * 0.2;
            detectorHeight = detectorWindowHeight;
        }
        
        // Effusive beam speed distribution: chi(4), i.e. f(v) ‚àù v¬≥ exp(-v¬≤/2)
        // Models thermal atoms effusing from an oven aperture
        function sampleEffusiveSpeed(meanSpeed) {
            const chi4Mean = 1.8800; // theoretical mean of chi(4)
            let v;
            // Rejection sampling to enforce ~10% effective spread (velocity selection)
            const lo = 0.9 * meanSpeed;
            const hi = 1.1 * meanSpeed;
            do {
                let sumSq = 0;
                for (let i = 0; i < 4; i++) {
                    const u1 = Math.random();
                    const u2 = Math.random();
                    const z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
                    sumSq += z * z;
                }
                v = Math.sqrt(sumSq) * (meanSpeed / chi4Mean);
            } while (v < lo || v > hi);
            return v;
        }
        
        class Atom {
            constructor() {
                this.x = sourceX + 30;
                this.y = centerY + (Math.random() - 0.5) * 12;
                this.vx = sampleEffusiveSpeed(MEAN_VX);
                this.vy = 0;
                this.phase = Math.random() * Math.PI * 2;
                
                if (classicalMode) {
                    this.mj = (Math.random() * 2 - 1) * totalSpin;
                    this.isClassical = true;
                } else {
                    // Randomly select one of the allowed mj values
                    const mjValues = getMjValues();
                    this.mj = mjValues[Math.floor(Math.random() * mjValues.length)];
                    this.isClassical = false;
                }
                
                this.inField = false;
                this.pastField = false;
                this.hasEnteredField = false;
                this.detected = false;
                this.trail = [];
                this.size = 5;
                this.alpha = 1;
                this.wobble = 0;
            }
            
            getColor() {
                if (!this.hasEnteredField) return COLORS.initial;
                if (this.isClassical) return COLORS.classical;
                return getColorForMj(this.mj);
            }
            
            getColorRgba(alpha) {
                if (!this.hasEnteredField) return COLORS.initialRgba + alpha + ')';
                if (this.isClassical) return COLORS.classicalRgba + alpha + ')';
                return getColorRgbaForMj(this.mj, alpha);
            }
            
            update(dt) {
                if (this.detected) return false;
                
                const dtScale = dt / 16.67; // normalize to 60fps for frame-rate independence
                
                this.wobble = Math.sin(animationTime * 0.01 + this.phase) * 0.5;
                
                if (this.trail.length > 40) this.trail.shift();
                this.trail.push({ 
                    x: this.x, 
                    y: this.y + this.wobble,
                    hasEnteredField: this.hasEnteredField,
                    mj: this.mj,
                    isClassical: this.isClassical
                });
                
                if (this.x >= magnetStartX && this.x <= magnetEndX) {
                    this.inField = true;
                    this.hasEnteredField = true;
                    // Magnetic force: F_z = -g_J √ó m_J √ó ¬µ_B √ó (‚àÇB/‚àÇz)
                    // Sign convention in canvas coords (y increases downward):
                    //   Field gradient ‚àÇB/‚àÇz < 0 (stronger at top, magnetTopY < centerY)
                    //   The implicit negative gradient and the formula's minus sign cancel,
                    //   so positive m_j ‚Üí positive vy ‚Üí downward deflection (correct).
                    const fieldEffect = fieldStrength * FORCE_CONST * this.mj;
                    this.vy += fieldEffect * dtScale;
                } else if (this.x > magnetEndX) {
                    this.pastField = true;
                }
                
                this.x += this.vx * dtScale;
                this.y += this.vy * dtScale;
                
                if (this.x >= detectorX) {
                    this.detected = true;
                    this.recordDetection();
                    return false;
                }
                
                if (this.y < 0 || this.y > height) return false;
                return true;
            }
            
            recordDetection() {
                totalCount++;
                if (!this.isClassical) {
                    // Find closest mj value for counting
                    const mjValues = getMjValues();
                    let closestMj = mjValues[0];
                    let minDiff = Math.abs(this.mj - closestMj);
                    mjValues.forEach(mj => {
                        const diff = Math.abs(this.mj - mj);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestMj = mj;
                        }
                    });
                    spinCounts[closestMj] = (spinCounts[closestMj] || 0) + 1;
                }
                
                const windowTop = centerY - detectorWindowHeight / 2;
                const relativeY = this.y - windowTop;
                const normalizedY = Math.max(10, Math.min(detectorWindowHeight - 10, relativeY));
                
                detectionPoints.push({
                    y: normalizedY,
                    mj: this.mj,
                    isClassical: this.isClassical,
                    x: (Math.random() - 0.5) * (detectorWindowWidth * 0.5),
                    time: animationTime
                });
                
                if (detectionPoints.length > 1500) detectionPoints.shift();
            }
            
            draw() {
                // Trail with gradient
                if (this.trail.length > 1) {
                    for (let i = 1; i < this.trail.length; i++) {
                        const prev = this.trail[i - 1];
                        const curr = this.trail[i];
                        const alpha = (i / this.trail.length) * 0.4;
                        
                        ctx.beginPath();
                        ctx.moveTo(prev.x, prev.y);
                        ctx.lineTo(curr.x, curr.y);
                        
                        let color;
                        if (!curr.hasEnteredField) color = COLORS.initialRgba + alpha + ')';
                        else if (curr.isClassical) color = COLORS.classicalRgba + alpha + ')';
                        else color = getColorRgbaForMj(curr.mj, alpha);
                        
                        ctx.strokeStyle = color;
                        ctx.lineWidth = 2.5;
                        ctx.lineCap = 'round';
                        ctx.stroke();
                    }
                }
                
                const color = this.getColor();
                const yPos = this.y + this.wobble;
                
                // Outer glow
                const glowGrad = ctx.createRadialGradient(this.x, yPos, 0, this.x, yPos, this.size * 4);
                glowGrad.addColorStop(0, this.getColorRgba(0.5));
                glowGrad.addColorStop(0.5, this.getColorRgba(0.15));
                glowGrad.addColorStop(1, 'transparent');
                ctx.beginPath();
                ctx.arc(this.x, yPos, this.size * 4, 0, Math.PI * 2);
                ctx.fillStyle = glowGrad;
                ctx.fill();
                
                // Core particle
                const coreGrad = ctx.createRadialGradient(this.x - 1, yPos - 1, 0, this.x, yPos, this.size);
                coreGrad.addColorStop(0, '#ffffff');
                coreGrad.addColorStop(0.3, color);
                coreGrad.addColorStop(1, this.getColorRgba(0.8));
                ctx.beginPath();
                ctx.arc(this.x, yPos, this.size, 0, Math.PI * 2);
                ctx.fillStyle = coreGrad;
                ctx.fill();
            }
        }
        
        function drawBackground() {
            // Deep space gradient
            const bgGrad = ctx.createRadialGradient(width * 0.3, height * 0.5, 0, width * 0.5, height * 0.5, width);
            bgGrad.addColorStop(0, '#0d1525');
            bgGrad.addColorStop(0.5, '#080c15');
            bgGrad.addColorStop(1, '#050810');
            ctx.fillStyle = bgGrad;
            ctx.fillRect(0, 0, width, height);
            
            // Subtle grid
            ctx.strokeStyle = 'rgba(80, 120, 180, 0.04)';
            ctx.lineWidth = 1;
            const gridSize = 40;
            for (let x = 0; x < width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, height);
                ctx.stroke();
            }
            for (let y = 0; y < height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Center line reference
            ctx.strokeStyle = 'rgba(79, 209, 255, 0.08)';
            ctx.setLineDash([8, 12]);
            ctx.beginPath();
            ctx.moveTo(0, centerY);
            ctx.lineTo(width, centerY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawSource() {
            const baseX = sourceX - 35;
            const baseY = centerY;
            
            // Main furnace body - 3D effect
            const bodyWidth = 70;
            const bodyHeight = 100;
            
            // Back shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.beginPath();
            ctx.roundRect(baseX + 5, baseY - bodyHeight/2 + 5, bodyWidth, bodyHeight, 12);
            ctx.fill();
            
            // Main body gradient
            const bodyGrad = ctx.createLinearGradient(baseX, baseY, baseX + bodyWidth, baseY);
            bodyGrad.addColorStop(0, '#4a5568');
            bodyGrad.addColorStop(0.3, '#718096');
            bodyGrad.addColorStop(0.7, '#4a5568');
            bodyGrad.addColorStop(1, '#2d3748');
            ctx.fillStyle = bodyGrad;
            ctx.beginPath();
            ctx.roundRect(baseX, baseY - bodyHeight/2, bodyWidth, bodyHeight, 12);
            ctx.fill();
            
            // Top highlight
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(baseX + 12, baseY - bodyHeight/2 + 2);
            ctx.lineTo(baseX + bodyWidth - 12, baseY - bodyHeight/2 + 2);
            ctx.stroke();
            
            // Heating coils (decorative rings)
            for (let i = 0; i < 4; i++) {
                const y = baseY - 30 + i * 20;
                ctx.strokeStyle = `rgba(255, 140, 60, ${0.3 + Math.sin(animationTime * 0.005 + i) * 0.15})`;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(baseX + 8, y);
                ctx.lineTo(baseX + bodyWidth - 8, y);
                ctx.stroke();
            }
            
            // Inner furnace glow
            const glowGrad = ctx.createRadialGradient(baseX + 50, baseY, 5, baseX + 50, baseY, 50);
            glowGrad.addColorStop(0, 'rgba(255, 200, 100, 0.9)');
            glowGrad.addColorStop(0.3, 'rgba(255, 140, 60, 0.5)');
            glowGrad.addColorStop(0.6, 'rgba(255, 100, 50, 0.2)');
            glowGrad.addColorStop(1, 'transparent');
            ctx.fillStyle = glowGrad;
            ctx.beginPath();
            ctx.arc(baseX + 50, baseY, 50, 0, Math.PI * 2);
            ctx.fill();
            
            // Aperture / collimator
            const apertureX = baseX + bodyWidth;
            const apertureWidth = 25;
            
            // Collimator tube
            const tubeGrad = ctx.createLinearGradient(apertureX, baseY - 15, apertureX, baseY + 15);
            tubeGrad.addColorStop(0, '#5a6b80');
            tubeGrad.addColorStop(0.5, '#3d4a5c');
            tubeGrad.addColorStop(1, '#2a3444');
            ctx.fillStyle = tubeGrad;
            ctx.fillRect(apertureX, baseY - 15, apertureWidth, 30);
            
            // Aperture slit
            ctx.fillStyle = '#0a0f1a';
            ctx.fillRect(apertureX + apertureWidth - 5, baseY - 6, 5, 12);
            
            // Beam emission glow
            const beamGlow = ctx.createRadialGradient(apertureX + apertureWidth, baseY, 0, apertureX + apertureWidth, baseY, 25);
            beamGlow.addColorStop(0, 'rgba(157, 255, 107, 0.4)');
            beamGlow.addColorStop(1, 'transparent');
            ctx.fillStyle = beamGlow;
            ctx.beginPath();
            ctx.arc(apertureX + apertureWidth, baseY, 25, 0, Math.PI * 2);
            ctx.fill();
            
            // Labels
            ctx.fillStyle = '#8898b8';
            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Particle Source', baseX + bodyWidth/2, baseY + bodyHeight/2 + 24);
            ctx.fillStyle = '#5a6a8a';
            ctx.font = '10px monospace';
            ctx.fillText(`j = ${totalSpin === 0.5 ? '1/2' : totalSpin === 1.5 ? '3/2' : totalSpin}`, baseX + bodyWidth/2, baseY + bodyHeight/2 + 40);
        }
        
        function drawMagnet() {
            const magnetWidth = magnetEndX - magnetStartX;
            const poleHeight = height * 0.14;
            const poleDepth = 12;
            const gapHeight = magnetBottomY - magnetTopY;
            
            // Connection yoke (back)
            ctx.fillStyle = '#2d3748';
            ctx.beginPath();
            ctx.roundRect(magnetStartX - 20, magnetTopY - poleHeight - 10, magnetWidth + 40, poleHeight * 2 + gapHeight + 20, 8);
            ctx.fill();
            
            // North pole (top) - pointed shape for inhomogeneous field
            const northGrad = ctx.createLinearGradient(magnetStartX, magnetTopY - poleHeight, magnetStartX, magnetTopY + 35);
            northGrad.addColorStop(0, '#dc2626');
            northGrad.addColorStop(0.4, '#ef4444');
            northGrad.addColorStop(0.7, '#b91c1c');
            northGrad.addColorStop(1, '#7f1d1d');
            
            ctx.fillStyle = northGrad;
            ctx.beginPath();
            ctx.moveTo(magnetStartX, magnetTopY - poleHeight);
            ctx.lineTo(magnetEndX, magnetTopY - poleHeight);
            ctx.lineTo(magnetEndX, magnetTopY);
            ctx.lineTo((magnetStartX + magnetEndX) / 2, magnetTopY + 35);
            ctx.lineTo(magnetStartX, magnetTopY);
            ctx.closePath();
            ctx.fill();
            
            // North pole 3D edge
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.moveTo(magnetStartX, magnetTopY - poleHeight);
            ctx.lineTo(magnetStartX + poleDepth, magnetTopY - poleHeight + poleDepth);
            ctx.lineTo(magnetStartX + poleDepth, magnetTopY - poleDepth);
            ctx.lineTo(magnetStartX, magnetTopY);
            ctx.closePath();
            ctx.fill();
            
            // South pole (bottom) - flat for field gradient
            const southGrad = ctx.createLinearGradient(magnetStartX, magnetBottomY, magnetStartX, magnetBottomY + poleHeight);
            southGrad.addColorStop(0, '#1d4ed8');
            southGrad.addColorStop(0.3, '#3b82f6');
            southGrad.addColorStop(0.7, '#2563eb');
            southGrad.addColorStop(1, '#1e40af');
            
            ctx.fillStyle = southGrad;
            ctx.beginPath();
            ctx.moveTo(magnetStartX, magnetBottomY);
            ctx.lineTo(magnetEndX, magnetBottomY);
            ctx.lineTo(magnetEndX, magnetBottomY + poleHeight);
            ctx.lineTo(magnetStartX, magnetBottomY + poleHeight);
            ctx.closePath();
            ctx.fill();
            
            // South pole 3D edge
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            ctx.beginPath();
            ctx.moveTo(magnetStartX, magnetBottomY);
            ctx.lineTo(magnetStartX + poleDepth, magnetBottomY + poleDepth);
            ctx.lineTo(magnetStartX + poleDepth, magnetBottomY + poleHeight - poleDepth);
            ctx.lineTo(magnetStartX, magnetBottomY + poleHeight);
            ctx.closePath();
            ctx.fill();
            
            // Pole labels with glow
            ctx.shadowColor = '#ef4444';
            ctx.shadowBlur = 15;
            ctx.fillStyle = '#fff';
            ctx.font = 'bold 18px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('N', (magnetStartX + magnetEndX) / 2, magnetTopY - poleHeight / 2 + 6);
            
            ctx.shadowColor = '#3b82f6';
            ctx.fillText('S', (magnetStartX + magnetEndX) / 2, magnetBottomY + poleHeight / 2 + 6);
            ctx.shadowBlur = 0;
            
            // Draw field lines
            drawFieldLines();
            
            // Info labels
            ctx.fillStyle = '#8898b8';
            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Inhomogeneous Magnet', (magnetStartX + magnetEndX) / 2, magnetBottomY + poleHeight + 28);
            ctx.fillStyle = '#5a6a8a';
            ctx.font = '10px monospace';
            ctx.fillText(`‚àÇB/‚àÇz = ${fieldStrength} T/m`, (magnetStartX + magnetEndX) / 2, magnetBottomY + poleHeight + 44);
        }
        
        function drawFieldLines() {
            const numLines = 10;
            const startY = magnetTopY + 25;
            const endY = magnetBottomY - 5;
            const tipX = (magnetStartX + magnetEndX) / 2;
            const tipY = magnetTopY + 35;
            
            for (let i = 0; i < numLines; i++) {
                const t = (i + 0.5) / numLines;
                const x = magnetStartX + (magnetEndX - magnetStartX) * t;
                const intensity = fieldStrength / 10;
                const alpha = 0.15 + Math.sin(animationTime * 0.003 + i * 0.5) * 0.05;
                
                // Curved field lines converging toward pole tip
                ctx.strokeStyle = `rgba(150, 180, 220, ${alpha})`;
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                
                const curveAmount = (x - tipX) * 0.4 * intensity;
                ctx.moveTo(x, startY);
                ctx.bezierCurveTo(
                    x + curveAmount * 0.3, startY + (endY - startY) * 0.3,
                    x + curveAmount * 0.5, startY + (endY - startY) * 0.7,
                    x, endY
                );
                ctx.stroke();
                
                // Arrow heads
                const arrowY = (startY + endY) / 2;
                const arrowX = x + curveAmount * 0.4;
                ctx.beginPath();
                ctx.moveTo(arrowX - 3, arrowY - 5);
                ctx.lineTo(arrowX, arrowY);
                ctx.lineTo(arrowX + 3, arrowY - 5);
                ctx.stroke();
            }
            
            // Field gradient indicator
            const gradWidth = 60;
            const gradX = magnetEndX + 15;
            const gradTop = magnetTopY + 40;
            const gradBottom = magnetBottomY - 10;
            const gradHeight = gradBottom - gradTop;
            
            const fieldGrad = ctx.createLinearGradient(0, gradTop, 0, gradBottom);
            fieldGrad.addColorStop(0, 'rgba(79, 209, 255, 0.4)');
            fieldGrad.addColorStop(0.5, 'rgba(79, 209, 255, 0.15)');
            fieldGrad.addColorStop(1, 'rgba(79, 209, 255, 0.05)');
            
            ctx.fillStyle = fieldGrad;
            ctx.beginPath();
            ctx.moveTo(gradX, gradTop);
            ctx.lineTo(gradX + 8, gradTop);
            ctx.lineTo(gradX + 4, gradBottom);
            ctx.lineTo(gradX, gradBottom);
            ctx.closePath();
            ctx.fill();
            
            ctx.fillStyle = '#5a6a8a';
            ctx.font = '9px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('|B| max', gradX + 12, gradTop + 10);
            ctx.fillText('|B| min', gradX + 12, gradBottom - 2);
        }
        
        function drawDetector() {
            const detectorWidth = 20;
            const screenHeight = detectorHeight * 0.95;
            const baseX = detectorX - detectorWidth / 2;
            const baseY = centerY - screenHeight / 2;
            
            // Shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.roundRect(baseX + 4, baseY + 4, detectorWidth, screenHeight, 6);
            ctx.fill();
            
            // Main body
            const detGrad = ctx.createLinearGradient(baseX, 0, baseX + detectorWidth, 0);
            detGrad.addColorStop(0, '#3d4a5c');
            detGrad.addColorStop(0.5, '#5a6b80');
            detGrad.addColorStop(1, '#2a3444');
            ctx.fillStyle = detGrad;
            ctx.beginPath();
            ctx.roundRect(baseX, baseY, detectorWidth, screenHeight, 6);
            ctx.fill();
            
            // Glass/detection surface
            ctx.fillStyle = 'rgba(10, 20, 40, 0.9)';
            ctx.fillRect(baseX + 4, baseY + 8, detectorWidth - 8, screenHeight - 16);
            
            // REMOVED: Expected spots glow based on mj values (oval legends)
            // The oval glows that were previously drawn here have been removed
            
            // Frame
            ctx.strokeStyle = 'rgba(100, 140, 200, 0.3)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(baseX, baseY, detectorWidth, screenHeight, 6);
            ctx.stroke();
            
            // Label
            ctx.fillStyle = '#8898b8';
            ctx.font = '600 11px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Screen', detectorX, baseY + screenHeight + 22);
        }
        
        function drawDetectorWindow() {
            const windowTop = centerY - detectorWindowHeight / 2;
            const windowLeft = detectorWindowX;
            
            // Window shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.beginPath();
            ctx.roundRect(windowLeft + 5, windowTop + 5, detectorWindowWidth, detectorWindowHeight, 12);
            ctx.fill();
            
            // Main window background
            const windowGrad = ctx.createLinearGradient(windowLeft, windowTop, windowLeft + detectorWindowWidth, windowTop);
            windowGrad.addColorStop(0, 'rgba(15, 25, 45, 0.95)');
            windowGrad.addColorStop(1, 'rgba(20, 30, 50, 0.95)');
            ctx.fillStyle = windowGrad;
            ctx.beginPath();
            ctx.roundRect(windowLeft, windowTop, detectorWindowWidth, detectorWindowHeight, 12);
            ctx.fill();
            
            // Inner detection area
            ctx.fillStyle = 'rgba(5, 10, 20, 0.8)';
            ctx.beginPath();
            ctx.roundRect(windowLeft + 10, windowTop + 35, detectorWindowWidth - 20, detectorWindowHeight - 70, 6);
            ctx.fill();
            
            // Center line
            ctx.strokeStyle = 'rgba(100, 140, 200, 0.15)';
            ctx.setLineDash([4, 6]);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(windowLeft + 15, centerY);
            ctx.lineTo(windowLeft + detectorWindowWidth - 15, centerY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Detection points
            const windowCenterX = windowLeft + detectorWindowWidth / 2;
            for (const point of detectionPoints) {
                let color;
                if (point.isClassical) {
                    color = 'rgba(255, 179, 71, 0.7)';
                } else {
                    color = getColorRgbaForMj(point.mj, 0.75);
                }
                
                // Point glow
                const glowSize = 6;
                const glow = ctx.createRadialGradient(
                    windowCenterX + point.x, windowTop + point.y, 0,
                    windowCenterX + point.x, windowTop + point.y, glowSize
                );
                glow.addColorStop(0, color);
                glow.addColorStop(1, 'transparent');
                ctx.fillStyle = glow;
                ctx.beginPath();
                ctx.arc(windowCenterX + point.x, windowTop + point.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                
                // Point core
                ctx.beginPath();
                ctx.arc(windowCenterX + point.x, windowTop + point.y, 2.5, 0, Math.PI * 2);
                ctx.fillStyle = color;
                ctx.fill();
            }
            
            // Border
            ctx.strokeStyle = 'rgba(100, 140, 200, 0.25)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.roundRect(windowLeft, windowTop, detectorWindowWidth, detectorWindowHeight, 12);
            ctx.stroke();
            
            // Labels for mj values on the side
            const mjValues = getMjValues();
            const maxDeflection = getDeflectionPerMj(); // pixels per unit mj, matches particle physics
            ctx.font = '9px monospace';
            ctx.textAlign = 'left';
            
            if (!classicalMode && totalSpin > 0) {
                mjValues.forEach(mj => {
                    const yOffset = mj * maxDeflection;
                    const labelY = centerY + yOffset;
                    if (labelY > windowTop + 40 && labelY < windowTop + detectorWindowHeight - 40) {
                        // Use single light green color for all mj labels
                        ctx.fillStyle = MJ_LABEL_COLOR;
                        ctx.fillText(`m‚±º=${formatMj(mj)}`, windowLeft + 15, labelY + 3);
                    }
                });
            }
            
            // Title
            ctx.fillStyle = classicalMode ? COLORS.classical : COLORS.quantum;
            ctx.font = '600 12px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.textAlign = 'center';
            const modeLabel = classicalMode ? 'Classical Prediction' : `Quantum Result (${2 * totalSpin + 1} beams)`;
            ctx.fillText(modeLabel, windowLeft + detectorWindowWidth / 2, windowTop + 20);
            
            // Connection line to detector
            ctx.strokeStyle = 'rgba(100, 140, 200, 0.2)';
            ctx.setLineDash([6, 8]);
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(detectorX + 15, centerY);
            ctx.lineTo(windowLeft, centerY);
            ctx.stroke();
            ctx.setLineDash([]);
        }
        
        function drawBeamPath() {
            // NOTE: These dashed guide lines use smooth Bezier curves for visual appeal.
            // The actual physical trajectory is: straight before magnet, parabolic inside
            // magnet, straight at angle after magnet. The real particle paths (Atom.update)
            // are physically correct; these guides are purely schematic.
            ctx.setLineDash([6, 8]);
            ctx.lineWidth = 1.5;
            
            // Initial beam path
            ctx.strokeStyle = 'rgba(157, 255, 107, 0.25)';
            ctx.beginPath();
            ctx.moveTo(sourceX + 60, centerY);
            ctx.lineTo(magnetStartX, centerY);
            ctx.stroke();
            
            const maxDeflection = getDeflectionPerMj(); // pixels per unit mj, matches particle physics
            const magnetCenterX = (magnetStartX + magnetEndX) / 2;
            
            if (classicalMode) {
                // Classical spread ‚Äî mj ranges from -totalSpin to +totalSpin
                for (let i = -6; i <= 6; i++) {
                    const fraction = i / 6;
                    const deflection = totalSpin * maxDeflection * fraction;
                    const alpha = 0.08 + 0.08 * (1 - Math.abs(fraction));
                    ctx.strokeStyle = `rgba(255, 179, 71, ${alpha})`;
                    ctx.beginPath();
                    ctx.moveTo(magnetCenterX, centerY);
                    ctx.bezierCurveTo(
                        magnetEndX - 30, centerY + deflection * 0.3,
                        magnetEndX + 30, centerY + deflection * 0.7,
                        detectorX, centerY + deflection
                    );
                    ctx.stroke();
                }
            } else {
                // Quantum discrete paths for each mj - using matching colors
                const mjValues = getMjValues();
                mjValues.forEach(mj => {
                    const deflection = mj * maxDeflection;
                    ctx.strokeStyle = getColorRgbaForMj(mj, 0.25);
                    ctx.beginPath();
                    ctx.moveTo(magnetCenterX, centerY);
                    ctx.bezierCurveTo(
                        magnetEndX - 30, centerY + deflection * 0.3,
                        magnetEndX + 30, centerY + deflection * 0.7,
                        detectorX, centerY + deflection
                    );
                    ctx.stroke();
                });
            }
            
            ctx.setLineDash([]);
        }
        
        function drawVacuumChamber() {
            // Subtle vacuum chamber outline
            const chamberLeft = sourceX - 60;
            const chamberRight = detectorX + 40;
            const chamberTop = magnetTopY - height * 0.2;
            const chamberBottom = magnetBottomY + height * 0.2;
            
            ctx.strokeStyle = 'rgba(80, 120, 180, 0.1)';
            ctx.lineWidth = 2;
            ctx.setLineDash([12, 8]);
            ctx.beginPath();
            ctx.roundRect(chamberLeft, chamberTop, chamberRight - chamberLeft, chamberBottom - chamberTop, 20);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Vacuum label
            ctx.fillStyle = 'rgba(80, 120, 180, 0.3)';
            ctx.font = '9px monospace';
            ctx.textAlign = 'left';
            ctx.fillText('VACUUM CHAMBER  P < 10‚Åª‚Å∂ torr', chamberLeft + 15, chamberTop + 20);
        }
        
        function emitAtom() {
            atoms.push(new Atom());
        }
        
        function updateStats() {
            document.getElementById('totalAtoms').textContent = totalCount;
        }
        
        function updateBeamLegend() {
            const container = document.getElementById('beamLegendItems');
            const mjValues = getMjValues();
            const numBeams = mjValues.length;
            
            document.getElementById('beamCountDisplay').textContent = numBeams;
            
            let html = '';
            
            if (classicalMode) {
                html = `
                    <div class="beam-legend-item">
                        <div class="beam-legend-color" style="background: ${COLORS.classical}"></div>
                        <span class="beam-legend-label">Continuous distribution</span>
                        <span class="beam-legend-count">${totalCount}</span>
                    </div>
                `;
            } else {
                // Sort mj values from highest to lowest (top to bottom on screen)
                const sortedMj = [...mjValues].sort((a, b) => b - a);
                sortedMj.forEach(mj => {
                    const color = getColorForMj(mj);
                    const count = spinCounts[mj] || 0;
                    html += `
                        <div class="beam-legend-item">
                            <div class="beam-legend-color" style="background: ${color}"></div>
                            <span class="beam-legend-label">m‚±º = ${formatMj(mj)}</span>
                            <span class="beam-legend-count">${count}</span>
                        </div>
                    `;
                });
            }
            
            container.innerHTML = html;
        }
        
        function updateModeUI() {
            const indicator = document.getElementById('modeIndicator');
            const toggleBtn = document.getElementById('classicalToggle');
            const numBeams = 2 * totalSpin + 1;
            
            if (classicalMode) {
                indicator.className = 'mode-indicator classical';
                indicator.textContent = '‚öô Classical Mode ‚Äî Continuous Distribution';
                toggleBtn.textContent = 'Switch to Quantum Result';
                toggleBtn.classList.add('active');
            } else {
                indicator.className = 'mode-indicator quantum';
                indicator.textContent = `‚öõ Quantum Mode ‚Äî ${numBeams} Discrete State${numBeams > 1 ? 's' : ''}`;
                toggleBtn.textContent = 'Switch to Classical Prediction';
                toggleBtn.classList.remove('active');
            }
            
            updateBeamLegend();
        }
        
        function updateSpinUI() {
            const spinSelect = document.getElementById('spinSelect');
            const spinValue = document.getElementById('spinValue');
            
            const val = parseFloat(spinSelect.value);
            if (val === 0.5) spinValue.textContent = '1/2';
            else if (val === 1.5) spinValue.textContent = '3/2';
            else spinValue.textContent = val;
        }
        
        function animate(currentTime) {
            const dt = lastFrameTime > 0 ? Math.min(currentTime - lastFrameTime, 50) : 16.67;
            lastFrameTime = currentTime;
            animationTime = currentTime;
            const emitInterval = 1000 / emissionRate;
            if (currentTime - lastEmitTime > emitInterval) {
                emitAtom();
                lastEmitTime = currentTime;
            }
            
            drawBackground();
            drawVacuumChamber();
            drawBeamPath();
            drawSource();
            drawMagnet();
            drawDetector();
            drawDetectorWindow();
            
            atoms = atoms.filter(atom => {
                const alive = atom.update(dt);
                if (alive || !atom.detected) {
                    atom.draw();
                }
                return alive;
            });
            
            updateStats();
            updateBeamLegend();
            requestAnimationFrame(animate);
        }
        
        function reset() {
            atoms = [];
            totalCount = 0;
            detectionPoints = [];
            initSpinCounts();
            updateBeamLegend();
        }
        
        // Event listeners
        document.getElementById('fieldStrength').addEventListener('input', (e) => {
            fieldStrength = parseInt(e.target.value);
            document.getElementById('fieldValue').textContent = fieldStrength;
        });
        
        document.getElementById('emissionRate').addEventListener('input', (e) => {
            emissionRate = parseInt(e.target.value);
            document.getElementById('emissionValue').textContent = emissionRate;
        });
        
        document.getElementById('spinSelect').addEventListener('change', (e) => {
            totalSpin = parseFloat(e.target.value);
            updateSpinUI();
            updateModeUI();
            reset();
        });
        
        document.getElementById('reset').addEventListener('click', reset);
        
        document.getElementById('classicalToggle').addEventListener('click', () => {
            classicalMode = !classicalMode;
            updateModeUI();
            reset();
        });
        
        window.addEventListener('resize', resize);
        
        // Initialize
        resize();
        initSpinCounts();
        updateSpinUI();
        updateModeUI();
        requestAnimationFrame(animate);

        // --- NARRATION / VOICEOVER ENGINE ---
        const narrationSteps = [
            {
                text: `Welcome to the <span class="hl">Stern-Gerlach experiment</span> ‚Äî the first direct proof that angular momentum is quantized. In 1922, Otto Stern and Walther Gerlach sent silver atoms through an inhomogeneous magnetic field and discovered something classical physics could not explain.`,
                speech: `Welcome to the Stern-Gerlach experiment ‚Äî the first direct proof that angular momentum is quantized. In 1922, Otto Stern and Walther Gerlach sent silver atoms through an inhomogeneous magnetic field and discovered something classical physics could not explain.`,
                duration: 14000
            },
            {
                text: `On the left, a <span class="hl-green">source oven</span> heats atoms until they evaporate and stream out as a beam. Each atom carries an intrinsic angular momentum called <span class="hl">spin</span>, with an associated magnetic moment ‚Äî like a tiny bar magnet.`,
                speech: `On the left, a source oven heats atoms until they evaporate and stream out as a beam. Each atom carries an intrinsic angular momentum called spin, with an associated magnetic moment ‚Äî like a tiny bar magnet.`,
                duration: 12000
            },
            {
                text: `The beam enters a <span class="hl">non-uniform magnetic field</span> between shaped pole pieces. The field is stronger near the top, weaker near the bottom. This gradient exerts a force on each magnetic moment: the force is <span class="hl">F = ‚àíg<sub>J</sub> m<sub>J</sub> Œº<sub>B</sub> (‚àÇB/‚àÇz)</span>.`,
                speech: `The beam enters a non-uniform magnetic field between shaped pole pieces. The field is stronger near the top, weaker near the bottom. This gradient exerts a force on each magnetic moment. The force equals minus g J, times m J, times the Bohr magneton, times the field gradient.`,
                duration: 14000
            },
            {
                text: `<span class="hl-orange">Classical expectation:</span> since the magnetic moment can point in any direction, atoms should deflect by a <em>continuous range</em> of angles ‚Äî producing a smeared-out band on the detector. Click <span class="hl">"Switch to Classical Prediction"</span> to see this.`,
                speech: `Classical expectation: since the magnetic moment can point in any direction, atoms should deflect by a continuous range of angles ‚Äî producing a smeared-out band on the detector. Click "Switch to Classical Prediction" to see this.`,
                duration: 12000
            },
            {
                text: `<span class="hl">Quantum result:</span> instead of a continuous band, the beam splits into exactly <span class="hl">2j + 1</span> discrete spots. For spin one-half particles, that's just <span class="hl-pink">two beams</span> ‚Äî spin up and spin down. The component m<sub>J</sub> can only take values ‚àíj, ‚àíj+1, ‚Ä¶ , +j.`,
                speech: `Quantum result: instead of a continuous band, the beam splits into exactly 2 j plus 1 discrete spots. For spin one-half particles, that's just two beams ‚Äî spin up and spin down. The component m J can only take values minus j, minus j plus 1, all the way up to plus j.`,
                duration: 14000
            },
            {
                text: `Watch the <span class="hl-green">green atoms</span> in the beam ‚Äî before entering the magnet, each atom is in a <span class="hl">superposition</span> of all allowed m<sub>J</sub> states. The moment it enters the field, the measurement collapses it into a single m<sub>J</sub> value, and the atom deflects accordingly.`,
                speech: `Watch the green atoms in the beam ‚Äî before entering the magnet, each atom is in a superposition of all allowed m J states. The moment it enters the field, the measurement collapses it into a single m J value, and the atom deflects accordingly.`,
                duration: 13000
            },
            {
                text: `Try changing the <span class="hl">spin quantum number j</span> in the controls. For j = 1, you get 3 beams. For j = 3/2, you get 4. The number of discrete spots is direct evidence of <span class="hl">space quantization</span> ‚Äî angular momentum can only take specific orientations.`,
                speech: `Try changing the spin quantum number j in the controls. For j equals 1, you get 3 beams. For j equals 3 halves, you get 4. The number of discrete spots is direct evidence of space quantization ‚Äî angular momentum can only take specific orientations.`,
                duration: 13000
            },
            {
                text: `Adjust the <span class="hl">magnetic field gradient</span> slider to see how stronger fields produce larger deflections. The detector window on the right shows the accumulating pattern ‚Äî the histogram that Stern and Gerlach saw on their glass plate in 1922.`,
                speech: `Adjust the magnetic field gradient slider to see how stronger fields produce larger deflections. The detector window on the right shows the accumulating pattern ‚Äî the histogram that Stern and Gerlach saw on their glass plate in 1922.`,
                duration: 12000
            }
        ];

        let narration = {
            currentStep: 0,
            isPlaying: false,
            timer: null,
            utterance: null,
            speechSupported: 'speechSynthesis' in window
        };

        function initNarration() {
            const dotsContainer = document.getElementById('narr-dots');
            narrationSteps.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'narr-dot' + (i === 0 ? ' active' : '');
                dot.onclick = () => jumpToStep(i);
                dotsContainer.appendChild(dot);
            });

            document.getElementById('narr-play').onclick = playNarration;
            document.getElementById('narr-pause').onclick = pauseNarration;
            document.getElementById('narr-back').onclick = goBackOneStep;

            showStep(0);
        }

        function showStep(index) {
            narration.currentStep = index;
            const step = narrationSteps[index];
            document.getElementById('narration-text').innerHTML = step.text;

            const dots = document.querySelectorAll('.narr-dot');
            dots.forEach((dot, i) => {
                dot.className = 'narr-dot';
                if (i < index) dot.classList.add('completed');
                if (i === index) dot.classList.add('active');
            });

            const progress = (index / (narrationSteps.length - 1)) * 100;
            document.getElementById('narr-progress-bar').style.width = progress + '%';
        }

        function finishNarration() {
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');

            if (narration.speechSupported) {
                window.speechSynthesis.cancel();
            }
            if (narration.timer) {
                clearTimeout(narration.timer);
                narration.timer = null;
            }

            // Reset to first slide after brief pause
            narration.timer = setTimeout(() => {
                narration.currentStep = 0;
                showStep(0);
                document.getElementById('narr-progress-bar').style.width = '0%';
                narration.timer = null;
            }, 1200);
        }

        function speakStep(index) {
            if (!narration.speechSupported) return;

            window.speechSynthesis.cancel();

            const text = narrationSteps[index].speech;
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 0.92;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Select Samantha voice (priority), fallback to any English voice
            const voices = window.speechSynthesis.getVoices();
            const samantha = voices.find(v => v.name.includes('Samantha'));
            const fallback = voices.find(v => v.lang.startsWith('en') && (v.name.includes('Google') || v.name.includes('Natural') || v.name.includes('Daniel'))) || voices.find(v => v.lang.startsWith('en'));
            utterance.voice = samantha || fallback || null;

            utterance.onend = () => {
                if (!narration.isPlaying) return;

                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) {
                    finishNarration();
                } else {
                    narration.timer = setTimeout(() => {
                        if (narration.isPlaying) {
                            showStep(nextIndex);
                            speakStep(nextIndex);
                        }
                    }, 800);
                }
            };

            narration.utterance = utterance;
            window.speechSynthesis.speak(utterance);
        }

        function playNarration() {
            if (narration.isPlaying) return;
            narration.isPlaying = true;
            document.getElementById('narr-play').classList.add('active');
            document.getElementById('narr-pause').classList.remove('active');

            if (narration.timer) {
                clearTimeout(narration.timer);
                narration.timer = null;
            }

            if (narration.speechSupported) {
                if (window.speechSynthesis.getVoices().length === 0) {
                    window.speechSynthesis.onvoiceschanged = () => {
                        speakStep(narration.currentStep);
                    };
                } else {
                    speakStep(narration.currentStep);
                }
            } else {
                advanceByTimer();
            }
        }

        function advanceByTimer() {
            if (!narration.isPlaying) return;
            const step = narrationSteps[narration.currentStep];
            narration.timer = setTimeout(() => {
                if (!narration.isPlaying) return;

                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) {
                    finishNarration();
                } else {
                    showStep(nextIndex);
                    advanceByTimer();
                }
            }, step.duration);
        }

        function pauseNarration() {
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');
            document.getElementById('narr-pause').classList.add('active');

            if (narration.speechSupported) {
                window.speechSynthesis.cancel();
            }
            if (narration.timer) {
                clearTimeout(narration.timer);
                narration.timer = null;
            }
        }

        function goBackOneStep() {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');

            const prevStep = Math.max(0, narration.currentStep - 1);
            narration.currentStep = prevStep;
            showStep(prevStep);

            if (wasPlaying) {
                playNarration();
            }
        }

        function jumpToStep(index) {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');
            narration.currentStep = index;
            showStep(index);
            if (wasPlaying) {
                playNarration();
            }
        }

        initNarration();
    </script>
</body>
</html>