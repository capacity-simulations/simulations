<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum-Classical Harmonic Oscillator Comparison</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: #e2e8f0;
            overflow: hidden;
            height: 100vh;
        }

        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }

        .main-area {
            flex: 1;
            display: flex;
            min-width: 0;
        }

        .visualization-panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            min-width: 0;
        }

        .divider {
            width: 2px;
            background: linear-gradient(to bottom, transparent, rgba(148, 163, 184, 0.3), transparent);
        }

        .panel-title {
            text-align: center;
            font-size: 16px;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 10px;
            padding: 8px;
            background: rgba(30, 41, 59, 0.6);
            border-radius: 8px;
        }

        .classical-title {
            border-left: 3px solid #3b82f6;
        }

        .quantum-title {
            border-left: 3px solid #8b5cf6;
        }

        .canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
            min-height: 0;
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            background: rgba(15, 23, 42, 0.5);
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            overflow: hidden;
        }

        .canvas-wrapper canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .canvas-label {
            position: absolute;
            top: 8px;
            left: 8px;
            font-size: 11px;
            color: #94a3b8;
            background: rgba(15, 23, 42, 0.8);
            padding: 4px 8px;
            border-radius: 4px;
        }

        /* Sidebar */
        .sidebar {
            width: 280px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(12px);
            border-left: 1px solid rgba(148, 163, 184, 0.1);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
        }

        .sidebar-header {
            padding: 15px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .sidebar-header h2 {
            font-size: 14px;
            font-weight: 600;
            color: #f1f5f9;
        }

        .sidebar-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .control-section {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            padding: 12px;
        }

        .section-title {
            font-size: 11px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
        }

        .playback-controls {
            display: flex;
            gap: 8px;
        }

        .btn {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-secondary {
            background: rgba(148, 163, 184, 0.2);
            color: #e2e8f0;
        }

        .btn-secondary:hover {
            background: rgba(148, 163, 184, 0.3);
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .slider-label-text {
            font-size: 12px;
            color: #cbd5e1;
        }

        .slider-value {
            font-size: 11px;
            color: #60a5fa;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }

        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 3px;
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.1);
        }

        .readout-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
        }

        .readout-item {
            background: rgba(15, 23, 42, 0.5);
            padding: 8px;
            border-radius: 6px;
        }

        .readout-label {
            font-size: 10px;
            color: #64748b;
            margin-bottom: 2px;
        }

        .readout-value {
            font-size: 13px;
            font-weight: 600;
            color: #f1f5f9;
            font-variant-numeric: tabular-nums;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 6px;
            font-size: 11px;
        }

        .legend-swatch {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }

        .swatch-allowed {
            background: linear-gradient(135deg, #06b6d4, #3b82f6);
        }

        .swatch-forbidden {
            background: linear-gradient(135deg, #f97316, #ef4444);
        }

        .swatch-potential {
            background: #94a3b8;
        }

        .swatch-energy {
            background: #fbbf24;
        }

        .swatch-classical {
            background: #3b82f6;
        }

        .swatch-quantum {
            background: #8b5cf6;
        }

        /* Mobile toggle */
        .sidebar-toggle {
            display: none;
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1001;
            width: 44px;
            height: 44px;
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 8px;
            color: #e2e8f0;
            font-size: 20px;
            cursor: pointer;
        }

        @media (max-width: 900px) {
            .sidebar {
                position: fixed;
                right: -280px;
                top: 0;
                height: 100vh;
                z-index: 1000;
                transition: right 0.3s ease;
            }

            .sidebar.open {
                right: 0;
            }

            .sidebar-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
        }

        @media (max-width: 600px) {
            .main-area {
                flex-direction: column;
            }

            .divider {
                width: 100%;
                height: 2px;
            }

            .visualization-panel {
                padding: 10px;
            }

            .panel-title {
                font-size: 14px;
                padding: 6px;
            }
        }

        /* NARRATION PANEL */
        .narration-panel {
            background: rgba(30, 41, 59, 0.7);
            border: 1.5px solid rgba(59, 130, 246, 0.25);
            border-radius: 8px;
            overflow: visible;
            flex-shrink: 0;
            min-height: 90px;
            box-shadow: 0 2px 10px rgba(59, 130, 246, 0.06);
        }
        .narration-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 9px 12px;
            background: rgba(59, 130, 246, 0.08);
            border-bottom: 1px solid rgba(59, 130, 246, 0.12);
            border-radius: 8px 8px 0 0;
        }
        .narration-header-left {
            display: flex;
            align-items: center;
            gap: 7px;
        }
        .narr-icon { font-size: 12px; }
        .narration-header-left span {
            font-size: 10px;
            font-weight: 600;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }
        .narration-controls {
            display: flex;
            gap: 3px;
            align-items: center;
        }
        .narr-btn {
            width: 26px;
            height: 26px;
            min-width: 26px;
            border-radius: 50%;
            border: 1px solid rgba(148, 163, 184, 0.2);
            background: rgba(15, 23, 42, 0.6);
            color: #94a3b8;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            transition: all 0.2s;
            padding: 0;
            flex: none;
        }
        .narr-btn:hover {
            border-color: rgba(59, 130, 246, 0.5);
            color: #60a5fa;
            background: rgba(59, 130, 246, 0.1);
            transform: none;
        }
        .narr-btn.active {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(59, 130, 246, 0.4);
            color: #60a5fa;
        }
        .narration-progress {
            height: 2px;
            background: rgba(148, 163, 184, 0.08);
        }
        .narration-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #60a5fa);
            width: 0%;
            transition: width 0.3s linear;
        }
        .narration-body {
            padding: 10px 12px;
            min-height: 48px;
            display: flex;
            align-items: center;
        }
        .narration-text {
            font-size: 11.5px;
            color: #cbd5e1;
            line-height: 1.55;
            margin: 0;
        }
        .narration-text .hl {
            color: #60a5fa;
            font-weight: 600;
        }
        .narration-text .hl-purple {
            color: #a78bfa;
            font-weight: 600;
        }
        .narration-text .hl-yellow {
            color: #fbbf24;
            font-weight: 600;
        }
        .narration-text .hl-red {
            color: #ef4444;
            font-weight: 600;
        }
        .narration-text .hl-cyan {
            color: #22d3ee;
            font-weight: 600;
        }
        .narration-text .hl-green {
            color: #4ade80;
            font-weight: 600;
        }
        .narr-step-dots {
            display: flex;
            justify-content: center;
            gap: 5px;
            padding: 5px 12px 8px;
        }
        .narr-dot {
            width: 5px;
            height: 5px;
            border-radius: 50%;
            background: rgba(148, 163, 184, 0.2);
            transition: all 0.3s;
            cursor: pointer;
        }
        .narr-dot.active {
            background: #60a5fa;
            box-shadow: 0 0 5px rgba(96, 165, 250, 0.5);
        }
        .narr-dot.completed {
            background: rgba(148, 163, 184, 0.4);
        }
    </style>
</head>
<body>
    <button class="sidebar-toggle" id="sidebarToggle">‚ò∞</button>
    
    <div class="container">
        <div class="main-area">
            <!-- Classical Side -->
            <div class="visualization-panel">
                <div class="panel-title classical-title">Classical Harmonic Oscillator</div>
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <span class="canvas-label">Potential Energy V(x) = ¬Ωkx¬≤</span>
                        <canvas id="classicalPotential"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <span class="canvas-label">Mass-Spring System</span>
                        <canvas id="classicalMass"></canvas>
                    </div>
                </div>
            </div>

            <div class="divider"></div>

            <!-- Quantum Side -->
            <div class="visualization-panel">
                <div class="panel-title quantum-title">Quantum Coherent State</div>
                <div class="canvas-container">
                    <div class="canvas-wrapper">
                        <span class="canvas-label">Potential V(x) with Classically Forbidden Regions</span>
                        <canvas id="quantumPotential"></canvas>
                    </div>
                    <div class="canvas-wrapper">
                        <span class="canvas-label">Probability Density |œà(x,t)|¬≤</span>
                        <canvas id="quantumWave"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Sidebar -->
        <div class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <h2>Control Panel</h2>
            </div>
            <div class="sidebar-content">
                <!-- NARRATION PANEL -->
                <div class="narration-panel" id="narration-panel">
                    <div class="narration-header">
                        <div class="narration-header-left">
                            <div class="narr-icon">üîä</div>
                            <span>Simulation Context</span>
                        </div>
                        <div class="narration-controls">
                            <button class="narr-btn" id="narr-back" title="Previous step">‚è™</button>
                            <button class="narr-btn" id="narr-play" title="Play">‚ñ∂</button>
                            <button class="narr-btn" id="narr-pause" title="Pause">‚è∏</button>
                        </div>
                    </div>
                    <div class="narration-progress">
                        <div class="narration-progress-bar" id="narr-progress-bar"></div>
                    </div>
                    <div class="narration-body">
                        <p class="narration-text" id="narration-text"></p>
                    </div>
                    <div class="narr-step-dots" id="narr-dots"></div>
                </div>

                <!-- Playback Controls -->
                <div class="control-section">
                    <div class="section-title">Playback</div>
                    <div class="playback-controls">
                        <button class="btn btn-primary" id="playPauseBtn">‚è∏ Pause</button>
                        <button class="btn btn-secondary" id="resetBtn">‚Ü∫ Reset</button>
                    </div>
                </div>

                <!-- Parameters -->
                <div class="control-section">
                    <div class="section-title">Parameters</div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="slider-label-text">Mass (m)</span>
                            <span class="slider-value" id="mSliderValue">1.00 kg</span>
                        </div>
                        <input type="range" class="slider" id="mSlider" min="0.25" max="4" step="0.05" value="1">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="slider-label-text">Stiffness (k)</span>
                            <span class="slider-value" id="kSliderValue">1.00 N/m</span>
                        </div>
                        <input type="range" class="slider" id="kSlider" min="0.25" max="4" step="0.05" value="1">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="slider-label-text">Energy (E)</span>
                            <span class="slider-value" id="energyValue">2.00 J</span>
                        </div>
                        <input type="range" class="slider" id="energySlider" min="0.5" max="5" step="0.1" value="2">
                    </div>
                </div>

                <!-- Live Readouts -->
                <div class="control-section">
                    <div class="section-title">Live Readouts</div>
                    <div class="readout-grid">
                        <div class="readout-item">
                            <div class="readout-label">Classical x</div>
                            <div class="readout-value" id="classicalX">0.00</div>
                        </div>
                        <div class="readout-item">
                            <div class="readout-label">Quantum x‚ÇÄ</div>
                            <div class="readout-value" id="quantumX">0.00</div>
                        </div>
                        <div class="readout-item">
                            <div class="readout-label">œâ (rad/s)</div>
                            <div class="readout-value" id="omegaValue">1.00</div>
                        </div>
                        <div class="readout-item">
                            <div class="readout-label">Amplitude A</div>
                            <div class="readout-value" id="amplitudeValue">2.00</div>
                        </div>
                        <div class="readout-item" style="grid-column: span 2;">
                            <div class="readout-label">Turning Points</div>
                            <div class="readout-value" id="turningPoints">¬±2.00</div>
                        </div>
                    </div>
                </div>

                <!-- Legend -->
                <div class="control-section">
                    <div class="section-title">Legend</div>
                    <div class="legend-item">
                        <div class="legend-swatch swatch-allowed"></div>
                        <span>Allowed region</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch swatch-forbidden"></div>
                        <span>Forbidden (tunneling)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch swatch-potential"></div>
                        <span>Potential V(x)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch swatch-energy"></div>
                        <span>Energy level E</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch swatch-classical"></div>
                        <span>Classical mass</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-swatch swatch-quantum"></div>
                        <span>Quantum wavepacket</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        /*
         * PHYSICS MODEL DOCUMENTATION
         * ===========================
         * This simulation uses NATURAL UNITS where ‚Ñè = 1.
         *
         * In these units:
         *   - Mass m and stiffness k are dimensionless parameters
         *   - Energy E is in units of ‚Ñèœâ (where œâ = ‚àö(k/m))
         *   - Time t is in units of 1/œâ
         *   - Position x is in units of ‚àö(‚Ñè/mœâ)
         *
         * CLASSICAL HARMONIC OSCILLATOR:
         *   x(t) = A cos(œât)           Position
         *   v(t) = -Aœâ sin(œât)         Velocity
         *   œâ = ‚àö(k/m)                 Angular frequency
         *   A = ‚àö(2E/k)                Amplitude (classical turning points at ¬±A)
         *   E = ¬ΩkA¬≤ = ¬Ωmœâ¬≤A¬≤         Total energy (conserved)
         *
         * QUANTUM COHERENT STATE:
         *   |œà(x,t)|¬≤ = ‚àö(mœâ/œÄ‚Ñè) exp(-mœâ(x-x‚ÇÄ(t))¬≤/‚Ñè)
         *   With ‚Ñè=1: |œà(x,t)|¬≤ = ‚àö(mœâ/œÄ) exp(-mœâ(x-x‚ÇÄ(t))¬≤)
         *   x‚ÇÄ(t) = A cos(œât)          Center follows classical trajectory
         *   œÉ = ‚àö(‚Ñè/2mœâ) = 1/‚àö(2mœâ)   Width (constant in time, with ‚Ñè=1)
         *
         * The quantum wavepacket maintains its shape while oscillating,
         * demonstrating Ehrenfest's theorem: ‚ü®x‚ü© follows classical motion.
         *
         * Note: UI displays "kg", "N/m", "J" for familiarity, but these are
         * actually dimensionless parameters in natural units.
         */

        // Physics parameters (in natural units, ‚Ñè = 1)
        const HBAR = 1;  // Reduced Planck constant (natural units)
        let m = 1.0;     // Mass (dimensionless)
        let k = 1.0;     // Stiffness (dimensionless)
        let energy = 2.0; // Energy in units of ‚Ñèœâ
        let time = 0;
        let isPlaying = true;
        let lastFrameTime = performance.now();
        const baseTimeStep = 0.02;  // Base time step for physics

        // Display range ‚Äî dynamically adapts so turning points always fit on screen
        let xMin = -5, xMax = 5;
        function updateDisplayRange() {
            const A = getAmplitude();
            // Ensure turning points ¬±A fit with 30% margin, minimum range [-5, 5]
            const halfRange = Math.max(5, A * 1.3);
            xMin = -halfRange;
            xMax = halfRange;
        }

        // Fixed y-axis scale for potential plots - this stays constant
        const potentialYMax = 6.0;  // Fixed maximum for y-axis
        const potentialYMin = 0;

        // Derived quantities
        function getOmega() {
            return Math.sqrt(k / m);  // omega = sqrt(k/m)
        }

        function getAmplitude() {
            return Math.sqrt(2 * energy / k);  // A = sqrt(2E/k)
        }

        function getSigma() {
            // œÉ = ‚àö(‚Ñè/2mœâ) - width of coherent state wavepacket
            // With ‚Ñè = 1 (natural units): œÉ = 1/‚àö(2mœâ)
            const omega = getOmega();
            return Math.sqrt(HBAR / (2 * m * omega));
        }

        // Canvas contexts
        let ctxCP, ctxCM, ctxQP, ctxQW;
        let canvasCP, canvasCM, canvasQP, canvasQW;

        // Initialize canvases
        function initCanvases() {
            canvasCP = document.getElementById('classicalPotential');
            canvasCM = document.getElementById('classicalMass');
            canvasQP = document.getElementById('quantumPotential');
            canvasQW = document.getElementById('quantumWave');

            ctxCP = canvasCP.getContext('2d');
            ctxCM = canvasCM.getContext('2d');
            ctxQP = canvasQP.getContext('2d');
            ctxQW = canvasQW.getContext('2d');

            resizeCanvases();
        }

        function resizeCanvases() {
            const canvases = [canvasCP, canvasCM, canvasQP, canvasQW];
            canvases.forEach(canvas => {
                const rect = canvas.parentElement.getBoundingClientRect();
                canvas.width = rect.width * window.devicePixelRatio;
                canvas.height = rect.height * window.devicePixelRatio;
                const ctx = canvas.getContext('2d');
                ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            });
        }

        // Coordinate transformations
        function xToCanvas(x, canvas) {
            const w = canvas.width / window.devicePixelRatio;
            const margin = 40;
            return margin + (x - xMin) / (xMax - xMin) * (w - 2 * margin);
        }

        function yToCanvas(y, yMin, yMax, canvas) {
            const h = canvas.height / window.devicePixelRatio;
            const margin = 30;
            return h - margin - (y - yMin) / (yMax - yMin) * (h - 2 * margin);
        }

        // Draw potential energy plot
        function drawPotential(ctx, canvas, isQuantum) {
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            const A = getAmplitude();
            // Use fixed y-axis scale so energy level position only changes with energy slider
            const yMax = potentialYMax;
            const yMin = potentialYMin;
            const margin = 30;
            const leftMargin = 40;
            const rightMargin = 40;

            // Clear
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, w, h);

            // Calculate energy level y position (only depends on energy, not k)
            const ey = yToCanvas(energy, yMin, yMax, canvas);

            // Draw forbidden region shading - based on where potential > energy
            // The turning points are at x = ¬±A where A = sqrt(2E/k)
            ctx.fillStyle = 'rgba(239, 68, 68, 0.15)';
            
            // Left forbidden region - fill from x=xMin to x=-A, from bottom to potential curve
            ctx.beginPath();
            ctx.moveTo(leftMargin, h - margin);  // Start at bottom-left of plot area
            
            // Go along the bottom to the turning point
            const leftTurnPx = xToCanvas(-A, canvas);
            ctx.lineTo(leftTurnPx, h - margin);
            
            // Go up to the energy level at turning point
            ctx.lineTo(leftTurnPx, ey);
            
            // Follow the potential curve back to the left edge
            for (let px = leftTurnPx; px >= leftMargin; px--) {
                const x = xMin + (px - leftMargin) / (w - leftMargin - rightMargin) * (xMax - xMin);
                const V = 0.5 * k * x * x;
                const y = yToCanvas(Math.min(V, yMax), yMin, yMax, canvas);
                ctx.lineTo(px, y);
            }
            
            ctx.closePath();
            ctx.fill();

            // Right forbidden region - fill from x=A to x=xMax, from bottom to potential curve
            ctx.beginPath();
            const rightTurnPx = xToCanvas(A, canvas);
            ctx.moveTo(rightTurnPx, h - margin);  // Start at bottom at turning point
            
            // Go along the bottom to the right edge
            ctx.lineTo(w - rightMargin, h - margin);
            
            // Go up along the potential curve
            for (let px = w - rightMargin; px >= rightTurnPx; px--) {
                const x = xMin + (px - leftMargin) / (w - leftMargin - rightMargin) * (xMax - xMin);
                const V = 0.5 * k * x * x;
                const y = yToCanvas(Math.min(V, yMax), yMin, yMax, canvas);
                ctx.lineTo(px, y);
            }
            
            // Go down to energy level at turning point
            ctx.lineTo(rightTurnPx, ey);
            
            ctx.closePath();
            ctx.fill();

            // Draw axes
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(leftMargin, h - margin);
            ctx.lineTo(w - rightMargin, h - margin);
            ctx.moveTo(w / 2, 20);
            ctx.lineTo(w / 2, h - margin);
            ctx.stroke();

            // Draw potential curve - shape changes with k
            ctx.strokeStyle = '#94a3b8';
            ctx.lineWidth = 2;
            ctx.beginPath();
            for (let px = leftMargin; px < w - rightMargin; px++) {
                const x = xMin + (px - leftMargin) / (w - leftMargin - rightMargin) * (xMax - xMin);
                const V = 0.5 * k * x * x;
                const y = yToCanvas(Math.min(V, yMax), yMin, yMax, canvas);
                if (px === leftMargin) ctx.moveTo(px, y);
                else ctx.lineTo(px, y);
            }
            ctx.stroke();

            // Draw energy level - position only changes with energy slider, not k
            ctx.strokeStyle = '#fbbf24';
            ctx.lineWidth = 2;
            ctx.setLineDash([8, 4]);
            ctx.beginPath();
            ctx.moveTo(leftMargin, ey);
            ctx.lineTo(w - rightMargin, ey);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw turning points - these move when either k or E changes
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            [-A, A].forEach(xTurn => {
                const px = xToCanvas(xTurn, canvas);
                ctx.beginPath();
                ctx.moveTo(px, 20);
                ctx.lineTo(px, h - margin);
                ctx.stroke();
            });
            ctx.setLineDash([]);

            // Labels
            ctx.fillStyle = '#94a3b8';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('x', w - 25, h - margin + 15);
            ctx.fillText('V(x)', w / 2 + 20, 25);
            ctx.fillText('-A', xToCanvas(-A, canvas), h - 15);
            ctx.fillText('+A', xToCanvas(A, canvas), h - 15);
            ctx.fillStyle = '#fbbf24';
            ctx.textAlign = 'right';
            // Energy displayed in natural units (‚Ñèœâ), positioned inside the right margin
            ctx.fillText('E=' + energy.toFixed(1) + ' ‚Ñèœâ', w - rightMargin - 5, ey - 8);
        }

        // Draw classical mass-spring system
        function drawClassicalMass(ctx, canvas) {
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            const A = getAmplitude();
            const omega = getOmega();
            const x = A * Math.cos(omega * time);

            // Clear
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, w, h);

            const centerY = h / 2;
            const wallX = 40;
            const massRadius = 20;
            const massX = xToCanvas(x, canvas);
            const eqX = xToCanvas(0, canvas);

            // Draw forbidden region shading (clamp to plot area so negative widths are avoided)
            ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            const leftTP = Math.max(40, xToCanvas(-A, canvas));
            const rightTP = Math.min(w - 40, xToCanvas(A, canvas));
            if (leftTP > 40) ctx.fillRect(40, 0, leftTP - 40, h);
            if (rightTP < w - 40) ctx.fillRect(rightTP, 0, w - 40 - rightTP, h);

            // Draw turning point markers (only if on-screen)
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            [-A, A].forEach(xTurn => {
                const px = xToCanvas(xTurn, canvas);
                if (px >= 40 && px <= w - 40) {
                    ctx.beginPath();
                    ctx.moveTo(px, 10);
                    ctx.lineTo(px, h - 10);
                    ctx.stroke();
                }
            });
            ctx.setLineDash([]);

            // Draw equilibrium line
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(eqX, 10);
            ctx.lineTo(eqX, h - 10);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw spring
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 2;
            ctx.beginPath();
            const springStart = wallX + 10;
            // Clamp so spring never inverts when mass is pushed past the wall
            const springEnd = Math.max(springStart + 5, massX - massRadius);
            const coils = 12;
            const coilWidth = 15;
            ctx.moveTo(springStart, centerY);
            for (let i = 0; i <= coils; i++) {
                const sx = springStart + (i / coils) * (springEnd - springStart);
                const sy = centerY + (i % 2 === 0 ? -coilWidth : coilWidth) * (i > 0 && i < coils ? 1 : 0);
                ctx.lineTo(sx, sy);
            }
            ctx.stroke();

            // Draw wall
            ctx.fillStyle = '#475569';
            ctx.fillRect(wallX - 5, centerY - 40, 10, 80);
            ctx.strokeStyle = '#64748b';
            ctx.lineWidth = 1;
            for (let i = 0; i < 8; i++) {
                ctx.beginPath();
                ctx.moveTo(wallX - 5, centerY - 35 + i * 10);
                ctx.lineTo(wallX - 15, centerY - 25 + i * 10);
                ctx.stroke();
            }

            // Draw mass
            const gradient = ctx.createRadialGradient(massX - 5, centerY - 5, 0, massX, centerY, massRadius);
            gradient.addColorStop(0, '#60a5fa');
            gradient.addColorStop(1, '#2563eb');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(massX, centerY, massRadius, 0, Math.PI * 2);
            ctx.fill();

            // Draw velocity indicator
            // v_max = Aœâ, scale velocity arrow proportionally to position scale
            const v = -A * omega * Math.sin(omega * time);
            const vMax = A * omega;  // Maximum velocity
            const positionScale = (w - 2 * 40) / (xMax - xMin);  // pixels per unit x
            // Scale velocity so that v_max arrow is same length as amplitude A
            const vScale = (vMax > 0) ? (A * positionScale / vMax) * 0.4 : 15;
            ctx.strokeStyle = '#34d399';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(massX, centerY);
            ctx.lineTo(massX + v * vScale, centerY);
            ctx.stroke();
            // Arrow head
            if (Math.abs(v) > 0.1) {
                const dir = v > 0 ? 1 : -1;
                ctx.beginPath();
                ctx.moveTo(massX + v * vScale, centerY);
                ctx.lineTo(massX + v * vScale - dir * 8, centerY - 5);
                ctx.lineTo(massX + v * vScale - dir * 8, centerY + 5);
                ctx.closePath();
                ctx.fillStyle = '#34d399';
                ctx.fill();
            }

            // Labels
            ctx.fillStyle = '#94a3b8';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('x=0', eqX, h - 5);
            ctx.fillStyle = '#ef4444';
            ctx.fillText('-A', xToCanvas(-A, canvas), h - 5);
            ctx.fillText('+A', xToCanvas(A, canvas), h - 5);
        }

        // Draw quantum wavepacket
        function drawQuantumWave(ctx, canvas) {
            const w = canvas.width / window.devicePixelRatio;
            const h = canvas.height / window.devicePixelRatio;
            const A = getAmplitude();
            const omega = getOmega();
            const sigma = getSigma();
            const x0 = A * Math.cos(omega * time);

            // Clear
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, w, h);

            const centerY = h - 40;
            const yScale = h - 80;

            // Probability density: |œà|¬≤ = sqrt(mœâ/œÄ‚Ñè) * exp(-mœâ/‚Ñè * (x-x0)¬≤)
            // In natural units with ‚Ñè=1: |œà|¬≤ = sqrt(mœâ/œÄ) * exp(-mœâ * (x-x0)¬≤)
            const normFactor = Math.sqrt(m * omega / Math.PI);

            // Draw forbidden region shading (clamp to plot area so negative widths are avoided)
            ctx.fillStyle = 'rgba(239, 68, 68, 0.1)';
            const leftTPq = Math.max(40, xToCanvas(-A, canvas));
            const rightTPq = Math.min(w - 40, xToCanvas(A, canvas));
            if (leftTPq > 40) ctx.fillRect(40, 0, leftTPq - 40, h);
            if (rightTPq < w - 40) ctx.fillRect(rightTPq, 0, w - 40 - rightTPq, h);

            // Draw turning point markers (only if on-screen)
            ctx.strokeStyle = 'rgba(239, 68, 68, 0.5)';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            [-A, A].forEach(xTurn => {
                const px = xToCanvas(xTurn, canvas);
                if (px >= 40 && px <= w - 40) {
                    ctx.beginPath();
                    ctx.moveTo(px, 10);
                    ctx.lineTo(px, h - 10);
                    ctx.stroke();
                }
            });
            ctx.setLineDash([]);

            // Draw x-axis
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(40, centerY);
            ctx.lineTo(w - 40, centerY);
            ctx.stroke();

            // Calculate probability density points
            const points = [];
            const resolution = 200;
            for (let i = 0; i <= resolution; i++) {
                const x = xMin + (i / resolution) * (xMax - xMin);
                const psi2 = normFactor * Math.exp(-m * omega * (x - x0) * (x - x0));
                points.push({ x, psi2 });
            }

            // Fixed reference scale so |œà|¬≤ height changes visibly with m and œâ.
            // Reference: default parameters (m=1, œâ=1) peak fills 70% of display.
            // At extreme parameters the peak is clamped to 95% to prevent overflow.
            const refNormFactor = Math.sqrt(1.0 / Math.PI);  // peak at m=1, œâ=1
            const psi2Scale = yScale * 0.7 / refNormFactor;
            function psi2ToY(psi2) {
                return centerY - Math.min(psi2 * psi2Scale, yScale * 0.95);
            }

            // Draw filled wavepacket with different colors for allowed/forbidden regions
            // First, draw the allowed region (cyan/blue)
            ctx.beginPath();
            ctx.moveTo(xToCanvas(xMin, canvas), centerY);
            points.forEach((p, i) => {
                if (Math.abs(p.x) <= A) {
                    const px = xToCanvas(p.x, canvas);
                    const py = psi2ToY(p.psi2);
                    if (i === 0 || Math.abs(points[i-1].x) > A) {
                        ctx.lineTo(px, centerY);
                    }
                    ctx.lineTo(px, py);
                } else if (i > 0 && Math.abs(points[i-1].x) <= A) {
                    ctx.lineTo(xToCanvas(points[i-1].x, canvas), centerY);
                }
            });
            ctx.lineTo(xToCanvas(A, canvas), centerY);
            ctx.closePath();
            const gradientAllowed = ctx.createLinearGradient(0, centerY - yScale * 0.95, 0, centerY);
            gradientAllowed.addColorStop(0, 'rgba(6, 182, 212, 0.8)');
            gradientAllowed.addColorStop(1, 'rgba(59, 130, 246, 0.3)');
            ctx.fillStyle = gradientAllowed;
            ctx.fill();

            // Draw forbidden regions (orange/red)
            // Left forbidden region
            ctx.beginPath();
            ctx.moveTo(xToCanvas(xMin, canvas), centerY);
            points.forEach((p, i) => {
                if (p.x < -A) {
                    const px = xToCanvas(p.x, canvas);
                    const py = psi2ToY(p.psi2);
                    ctx.lineTo(px, py);
                }
            });
            ctx.lineTo(xToCanvas(-A, canvas), centerY);
            ctx.closePath();
            const gradientForbidden = ctx.createLinearGradient(0, centerY - yScale * 0.95, 0, centerY);
            gradientForbidden.addColorStop(0, 'rgba(249, 115, 22, 0.8)');
            gradientForbidden.addColorStop(1, 'rgba(239, 68, 68, 0.3)');
            ctx.fillStyle = gradientForbidden;
            ctx.fill();

            // Right forbidden region
            ctx.beginPath();
            ctx.moveTo(xToCanvas(A, canvas), centerY);
            points.forEach((p, i) => {
                if (p.x > A) {
                    const px = xToCanvas(p.x, canvas);
                    const py = psi2ToY(p.psi2);
                    ctx.lineTo(px, py);
                }
            });
            ctx.lineTo(xToCanvas(xMax, canvas), centerY);
            ctx.closePath();
            ctx.fillStyle = gradientForbidden;
            ctx.fill();

            // Draw wavepacket outline
            ctx.strokeStyle = '#8b5cf6';
            ctx.lineWidth = 2;
            ctx.beginPath();
            points.forEach((p, i) => {
                const px = xToCanvas(p.x, canvas);
                const py = psi2ToY(p.psi2);
                if (i === 0) ctx.moveTo(px, py);
                else ctx.lineTo(px, py);
            });
            ctx.stroke();

            // Draw center marker
            const centerPx = xToCanvas(x0, canvas);
            ctx.strokeStyle = '#a855f7';
            ctx.lineWidth = 2;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(centerPx, 20);
            ctx.lineTo(centerPx, centerY);
            ctx.stroke();
            ctx.setLineDash([]);

            // Draw sigma markers (¬±œÉ from center, showing wavepacket width)
            ctx.strokeStyle = 'rgba(168, 85, 247, 0.5)';
            ctx.lineWidth = 1;
            [x0 - sigma, x0 + sigma].forEach((xs, i) => {
                if (xs > xMin && xs < xMax) {
                    const px = xToCanvas(xs, canvas);
                    ctx.beginPath();
                    ctx.moveTo(px, centerY - 10);
                    ctx.lineTo(px, centerY + 10);
                    ctx.stroke();
                }
            });

            // Add sigma labels
            ctx.fillStyle = 'rgba(168, 85, 247, 0.7)';
            ctx.font = '9px sans-serif';
            if (x0 - sigma > xMin && x0 - sigma < xMax) {
                ctx.textAlign = 'center';
                ctx.fillText('-œÉ', xToCanvas(x0 - sigma, canvas), centerY + 22);
            }
            if (x0 + sigma > xMin && x0 + sigma < xMax) {
                ctx.textAlign = 'center';
                ctx.fillText('+œÉ', xToCanvas(x0 + sigma, canvas), centerY + 22);
            }

            // Labels
            ctx.fillStyle = '#94a3b8';
            ctx.font = '10px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('x', w - 25, centerY + 15);
            ctx.fillText('|œà|¬≤', 55, 25);
            ctx.fillStyle = '#a855f7';
            ctx.fillText('x‚ÇÄ', centerPx, 15);
            ctx.fillStyle = '#ef4444';
            ctx.fillText('-A', xToCanvas(-A, canvas), h - 5);
            ctx.fillText('+A', xToCanvas(A, canvas), h - 5);
        }

        // Update UI
        function updateUI() {
            const A = getAmplitude();
            const omega = getOmega();
            const x = A * Math.cos(omega * time);

            document.getElementById('classicalX').textContent = x.toFixed(3);
            document.getElementById('quantumX').textContent = x.toFixed(3);
            document.getElementById('omegaValue').textContent = omega.toFixed(3);
            document.getElementById('amplitudeValue').textContent = A.toFixed(3);
            document.getElementById('turningPoints').textContent = `¬±${A.toFixed(2)}`;
        }

        // Animation loop with frame-rate independence
        function animate(currentTime) {
            // Calculate delta time for frame-rate independence
            const deltaTime = (currentTime - lastFrameTime) / 1000;  // Convert to seconds
            lastFrameTime = currentTime;

            // Cap deltaTime to prevent huge jumps after tab switching
            const cappedDelta = Math.min(deltaTime, 0.1);

            if (isPlaying) {
                // Scale by a factor to get reasonable animation speed
                time += cappedDelta * 1.0;  // 1.0 = real-time in natural units
            }

            // Recompute display range so turning points always fit on screen
            updateDisplayRange();

            drawPotential(ctxCP, canvasCP, false);
            drawClassicalMass(ctxCM, canvasCM);
            drawPotential(ctxQP, canvasQP, true);
            drawQuantumWave(ctxQW, canvasQW);
            updateUI();

            requestAnimationFrame(animate);
        }

        // Event listeners
        function setupEventListeners() {
            document.getElementById('playPauseBtn').addEventListener('click', function() {
                isPlaying = !isPlaying;
                this.textContent = isPlaying ? '‚è∏ Pause' : '‚ñ∂ Play';
            });

            document.getElementById('resetBtn').addEventListener('click', function() {
                time = 0;
            });

            document.getElementById('mSlider').addEventListener('input', function() {
                // Preserve oscillation phase across œâ change to prevent position discontinuity
                // Phase Œ∏ = œâ¬∑t is the current point in the oscillation cycle
                const oldOmega = getOmega();
                const phase = oldOmega * time;
                m = parseFloat(this.value);
                const newOmega = getOmega();
                time = newOmega > 0 ? phase / newOmega : time;
                document.getElementById('mSliderValue').textContent = m.toFixed(2) + ' kg';
            });

            document.getElementById('kSlider').addEventListener('input', function() {
                // Changing k affects both œâ = ‚àö(k/m) AND A = ‚àö(2E/k).
                // Phase-only preservation (as used for the mass slider) still causes a
                // position jump because A changes. Instead, preserve the actual position
                // x_old and the velocity direction by solving A_new¬∑cos(Œ∏_new) = x_old.
                const oldOmega = getOmega();
                const oldA = getAmplitude();
                const oldTheta = oldOmega * time;
                const xOld = oldA * Math.cos(oldTheta);
                const movingLeft = Math.sin(oldTheta) > 0; // v = -Aœâ sin(Œ∏), sin>0 ‚Üí v<0

                k = parseFloat(this.value);

                const newOmega = getOmega();
                const newA = getAmplitude();
                if (newOmega > 0 && newA > 0) {
                    // Clamp ratio to [-1, 1] in case x_old is beyond new turning points
                    const cosNew = Math.max(-1, Math.min(1, xOld / newA));
                    let newTheta = Math.acos(cosNew); // returns [0, œÄ] where sin ‚â• 0
                    // acos gives sin(Œ∏) ‚â• 0 (moving left). Flip to [œÄ, 2œÄ] if was moving right.
                    if (!movingLeft) {
                        newTheta = 2 * Math.PI - newTheta;
                    }
                    time = newTheta / newOmega;
                }
                document.getElementById('kSliderValue').textContent = k.toFixed(2) + ' N/m';
            });

            document.getElementById('energySlider').addEventListener('input', function() {
                energy = parseFloat(this.value);
                document.getElementById('energyValue').textContent = energy.toFixed(2) + ' J';
            });

            document.getElementById('sidebarToggle').addEventListener('click', function() {
                document.getElementById('sidebar').classList.toggle('open');
            });

            window.addEventListener('resize', resizeCanvases);
        }

        // Initialize
        function init() {
            initCanvases();
            setupEventListeners();
            
            // Set initial derived values
            document.getElementById('omegaValue').textContent = getOmega().toFixed(3);
            document.getElementById('amplitudeValue').textContent = getAmplitude().toFixed(3);
            
            requestAnimationFrame(animate);
        }

        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

        // --- NARRATION / VOICEOVER ENGINE ---
        const narrationSteps = [
            {
                text: `This simulation places <span class="hl">classical</span> and <span class="hl-purple">quantum</span> harmonic oscillators side by side. On the left, a mass on a spring. On the right, a quantum coherent-state wavepacket in the same parabolic potential. Watch how the quantum center tracks the classical motion <em>exactly</em> ‚Äî this is <span class="hl">Ehrenfest's theorem</span> in action.`,
                speech: `This simulation places classical and quantum harmonic oscillators side by side. On the left, a mass on a spring. On the right, a quantum coherent-state wavepacket in the same parabolic potential. Watch how the quantum center tracks the classical motion exactly ‚Äî this is Ehrenfest's theorem in action.`,
                duration: 16000
            },
            {
                text: `The <span class="hl">top-left</span> plot shows the parabolic potential V(x) = ¬Ωkx¬≤ with the <span class="hl-yellow">yellow dashed energy level</span> E. The <span class="hl">blue dot</span> is the classical mass sliding along the potential bowl ‚Äî it oscillates between the <span class="hl-red">red dashed turning points</span> at ¬±A, where A = ‚àö(2E/k).`,
                speech: `The top-left plot shows the parabolic potential V of x equals one-half k x squared with the yellow dashed energy level E. The blue dot is the classical mass sliding along the potential bowl ‚Äî it oscillates between the red dashed turning points at plus or minus A, where A equals the square root of 2 E over k.`,
                duration: 15000
            },
            {
                text: `The <span class="hl-purple">top-right</span> shows the same potential, but now with <span class="hl-red">red-shaded forbidden regions</span> ‚Äî areas where V(x) > E. Classically, the particle can <em>never</em> enter these regions. But quantum mechanically, the wavepacket's tails extend into them ‚Äî this is <span class="hl-cyan">quantum tunneling</span>.`,
                speech: `The top-right shows the same potential, but now with red-shaded forbidden regions ‚Äî areas where V of x is greater than E. Classically, the particle can never enter these regions. But quantum mechanically, the wavepacket's tails extend into them ‚Äî this is quantum tunneling.`,
                duration: 14000
            },
            {
                text: `The <span class="hl-purple">bottom-right</span> plot shows |œà(x,t)|¬≤ ‚Äî the probability density of the coherent state. It's a <span class="hl-purple">Gaussian bell curve</span> whose center oscillates exactly like the classical mass: x‚ÇÄ(t) = A cos(œât). The width œÉ = 1/‚àö(2mœâ) stays constant ‚Äî the wavepacket never spreads.`,
                speech: `The bottom-right plot shows the probability density of the coherent state. It's a Gaussian bell curve whose center oscillates exactly like the classical mass: x zero of t equals A cosine omega t. The width sigma equals 1 over the square root of 2 m omega stays constant ‚Äî the wavepacket never spreads.`,
                duration: 15000
            },
            {
                text: `<span class="hl">Try the Energy slider:</span> Increase E from 2 to 5 ‚Äî the classical mass swings wider (larger amplitude A) and the <span class="hl-red">turning points</span> move outward. The quantum wavepacket also swings wider, but notice its <em>width stays the same</em> ‚Äî only the oscillation range grows.`,
                speech: `Try the Energy slider: Increase E from 2 to 5 ‚Äî the classical mass swings wider with a larger amplitude A, and the turning points move outward. The quantum wavepacket also swings wider, but notice its width stays the same ‚Äî only the oscillation range grows.`,
                duration: 14000
            },
            {
                text: `<span class="hl">Try the Stiffness slider:</span> Increase k from 1 to 4. The potential well gets <em>steeper</em> (narrower bowl), so œâ = ‚àö(k/m) increases ‚Äî the oscillation speeds up. The amplitude shrinks because A = ‚àö(2E/k). Also watch the quantum wavepacket get <em>narrower</em> because œÉ depends on 1/‚àö(œâ).`,
                speech: `Try the Stiffness slider: Increase k from 1 to 4. The potential well gets steeper ‚Äî a narrower bowl ‚Äî so omega equals the square root of k over m increases, and the oscillation speeds up. The amplitude shrinks because A equals the square root of 2 E over k. Also watch the quantum wavepacket get narrower because sigma depends on 1 over the square root of omega.`,
                duration: 16000
            },
            {
                text: `<span class="hl">Try the Mass slider:</span> Increase m from 1 to 4. Now œâ = ‚àö(k/m) decreases ‚Äî the oscillation slows down. The amplitude A doesn't change (it only depends on E and k), but the quantum wavepacket gets <em>narrower</em> because œÉ = 1/‚àö(2mœâ). A heavier particle has a more localized wavefunction.`,
                speech: `Try the Mass slider: Increase m from 1 to 4. Now omega decreases ‚Äî the oscillation slows down. The amplitude A doesn't change since it only depends on E and k, but the quantum wavepacket gets narrower because sigma equals 1 over the square root of 2 m omega. A heavier particle has a more localized wavefunction.`,
                duration: 16000
            },
            {
                text: `<span class="hl">Key insight:</span> Coherent states are the "most classical" quantum states ‚Äî they minimize the Heisenberg uncertainty product Œîx¬∑Œîp = ‚Ñè/2. Use <span class="hl">Pause</span> to freeze a moment and compare positions. Watch the <span class="hl-green">Live Readouts</span> to see Classical x and Quantum x‚ÇÄ stay perfectly in sync.`,
                speech: `Key insight: Coherent states are the most classical quantum states ‚Äî they minimize the Heisenberg uncertainty product delta x times delta p equals h-bar over 2. Use Pause to freeze a moment and compare positions. Watch the Live Readouts to see Classical x and Quantum x zero stay perfectly in sync.`,
                duration: 15000
            }
        ];

        let narration = {
            currentStep: 0,
            isPlaying: false,
            timer: null,
            utterance: null,
            speechSupported: 'speechSynthesis' in window
        };

        function initNarration() {
            const dotsContainer = document.getElementById('narr-dots');
            narrationSteps.forEach((_, i) => {
                const dot = document.createElement('div');
                dot.className = 'narr-dot' + (i === 0 ? ' active' : '');
                dot.onclick = () => jumpToNarrStep(i);
                dotsContainer.appendChild(dot);
            });

            document.getElementById('narr-play').onclick = playNarration;
            document.getElementById('narr-pause').onclick = pauseNarration;
            document.getElementById('narr-back').onclick = goBackOneNarrStep;

            showNarrStep(0);
        }

        function showNarrStep(index) {
            narration.currentStep = index;
            document.getElementById('narration-text').innerHTML = narrationSteps[index].text;

            const dots = document.querySelectorAll('.narr-dot');
            dots.forEach((dot, i) => {
                dot.className = 'narr-dot';
                if (i < index) dot.classList.add('completed');
                if (i === index) dot.classList.add('active');
            });

            const progress = (index / (narrationSteps.length - 1)) * 100;
            document.getElementById('narr-progress-bar').style.width = progress + '%';
        }

        function finishNarration() {
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');
            if (narration.speechSupported) window.speechSynthesis.cancel();
            if (narration.timer) { clearTimeout(narration.timer); narration.timer = null; }

            narration.timer = setTimeout(() => {
                narration.currentStep = 0;
                showNarrStep(0);
                document.getElementById('narr-progress-bar').style.width = '0%';
                narration.timer = null;
            }, 1200);
        }

        function speakNarrStep(index) {
            if (!narration.speechSupported) return;
            window.speechSynthesis.cancel();

            const utterance = new SpeechSynthesisUtterance(narrationSteps[index].speech);
            utterance.rate = 0.92;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            // Select Samantha voice (priority), fallback to any English voice
            const voices = window.speechSynthesis.getVoices();
            const samantha = voices.find(v => v.name.includes('Samantha'));
            const fallback = voices.find(v => v.lang.startsWith('en') && (v.name.includes('Google') || v.name.includes('Natural') || v.name.includes('Daniel'))) || voices.find(v => v.lang.startsWith('en'));
            utterance.voice = samantha || fallback || null;

            utterance.onend = () => {
                if (!narration.isPlaying) return;
                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) {
                    finishNarration();
                } else {
                    narration.timer = setTimeout(() => {
                        if (narration.isPlaying) { showNarrStep(nextIndex); speakNarrStep(nextIndex); }
                    }, 800);
                }
            };

            narration.utterance = utterance;
            window.speechSynthesis.speak(utterance);
        }

        function playNarration() {
            if (narration.isPlaying) return;
            narration.isPlaying = true;
            document.getElementById('narr-play').classList.add('active');
            document.getElementById('narr-pause').classList.remove('active');
            if (narration.timer) { clearTimeout(narration.timer); narration.timer = null; }

            if (narration.speechSupported) {
                if (window.speechSynthesis.getVoices().length === 0) {
                    window.speechSynthesis.onvoiceschanged = () => speakNarrStep(narration.currentStep);
                } else {
                    speakNarrStep(narration.currentStep);
                }
            } else {
                advanceNarrByTimer();
            }
        }

        function advanceNarrByTimer() {
            if (!narration.isPlaying) return;
            narration.timer = setTimeout(() => {
                if (!narration.isPlaying) return;
                const nextIndex = narration.currentStep + 1;
                if (nextIndex >= narrationSteps.length) { finishNarration(); }
                else { showNarrStep(nextIndex); advanceNarrByTimer(); }
            }, narrationSteps[narration.currentStep].duration);
        }

        function pauseNarration() {
            narration.isPlaying = false;
            document.getElementById('narr-play').classList.remove('active');
            document.getElementById('narr-pause').classList.add('active');
            if (narration.speechSupported) window.speechSynthesis.cancel();
            if (narration.timer) { clearTimeout(narration.timer); narration.timer = null; }
        }

        function goBackOneNarrStep() {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');
            const prevStep = Math.max(0, narration.currentStep - 1);
            narration.currentStep = prevStep;
            showNarrStep(prevStep);
            if (wasPlaying) playNarration();
        }

        function jumpToNarrStep(index) {
            const wasPlaying = narration.isPlaying;
            pauseNarration();
            document.getElementById('narr-pause').classList.remove('active');
            narration.currentStep = index;
            showNarrStep(index);
            if (wasPlaying) playNarration();
        }

        initNarration();
    </script>
</body>
</html>