<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Measurement Simulation</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: #0f172a; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: #e2e8f0;
            height: 100vh;
            overflow: hidden;
        }
        
        .top-header {
            background: rgba(30, 41, 59, 0.95);
            border-bottom: 2px solid rgba(59, 130, 246, 0.3);
            padding: 12px 25px;
            display: flex;
            align-items: center;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            height: 50px;
        }
        
        .title-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .simulation-title {
            font-size: 18px;
            font-weight: 600;
            color: #f1f5f9;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .simulation-title::before {
            content: '';
            width: 10px;
            height: 10px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 50%;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        
        .info-icon-container {
            position: relative;
            display: inline-flex;
        }
        
        .info-icon {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.2);
            border: 1px solid rgba(59, 130, 246, 0.5);
            color: #60a5fa;
            font-size: 12px;
            font-weight: 700;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: help;
            transition: all 0.2s;
        }
        
        .info-icon:hover {
            background: rgba(59, 130, 246, 0.4);
            transform: scale(1.1);
        }
        
        .info-tooltip {
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 10px;
            width: 350px;
            background: rgba(30, 41, 59, 0.98);
            border: 1px solid rgba(59, 130, 246, 0.3);
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
            opacity: 0;
            visibility: hidden;
            transform: translateY(-10px);
            transition: all 0.3s ease;
            z-index: 1000;
        }
        
        .info-icon-container:hover .info-tooltip {
            opacity: 1;
            visibility: visible;
            transform: translateY(0);
        }
        
        .info-tooltip h4 {
            color: #60a5fa;
            font-size: 14px;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .info-tooltip p {
            color: #94a3b8;
            font-size: 12px;
            line-height: 1.6;
            margin-bottom: 8px;
        }
        
        .info-tooltip p:last-child {
            margin-bottom: 0;
        }
        
        .info-tooltip .highlight {
            color: #f472b6;
            font-weight: 500;
        }
        
        .main-layout {
            display: flex;
            height: calc(100vh - 50px);
            margin-top: 50px;
        }
        
        .canvas-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 15px;
            gap: 15px;
            overflow: hidden;
        }
        
        .control-panel {
            width: 300px;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(12px);
            border-left: 1px solid rgba(148, 163, 184, 0.1);
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
        }
        
        .panel-section {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            padding: 12px;
        }
        
        .panel-title {
            font-size: 13px;
            font-weight: 600;
            color: #f1f5f9;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .panel-title::before {
            content: '';
            width: 6px;
            height: 6px;
            background: #3b82f6;
            border-radius: 50%;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-bottom: 12px;
        }
        
        .control-group:last-child {
            margin-bottom: 0;
        }
        
        .control-group label {
            font-size: 11px;
            color: #94a3b8;
        }
        
        .control-row {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .btn {
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
            width: 100%;
        }
        
        .btn-primary {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
        }
        
        .btn-primary:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }
        
        .btn-secondary {
            background: rgba(148, 163, 184, 0.2);
            color: #e2e8f0;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }
        
        .btn-secondary:hover {
            background: rgba(148, 163, 184, 0.3);
        }
        
        .btn-toggle {
            background: rgba(148, 163, 184, 0.2);
            color: #94a3b8;
        }
        
        .btn-toggle.active {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }
        
        .slider {
            width: 100%;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(148, 163, 184, 0.3);
            border-radius: 2px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }
        
        select {
            padding: 6px 8px;
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 4px;
            color: #e2e8f0;
            font-size: 11px;
            cursor: pointer;
            width: 100%;
        }
        
        .canvas-container {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(148, 163, 184, 0.1);
            padding: 12px;
            position: relative;
            flex: 1;
            display: flex;
            flex-direction: column;
            min-height: 0;
        }
        
        .canvas-title {
            font-size: 13px;
            color: #94a3b8;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }
        
        .canvas-title span {
            color: #60a5fa;
            font-weight: 600;
        }
        
        canvas {
            display: block;
            border-radius: 6px;
            width: 100%;
            flex: 1;
            min-height: 0;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            font-size: 11px;
            color: #94a3b8;
        }
        
        .stat-value {
            font-size: 12px;
            font-weight: 600;
            color: #f1f5f9;
            font-variant-numeric: tabular-nums;
        }
        
        .stat-value.highlight {
            color: #60a5fa;
        }
        
        .convergence-bar {
            margin-top: 10px;
        }
        
        .convergence-label {
            font-size: 10px;
            color: #94a3b8;
            margin-bottom: 4px;
        }
        
        .convergence-track {
            height: 5px;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .convergence-fill {
            height: 100%;
            background: linear-gradient(90deg, #f472b6, #8b5cf6, #3b82f6);
            border-radius: 3px;
            transition: width 0.3s ease;
        }
        
        .legend {
            display: flex;
            gap: 15px;
            margin-top: 8px;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 10px;
            color: #94a3b8;
        }
        
        .legend-color {
            width: 14px;
            height: 3px;
            border-radius: 2px;
        }
        
        .legend-color.dashed {
            background: repeating-linear-gradient(90deg, #f472b6, #f472b6 4px, transparent 4px, transparent 8px);
        }
        
        .slider-value {
            font-size: 11px;
            color: #60a5fa;
            min-width: 35px;
            text-align: right;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .stats-indicator::before {
            content: '';
            width: 6px;
            height: 6px;
            background: #10b981;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }
        
        .momentum-indicator {
            font-size: 10px;
            color: #10b981;
            background: rgba(16, 185, 129, 0.1);
            padding: 3px 6px;
            border-radius: 4px;
            margin-top: 4px;
        }
        
        @media (max-width: 1000px) {
            .main-layout {
                flex-direction: column;
            }
            
            .control-panel {
                width: 100%;
                flex-direction: row;
                flex-wrap: wrap;
                border-left: none;
                border-top: 1px solid rgba(148, 163, 184, 0.1);
                max-height: 200px;
            }
            
            .panel-section {
                flex: 1;
                min-width: 200px;
            }
        }
    </style>
</head>
<body>
    <div class="top-header">
        <div class="title-container">
            <div class="simulation-title">Quantum Wavefunction Measurement Simulation</div>
            <div class="info-icon-container">
                <div class="info-icon">i</div>
                <div class="info-tooltip">
                    <h4>ðŸ“Š About This Simulation</h4>
                    <p>This interactive simulation demonstrates the <span class="highlight">quantum measurement process</span> for a Gaussian wavepacket with zero average momentum.</p>
                    <p>The <span class="highlight">wavefunction Ïˆ(x)</span> represents the quantum state of a particle. The probability of finding the particle at position x is given by <span class="highlight">|Ïˆ(x)|Â²</span>.</p>
                    <p>Each measurement "collapses" the wavefunction, yielding a random position sampled from the probability distribution. As you accumulate measurements, the histogram converges to the theoretical distribution.</p>
                    <p>Use the controls to adjust measurement rate, view different representations (real/imaginary parts), and observe quantum statistics in action!</p>
                </div>
            </div>
        </div>
    </div>
    
    <div class="main-layout">
        <div class="canvas-area">
            <div class="canvas-container" id="wavefunctionContainer">
                <div class="canvas-title">Wavefunction <span id="viewLabel">|Ïˆ(x)|Â²</span></div>
                <canvas id="wavefunctionCanvas"></canvas>
            </div>
            
            <div class="canvas-container" id="histogramContainer">
                <div class="canvas-title">Measurement Results <span id="measurementCount">0 measurements</span></div>
                <canvas id="histogramCanvas"></canvas>
                <div class="legend">
                    <div class="legend-item">
                        <div class="legend-color" style="background: #3b82f6;"></div>
                        <span>Histogram (Normalized)</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color dashed"></div>
                        <span>Theoretical |Ïˆ(x)|Â²</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="control-panel">
            <div class="panel-section">
                <div class="panel-title">Measurement Controls</div>
                
                <div class="control-group">
                    <button class="btn btn-primary" id="measureBtn">âš¡ Measure</button>
                </div>
                
                <div class="control-group">
                    <label>Measurements per click</label>
                    <select id="measureCount">
                        <option value="1">1 per click</option>
                        <option value="10">10 per click</option>
                        <option value="50">50 per click</option>
                        <option value="100" selected>100 per click</option>
                        <option value="500">500 per click</option>
                        <option value="1000">1000 per click</option>
                    </select>
                </div>
                
                <div class="control-group">
                    <button class="btn btn-toggle" id="autoMeasure">Auto Measure</button>
                </div>
                
                <div class="control-group">
                    <label>Auto-measure rate</label>
                    <div class="control-row">
                        <input type="range" class="slider" id="autoRate" min="1" max="100" value="20">
                        <span class="slider-value" id="rateValue">20/s</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <button class="btn btn-secondary" id="resetBtn">â†º Reset Measurements</button>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">Wavefunction Settings</div>
                
                <div class="control-group">
                    <label>Animation Speed</label>
                    <div class="control-row">
                        <input type="range" class="slider" id="animationSpeedSlider" min="1" max="20" value="5">
                        <span class="slider-value" id="animationSpeedValue">1.0x</span>
                    </div>
                </div>
                
                <div class="control-group">
                    <label>View Mode</label>
                    <select id="viewMode">
                        <option value="probability">|Ïˆ(x)|Â² Probability Density</option>
                        <option value="real">Re(Ïˆ) Real Part</option>
                        <option value="imag">Im(Ïˆ) Imaginary Part</option>
                        <option value="both">Re(Ïˆ) & Im(Ïˆ)</option>
                    </select>
                    <div class="momentum-indicator">âŸ¨pâŸ© = 0 (Zero Average Momentum)</div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title stats-indicator">Statistics</div>
                
                <div class="stat-row">
                    <span class="stat-label">Total Measurements</span>
                    <span class="stat-value highlight" id="totalMeasurements">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Mean Position</span>
                    <span class="stat-value" id="meanPosition">â€”</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Measured Std Dev</span>
                    <span class="stat-value" id="stdDev">â€”</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Theoretical Ïƒ</span>
                    <span class="stat-value" id="theoreticalSigma">50.0</span>
                </div>
                
                <div class="convergence-bar">
                    <div class="convergence-label">Convergence to Theory</div>
                    <div class="convergence-track">
                        <div class="convergence-fill" id="convergenceFill" style="width: 0%;"></div>
                    </div>
                </div>
            </div>
            
            <div class="panel-section">
                <div class="panel-title">Keyboard Shortcuts</div>
                <div style="font-size: 10px; color: #94a3b8; line-height: 1.8;">
                    <div><kbd style="background: rgba(148,163,184,0.2); padding: 2px 5px; border-radius: 3px;">Space</kbd> â€” Measure</div>
                    <div><kbd style="background: rgba(148,163,184,0.2); padding: 2px 5px; border-radius: 3px;">A</kbd> â€” Toggle Auto</div>
                    <div><kbd style="background: rgba(148,163,184,0.2); padding: 2px 5px; border-radius: 3px;">R</kbd> â€” Reset</div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Canvas setup
        const wfCanvas = document.getElementById('wavefunctionCanvas');
        const wfCtx = wfCanvas.getContext('2d');
        const histCanvas = document.getElementById('histogramCanvas');
        const histCtx = histCanvas.getContext('2d');
        
        // Margins for axis labels
        const marginLeft = 60;
        const marginRight = 20;
        const marginTop = 20;
        const marginBottom = 40;
        
        // State - use abstract/normalized coordinate system independent of canvas pixels
        // The wavefunction is centered at x=0 in data space, with sigma in data units
        const sigma = 1.0; // Wavepacket width in normalized units
        const omega = 5; // Fixed oscillation frequency for time evolution
        let animationSpeed = 1.0; // Animation speed multiplier
        const dataCenter = 0; // Center of the Gaussian in data coordinates (always 0)
        const dataRange = 4 * sigma; // Show Â±4Ïƒ range in data space
        const numBins = 100; // Original bin count for fine-grained histogram
        let measurements = [];
        let histogram = new Array(numBins).fill(0);
        let autoMeasureActive = false;
        let autoMeasureInterval = null;
        let viewMode = 'probability';
        let animationTime = 0;
        let flashEffects = [];
        
        // DOM elements
        const measureBtn = document.getElementById('measureBtn');
        const measureCountSelect = document.getElementById('measureCount');
        const autoMeasureBtn = document.getElementById('autoMeasure');
        const autoRateSlider = document.getElementById('autoRate');
        const rateValueSpan = document.getElementById('rateValue');
        const animationSpeedSlider = document.getElementById('animationSpeedSlider');
        const animationSpeedValueSpan = document.getElementById('animationSpeedValue');
        const viewModeSelect = document.getElementById('viewMode');
        const resetBtn = document.getElementById('resetBtn');
        const viewLabel = document.getElementById('viewLabel');
        const measurementCountSpan = document.getElementById('measurementCount');
        const totalMeasurementsSpan = document.getElementById('totalMeasurements');
        const meanPositionSpan = document.getElementById('meanPosition');
        const stdDevSpan = document.getElementById('stdDev');
        const theoreticalSigmaSpan = document.getElementById('theoreticalSigma');
        const convergenceFill = document.getElementById('convergenceFill');
        
        // Update display sigma
        theoreticalSigmaSpan.textContent = sigma.toFixed(2);
        
        // Resize canvases to fill containers
        function resizeCanvases() {
            const wfContainer = document.getElementById('wavefunctionContainer');
            const histContainer = document.getElementById('histogramContainer');
            
            const wfRect = wfContainer.getBoundingClientRect();
            const histRect = histContainer.getBoundingClientRect();
            
            const padding = 24;
            const titleHeight = 30;
            const legendHeight = 30;
            
            wfCanvas.width = wfRect.width - padding;
            wfCanvas.height = wfRect.height - padding - titleHeight;
            
            histCanvas.width = histRect.width - padding;
            histCanvas.height = histRect.height - padding - titleHeight - legendHeight;
        }
        
        // Gaussian probability density function (properly normalized)
        function gaussian(x, mu, sig) {
            return Math.exp(-0.5 * Math.pow((x - mu) / sig, 2)) / (sig * Math.sqrt(2 * Math.PI));
        }
        
        // Sample from Gaussian distribution using Box-Muller transform
        function sampleGaussian(mu, sig) {
            // Ensure u1 is never 0 to avoid Math.log(0) = -Infinity
            let u1;
            do {
                u1 = Math.random();
            } while (u1 === 0);
            let u2 = Math.random();
            let z = Math.sqrt(-2 * Math.log(u1)) * Math.cos(2 * Math.PI * u2);
            return mu + sig * z;
        }
        
        // Get plot area dimensions
        function getPlotArea(canvas) {
            return {
                x: marginLeft,
                y: marginTop,
                width: canvas.width - marginLeft - marginRight,
                height: canvas.height - marginTop - marginBottom
            };
        }
        
        // Convert data x (normalized units) to canvas pixel x
        function dataToCanvasX(dataX, plotArea) {
            const normalized = (dataX - dataCenter + dataRange) / (2 * dataRange);
            return plotArea.x + normalized * plotArea.width;
        }
        
        // Convert canvas pixel x to data x (normalized units)
        function canvasToDataX(canvasX, plotArea) {
            const normalized = (canvasX - plotArea.x) / plotArea.width;
            return dataCenter - dataRange + normalized * 2 * dataRange;
        }
        
        // Draw wavefunction
        function drawWavefunction() {
            wfCtx.fillStyle = '#1e293b';
            wfCtx.fillRect(0, 0, wfCanvas.width, wfCanvas.height);
            
            const plotArea = getPlotArea(wfCanvas);
            
            // Draw grid
            wfCtx.strokeStyle = 'rgba(148, 163, 184, 0.1)';
            wfCtx.lineWidth = 1;
            for (let i = 0; i <= 8; i++) {
                const x = plotArea.x + (i / 8) * plotArea.width;
                wfCtx.beginPath();
                wfCtx.moveTo(x, plotArea.y);
                wfCtx.lineTo(x, plotArea.y + plotArea.height);
                wfCtx.stroke();
            }
            for (let i = 0; i <= 5; i++) {
                const y = plotArea.y + (i / 5) * plotArea.height;
                wfCtx.beginPath();
                wfCtx.moveTo(plotArea.x, y);
                wfCtx.lineTo(plotArea.x + plotArea.width, y);
                wfCtx.stroke();
            }
            
            // Draw axes
            wfCtx.strokeStyle = 'rgba(148, 163, 184, 0.5)';
            wfCtx.lineWidth = 2;
            wfCtx.beginPath();
            wfCtx.moveTo(plotArea.x, plotArea.y + plotArea.height);
            wfCtx.lineTo(plotArea.x + plotArea.width, plotArea.y + plotArea.height);
            wfCtx.stroke();
            
            wfCtx.beginPath();
            wfCtx.moveTo(plotArea.x, plotArea.y);
            wfCtx.lineTo(plotArea.x, plotArea.y + plotArea.height);
            wfCtx.stroke();
            
            // Calculate max value for scaling
            const maxProb = gaussian(dataCenter, dataCenter, sigma);
            
            // Time parameter for oscillation
            const t = animationTime * 0.02 * animationSpeed;
            
            if (viewMode === 'probability') {
                // Draw |Ïˆ(x)|Â² filled area
                wfCtx.beginPath();
                wfCtx.moveTo(plotArea.x, plotArea.y + plotArea.height);
                
                for (let px = 0; px <= plotArea.width; px++) {
                    const dataX = canvasToDataX(plotArea.x + px, plotArea);
                    const prob = gaussian(dataX, dataCenter, sigma);
                    const y = plotArea.y + plotArea.height - (prob / maxProb) * plotArea.height * 0.9;
                    wfCtx.lineTo(plotArea.x + px, y);
                }
                
                wfCtx.lineTo(plotArea.x + plotArea.width, plotArea.y + plotArea.height);
                wfCtx.closePath();
                
                const gradient = wfCtx.createLinearGradient(0, plotArea.y, 0, plotArea.y + plotArea.height);
                gradient.addColorStop(0, 'rgba(139, 92, 246, 0.6)');
                gradient.addColorStop(1, 'rgba(59, 130, 246, 0.1)');
                wfCtx.fillStyle = gradient;
                wfCtx.fill();
                
                // Draw curve outline
                wfCtx.strokeStyle = '#8b5cf6';
                wfCtx.lineWidth = 3;
                wfCtx.beginPath();
                for (let px = 0; px <= plotArea.width; px++) {
                    const dataX = canvasToDataX(plotArea.x + px, plotArea);
                    const prob = gaussian(dataX, dataCenter, sigma);
                    const y = plotArea.y + plotArea.height - (prob / maxProb) * plotArea.height * 0.9;
                    if (px === 0) wfCtx.moveTo(plotArea.x + px, y);
                    else wfCtx.lineTo(plotArea.x + px, y);
                }
                wfCtx.stroke();
                
            } else {
                const envelope = (dataX) => Math.sqrt(gaussian(dataX, dataCenter, sigma) / maxProb);
                const phase = omega * t;
                
                if (viewMode === 'real' || viewMode === 'both') {
                    wfCtx.strokeStyle = '#60a5fa';
                    wfCtx.lineWidth = 2;
                    wfCtx.beginPath();
                    
                    for (let px = 0; px <= plotArea.width; px++) {
                        const dataX = canvasToDataX(plotArea.x + px, plotArea);
                        const env = envelope(dataX);
                        const val = env * Math.cos(phase);
                        const y = plotArea.y + plotArea.height / 2 - val * plotArea.height * 0.4;
                        if (px === 0) wfCtx.moveTo(plotArea.x + px, y);
                        else wfCtx.lineTo(plotArea.x + px, y);
                    }
                    wfCtx.stroke();
                }
                
                if (viewMode === 'imag' || viewMode === 'both') {
                    wfCtx.strokeStyle = '#f472b6';
                    wfCtx.lineWidth = 2;
                    wfCtx.beginPath();
                    
                    for (let px = 0; px <= plotArea.width; px++) {
                        const dataX = canvasToDataX(plotArea.x + px, plotArea);
                        const env = envelope(dataX);
                        const val = -env * Math.sin(phase);
                        const y = plotArea.y + plotArea.height / 2 - val * plotArea.height * 0.4;
                        if (px === 0) wfCtx.moveTo(plotArea.x + px, y);
                        else wfCtx.lineTo(plotArea.x + px, y);
                    }
                    wfCtx.stroke();
                }
                
                // Draw envelope (dashed)
                wfCtx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
                wfCtx.lineWidth = 1;
                wfCtx.setLineDash([4, 4]);
                
                wfCtx.beginPath();
                for (let px = 0; px <= plotArea.width; px++) {
                    const dataX = canvasToDataX(plotArea.x + px, plotArea);
                    const env = envelope(dataX);
                    const y = plotArea.y + plotArea.height / 2 - env * plotArea.height * 0.4;
                    if (px === 0) wfCtx.moveTo(plotArea.x + px, y);
                    else wfCtx.lineTo(plotArea.x + px, y);
                }
                wfCtx.stroke();
                
                wfCtx.beginPath();
                for (let px = 0; px <= plotArea.width; px++) {
                    const dataX = canvasToDataX(plotArea.x + px, plotArea);
                    const env = envelope(dataX);
                    const y = plotArea.y + plotArea.height / 2 + env * plotArea.height * 0.4;
                    if (px === 0) wfCtx.moveTo(plotArea.x + px, y);
                    else wfCtx.lineTo(plotArea.x + px, y);
                }
                wfCtx.stroke();
                wfCtx.setLineDash([]);
                
                // Draw zero line
                wfCtx.strokeStyle = 'rgba(148, 163, 184, 0.3)';
                wfCtx.lineWidth = 1;
                wfCtx.setLineDash([5, 5]);
                wfCtx.beginPath();
                wfCtx.moveTo(plotArea.x, plotArea.y + plotArea.height / 2);
                wfCtx.lineTo(plotArea.x + plotArea.width, plotArea.y + plotArea.height / 2);
                wfCtx.stroke();
                wfCtx.setLineDash([]);
            }
            
            // Draw x-axis labels in sigma units
            wfCtx.fillStyle = '#94a3b8';
            wfCtx.font = '11px -apple-system, sans-serif';
            wfCtx.textAlign = 'center';
            for (let i = 0; i <= 8; i++) {
                const x = plotArea.x + (i / 8) * plotArea.width;
                const dataX = canvasToDataX(x, plotArea);
                const labelVal = dataX / sigma;
                wfCtx.fillText(labelVal.toFixed(1) + 'Ïƒ', x, plotArea.y + plotArea.height + 20);
            }
            wfCtx.fillText('Position (x)', plotArea.x + plotArea.width / 2, plotArea.y + plotArea.height + 35);
            
            // Draw y-axis label
            wfCtx.save();
            wfCtx.translate(15, plotArea.y + plotArea.height / 2);
            wfCtx.rotate(-Math.PI / 2);
            wfCtx.textAlign = 'center';
            wfCtx.fillStyle = '#94a3b8';
            wfCtx.font = '12px -apple-system, sans-serif';
            
            let yLabel = '';
            if (viewMode === 'probability') {
                yLabel = '|Ïˆ(x)|Â² (Probability Density)';
            } else if (viewMode === 'real') {
                yLabel = 'Re(Ïˆ(x,t)) (Amplitude)';
            } else if (viewMode === 'imag') {
                yLabel = 'Im(Ïˆ(x,t)) (Amplitude)';
            } else {
                yLabel = 'Ïˆ(x,t) (Amplitude)';
            }
            wfCtx.fillText(yLabel, 0, 0);
            wfCtx.restore();
            
            // Draw y-axis tick marks
            wfCtx.fillStyle = '#94a3b8';
            wfCtx.font = '10px -apple-system, sans-serif';
            wfCtx.textAlign = 'right';
            
            if (viewMode === 'probability') {
                for (let i = 0; i <= 5; i++) {
                    const y = plotArea.y + plotArea.height - (i / 5) * plotArea.height * 0.9;
                    const val = (i / 5) * maxProb;
                    wfCtx.fillText(val.toFixed(3), plotArea.x - 5, y + 4);
                }
            } else {
                for (let i = -2; i <= 2; i++) {
                    const y = plotArea.y + plotArea.height / 2 - (i / 2) * plotArea.height * 0.4;
                    wfCtx.fillText((i / 2).toFixed(1), plotArea.x - 5, y + 4);
                }
            }
        }
        
        // Draw histogram - recomputed from raw measurements each frame for correctness
        function drawHistogram() {
            histCtx.fillStyle = '#1e293b';
            histCtx.fillRect(0, 0, histCanvas.width, histCanvas.height);
            
            const plotArea = getPlotArea(histCanvas);
            const totalCount = measurements.length;
            const binMin = dataCenter - dataRange; // -4Ïƒ
            const binMax = dataCenter + dataRange; // +4Ïƒ
            const binWidth = (binMax - binMin) / numBins;
            
            // Recompute histogram from raw measurements for accuracy
            const histCounts = new Array(numBins).fill(0);
            let outsideCount = 0;
            for (let i = 0; i < measurements.length; i++) {
                const m = measurements[i];
                const binIndex = Math.floor((m - binMin) / binWidth);
                if (binIndex >= 0 && binIndex < numBins) {
                    histCounts[binIndex]++;
                } else {
                    outsideCount++;
                }
            }
            
            // Draw grid
            histCtx.strokeStyle = 'rgba(148, 163, 184, 0.1)';
            histCtx.lineWidth = 1;
            for (let i = 0; i <= 8; i++) {
                const x = plotArea.x + (i / 8) * plotArea.width;
                histCtx.beginPath();
                histCtx.moveTo(x, plotArea.y);
                histCtx.lineTo(x, plotArea.y + plotArea.height);
                histCtx.stroke();
            }
            for (let i = 0; i <= 5; i++) {
                const y = plotArea.y + (i / 5) * plotArea.height;
                histCtx.beginPath();
                histCtx.moveTo(plotArea.x, y);
                histCtx.lineTo(plotArea.x + plotArea.width, y);
                histCtx.stroke();
            }
            
            // Draw axes
            histCtx.strokeStyle = 'rgba(148, 163, 184, 0.5)';
            histCtx.lineWidth = 2;
            histCtx.beginPath();
            histCtx.moveTo(plotArea.x, plotArea.y + plotArea.height);
            histCtx.lineTo(plotArea.x + plotArea.width, plotArea.y + plotArea.height);
            histCtx.stroke();
            
            histCtx.beginPath();
            histCtx.moveTo(plotArea.x, plotArea.y);
            histCtx.lineTo(plotArea.x, plotArea.y + plotArea.height);
            histCtx.stroke();
            
            // Calculate max probability density for scaling (theoretical)
            const maxProb = gaussian(dataCenter, dataCenter, sigma);
            
            // Draw histogram bars (normalized to probability density)
            const barPixelWidth = plotArea.width / numBins;
            const gradient = histCtx.createLinearGradient(0, plotArea.y, 0, plotArea.y + plotArea.height);
            gradient.addColorStop(0, '#3b82f6');
            gradient.addColorStop(1, '#1e40af');
            
            // Normalize using the total number of measurements so that,
            // in expectation, the histogram's peak height matches the
            // theoretical Gaussian probability density peak.
            const effectiveTotal = totalCount;
            
            for (let i = 0; i < numBins; i++) {
                if (histCounts[i] > 0 && effectiveTotal > 0) {
                    // (count / totalCount) / binWidth -> probability density estimate
                    const probDensity = (histCounts[i] / effectiveTotal) / binWidth;
                    const barHeight = (probDensity / maxProb) * plotArea.height * 0.9;
                    const x = plotArea.x + i * barPixelWidth;
                    
                    histCtx.fillStyle = gradient;
                    histCtx.fillRect(x, plotArea.y + plotArea.height - barHeight, barPixelWidth - 1, barHeight);
                }
            }
            
            // Draw theoretical distribution overlay
            histCtx.strokeStyle = '#f472b6';
            histCtx.lineWidth = 2;
            histCtx.setLineDash([6, 4]);
            histCtx.beginPath();
            
            for (let px = 0; px <= plotArea.width; px++) {
                const dataX = canvasToDataX(plotArea.x + px, plotArea);
                const prob = gaussian(dataX, dataCenter, sigma);
                const y = plotArea.y + plotArea.height - (prob / maxProb) * plotArea.height * 0.9;
                if (px === 0) histCtx.moveTo(plotArea.x + px, y);
                else histCtx.lineTo(plotArea.x + px, y);
            }
            histCtx.stroke();
            histCtx.setLineDash([]);
            
            // Draw x-axis labels in sigma units
            histCtx.fillStyle = '#94a3b8';
            histCtx.font = '11px -apple-system, sans-serif';
            histCtx.textAlign = 'center';
            for (let i = 0; i <= 8; i++) {
                const x = plotArea.x + (i / 8) * plotArea.width;
                const dataX = canvasToDataX(x, plotArea);
                const labelVal = dataX / sigma;
                histCtx.fillText(labelVal.toFixed(1) + 'Ïƒ', x, plotArea.y + plotArea.height + 20);
            }
            histCtx.fillText('Position (x)', plotArea.x + plotArea.width / 2, plotArea.y + plotArea.height + 35);
            
            // Draw y-axis label
            histCtx.save();
            histCtx.translate(15, plotArea.y + plotArea.height / 2);
            histCtx.rotate(-Math.PI / 2);
            histCtx.textAlign = 'center';
            histCtx.fillStyle = '#94a3b8';
            histCtx.font = '12px -apple-system, sans-serif';
            histCtx.fillText('Probability Density', 0, 0);
            histCtx.restore();
            
            // Draw y-axis tick marks
            histCtx.fillStyle = '#94a3b8';
            histCtx.font = '10px -apple-system, sans-serif';
            histCtx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const y = plotArea.y + plotArea.height - (i / 5) * plotArea.height * 0.9;
                const val = (i / 5) * maxProb;
                histCtx.fillText(val.toFixed(3), plotArea.x - 5, y + 4);
            }
            
            // Draw flash effects
            flashEffects = flashEffects.filter(flash => {
                flash.age++;
                if (flash.age > 30) return false;
                
                const alpha = 1 - flash.age / 30;
                const radius = 5 + flash.age * 0.5;
                const flashX = dataToCanvasX(flash.x, plotArea);
                
                histCtx.beginPath();
                histCtx.arc(flashX, plotArea.y + plotArea.height - 10, radius, 0, Math.PI * 2);
                histCtx.fillStyle = `rgba(251, 191, 36, ${alpha})`;
                histCtx.fill();
                
                return true;
            });
        }
        
        // Perform measurement - samples from normalized Gaussian
        function performMeasurement() {
            const x = sampleGaussian(dataCenter, sigma);
            measurements.push(x);
            
            // Add flash effect
            flashEffects.push({ x: x, age: 0 });
            
            updateStats();
        }
        
        // Update statistics
        function updateStats() {
            const n = measurements.length;
            totalMeasurementsSpan.textContent = n;
            measurementCountSpan.textContent = `${n} measurements`;
            
            if (n > 0) {
                const mean = measurements.reduce((a, b) => a + b, 0) / n;
                meanPositionSpan.textContent = mean.toFixed(3);
                
                if (n > 1) {
                    const variance = measurements.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / (n - 1);
                    const std = Math.sqrt(variance);
                    stdDevSpan.textContent = std.toFixed(3);
                    
                    // Calculate convergence (how close measured std is to theoretical)
                    const relError = Math.abs(std - sigma) / sigma;
                    const convergence = Math.max(0, 100 * (1 - relError));
                    convergenceFill.style.width = `${Math.min(100, convergence)}%`;
                } else {
                    stdDevSpan.textContent = 'â€”';
                }
            } else {
                meanPositionSpan.textContent = 'â€”';
                stdDevSpan.textContent = 'â€”';
                convergenceFill.style.width = '0%';
            }
        }
        
        // Reset histogram
        function resetHistogram() {
            measurements = [];
            histogram = new Array(numBins).fill(0);
            flashEffects = [];
            updateStats();
        }
        
        // Animation loop
        function animate() {
            animationTime++;
            drawWavefunction();
            drawHistogram();
            requestAnimationFrame(animate);
        }
        
        // Event listeners
        measureBtn.addEventListener('click', () => {
            const count = parseInt(measureCountSelect.value);
            // For large counts, add them all immediately for better performance
            if (count <= 50) {
                for (let i = 0; i < count; i++) {
                    setTimeout(() => performMeasurement(), i * 20);
                }
            } else {
                // Add all at once for large batches
                for (let i = 0; i < count; i++) {
                    const x = sampleGaussian(dataCenter, sigma);
                    measurements.push(x);
                    if (i < 5) flashEffects.push({ x: x, age: 0 }); // Only a few flash effects
                }
                updateStats();
            }
        });
        
        autoMeasureBtn.addEventListener('click', () => {
            autoMeasureActive = !autoMeasureActive;
            autoMeasureBtn.classList.toggle('active', autoMeasureActive);
            autoMeasureBtn.textContent = autoMeasureActive ? 'â¸ Stop Auto' : 'Auto Measure';
            
            if (autoMeasureActive) {
                const rate = parseInt(autoRateSlider.value);
                autoMeasureInterval = setInterval(performMeasurement, 1000 / rate);
            } else {
                clearInterval(autoMeasureInterval);
            }
        });
        
        autoRateSlider.addEventListener('input', () => {
            const rate = parseInt(autoRateSlider.value);
            rateValueSpan.textContent = `${rate}/s`;
            
            if (autoMeasureActive) {
                clearInterval(autoMeasureInterval);
                autoMeasureInterval = setInterval(performMeasurement, 1000 / rate);
            }
        });
        
        animationSpeedSlider.addEventListener('input', () => {
            const sliderVal = parseInt(animationSpeedSlider.value);
            animationSpeed = sliderVal / 5;
            animationSpeedValueSpan.textContent = animationSpeed.toFixed(1) + 'x';
        });
        
        viewModeSelect.addEventListener('change', () => {
            viewMode = viewModeSelect.value;
            const labels = {
                'probability': '|Ïˆ(x)|Â²',
                'real': 'Re(Ïˆ)',
                'imag': 'Im(Ïˆ)',
                'both': 'Re(Ïˆ) & Im(Ïˆ)'
            };
            viewLabel.textContent = labels[viewMode];
        });
        
        resetBtn.addEventListener('click', resetHistogram);
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                measureBtn.click();
            } else if (e.code === 'KeyR') {
                resetBtn.click();
            } else if (e.code === 'KeyA') {
                autoMeasureBtn.click();
            }
        });
        
        // Handle window resize
        window.addEventListener('resize', () => {
            resizeCanvases();
        });
        
        // Initial setup
        resizeCanvases();
        // Set initial rate display
        rateValueSpan.textContent = `${autoRateSlider.value}/s`;
        animate();
    </script>
</body>
</html>