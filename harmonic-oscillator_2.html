<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Harmonic Oscillator Visualization</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body { 
            background: #0f172a;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: #e2e8f0;
            overflow: hidden;
        }
        
        .main-container {
            display: flex;
            height: 100vh;
        }
        
        .visualization-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 20px;
            gap: 20px;
        }
        
        .plot-container {
            flex: 1;
            background: rgba(15, 23, 42, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 8px;
            position: relative;
            min-height: 180px;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }

        .plot-label {
            position: absolute;
            top: 10px;
            left: 15px;
            font-size: 12px;
            color: #94a3b8;
            font-weight: 600;
            display: flex;
            align-items: baseline;
            gap: 4px;

            /* NEW: opaque-ish background so curves don’t clash with text */
            padding: 4px 8px;
            background: rgba(15, 23, 42, 0.95);
            border-radius: 6px;
            box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.25);
            z-index: 2;
        }

        .plot-legend {
            position: absolute;
            top: 10px;
            right: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            pointer-events: none; /* purely informative */

            /* NEW: same background treatment */
            padding: 4px 8px;
            background: rgba(15, 23, 42, 0.95);
            border-radius: 6px;
            box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.25);
            z-index: 2;
        }

/* optional: keep a bit of spacing on the text part only */
.plot-label-text {
    letter-spacing: 0.08em;
}

/* make sure MathJax is not forced to uppercase */
.plot-label-math {
    text-transform: none;
}

        /* NEW: subtitle used for stationary vs non-stationary text */
        .plot-subtitle {
            position: absolute;
            /* push it below the padded title pill */
            top: 42px;              /* was 28px */
            left: 15px;
            font-size: 11px;
            color: #64748b;

            /* give it its own background so curves don't cut through */
            padding: 3px 8px;
            background: rgba(15, 23, 42, 0.95);
            border-radius: 6px;
            box-shadow: 0 0 0 1px rgba(148, 163, 184, 0.2);
            z-index: 2;
        }


        .plot-legend {
            position: absolute;
            top: 10px;
            right: 15px;
            display: flex;
            gap: 10px;
            align-items: center;
            pointer-events: none; /* purely informative */
        }
        .legend-item {
            display: flex;
            gap: 6px;
            align-items: center;
            font-size: 12px;
            color: #cbd5e1;
            font-weight: 600;
            pointer-events: auto;
        }
        .legend-swatch {
            display: inline-block;
            width: 20px;
            height: 8px;
            border-radius: 3px;
        }
        .legend-swatch-real { background: #60a5fa; }
        /* imaginary swatch (dashed) - purple */
        .legend-swatch-imag { width: 20px; height: 0; border-top: 3px dashed #8b5cf6; border-radius: 0; background: transparent; }
        /* potential / energy legend swatches */
        .legend-swatch-potential { background: #fbbf24; }
        .legend-swatch-energy { width: 20px; height: 0; border-top: 3px dashed #f472b6; border-radius: 0; background: transparent; }
        .legend-label { color: #cbd5e1; font-size: 11px; }
        
        .sidebar {
            width: 320px;
            background: rgba(15, 23, 42, 0.8);
            backdrop-filter: blur(12px);
            border-left: 1px solid rgba(148, 163, 184, 0.1);
            padding: 25px;
            display: flex;
            flex-direction: column;
            gap: 25px;
            overflow-y: auto;
        }
        
        .control-group {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            padding: 15px;
        }
        
        .control-group h3 {
            font-size: 14px;
            color: #cbd5e1;
            margin-bottom: 15px;
            font-weight: 600;
        }
        
        .control {
            margin-bottom: 15px;
        }
        
        .control label {
            display: block;
            font-size: 12px;
            color: #94a3b8;
            margin-bottom: 8px;
        }
        
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* NEW: visually dim disabled slider when superposition is off */
        .slider-container.disabled {
            opacity: 0.4;
        }
        
        .slider {
            flex: 1;
            height: 4px;
            -webkit-appearance: none;
            appearance: none;
            background: rgba(148, 163, 184, 0.2);
            border-radius: 2px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #3b82f6;
            border-radius: 50%;
            cursor: pointer;
            transition: background 0.2s;
        }
        
        .slider::-webkit-slider-thumb:hover {
            background: #60a5fa;
        }
        
        .slider-value {
            min-width: 30px;
            text-align: right;
            font-size: 13px;
            color: #f1f5f9;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }
        
        .checkbox-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .checkbox {
            width: 18px;
            height: 18px;
            accent-color: #3b82f6;
            cursor: pointer;
        }
        
        .checkbox-label {
            font-size: 13px;
            color: #cbd5e1;
            cursor: pointer;
        }
        
        .equations-box {
            background: rgba(30, 41, 59, 0.5);
            border-radius: 8px;
            padding: 15px;
            font-size: 13px;
            line-height: 1.8;
        }
        
        .equation {
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
            color: #60a5fa;
        }
        
        .equation-label {
            color: #94a3b8;
            font-size: 11px;
            margin-bottom: 4px;
        }

        .equation-description {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            font-size: 0.8em;      /* match MathJax inline size */
            color: inherit;      /* same color as the LaTeX */
            margin-left: 2px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }
        
        .stat {
            background: rgba(30, 41, 59, 0.3);
            padding: 8px;
            border-radius: 4px;
        }
        
        .stat-label {
            font-size: 11px;
            color: #94a3b8;
        }
        
        .stat-value {
            font-size: 14px;
            color: #f1f5f9;
            font-weight: 600;
            font-variant-numeric: tabular-nums;
        }
        /* Keep statistics DOM present for JS but hide visually */
        #statisticsPanel {
            display: none;
        }
    </style>
    <!-- MathJax config and loader to render LaTeX equations -->
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['\\(', '\\)'], ['$', '$']],
                displayMath: [['$$','$$']]
            },
            options: {
                skipHtmlTags: ['script','noscript','style','textarea','pre']
            }
        };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>
</head>
<body>
    <div class="main-container">
        <div class="visualization-area">
            <div class="plot-container">
            <span class="plot-label">
            <span class="plot-label-text">Wavefunction</span>
            <span class="plot-label-math">\(\psi(x)\)</span>
            </span>                
            <div class="plot-legend" aria-hidden="true">
                    <div class="legend-item"><span class="legend-swatch legend-swatch-real"></span><span class="legend-label">Real Part</span></div>
                    <div class="legend-item"><span class="legend-swatch legend-swatch-imag"></span><span class="legend-label">Imaginary Part</span></div>
                </div>
                <canvas id="wavefunctionCanvas"></canvas>
            </div>
            <div class="plot-container">
                <span class="plot-label">
                <span class="plot-label-text">Probability Density</span>
                <span class="plot-label-math">\(|\psi(x)|^2\)</span>
                </span>   


                <!-- NEW: explanatory subtitle for stationary vs non-stationary -->
                <span class="plot-subtitle" id="stateTypeLabel">
                    Stationary eigenstate: probability density does not change in time.
                </span>
                <canvas id="probabilityCanvas"></canvas>
            </div>
            <div class="plot-container">
                <span class="plot-label">Potential and Energy Levels</span>
                <div class="plot-legend" aria-hidden="true">
                    <div class="legend-item"><span class="legend-swatch legend-swatch-potential"></span>  <span class="legend-label">Potential \(V(x)\)</span></div>
                    <div class="legend-item"><span class="legend-swatch legend-swatch-energy"></span><span class="legend-label" id="energyLegendLabel">E0</span></div>
                </div>
                <canvas id="potentialCanvas"></canvas>
            </div>
        </div>
        
        <div class="sidebar">
            <div class="control-group">
                <h3>Quantum State Controls</h3>
                <div class="control">
                    <label for="nSlider">Quantum Number \(n\)</label>

                    <div class="slider-container">
                        <input type="range" class="slider" id="nSlider" min="0" max="10" value="0">
                        <span class="slider-value" id="nValue">0</span>
                    </div>
                </div>

                <!-- Superposition toggle + second quantum number -->
                <div class="control">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="superpositionCheckbox">
                        <label for="superpositionCheckbox" class="checkbox-label">Enable eigenstate superposition: \(\psi = (\psi_{n} + \psi_{m})/\sqrt{2}\)</label>
                    </div>
                </div>
                <div class="control">
                    <label for="n2Slider">Second quantum number m</label>
                    <div class="slider-container disabled" id="n2SliderContainer">
                        <input type="range" class="slider" id="n2Slider" min="0" max="10" value="1" disabled>
                        <span class="slider-value" id="n2Value">1</span>
                    </div>
                </div>

                <h3>Display Controls</h3>

                <div class="control">
                    <!-- renamed for clarity -->
                    <label for="scaleSlider">Position Range (zoom)</label>
                    <div class="slider-container">
                        <input type="range" class="slider" id="scaleSlider" min="4" max="20" value="2" step="0.5">
                        <span class="slider-value" id="scaleValue">2.0</span>
                    </div>
                </div>
                <div class="control">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="animateCheckbox" checked>
                        <label for="animateCheckbox" class="checkbox-label">Animate Time Evolution</label>
                    </div>
                </div>
                <div class="control">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="showRealCheckbox" checked>
                        <label for="showRealCheckbox" class="checkbox-label">Show real part</label>
                    </div>
                </div>
                <div class="control">
                    <div class="checkbox-container">
                        <input type="checkbox" class="checkbox" id="showImagCheckbox" checked>
                        <label for="showImagCheckbox" class="checkbox-label">Show imaginary part</label>
                    </div>
                </div>
            </div>
            
            <div class="equations-box">
                <h4>Relevant Equations</h4>

                <div class="equation-label">Wavefunction:</div>
                <div class="equation">
                    \(\psi_n(x) = \left(\frac{m\omega}{\pi\hbar}\right)^{1/4} \frac{1}{\sqrt{2^n n!}} e^{-\frac{m\omega x^2}{2\hbar}}\, H_n\!\left(\sqrt{\frac{m\omega}{\hbar}}\,x\right)\)
                </div>
                <div class="equation">
                    <span class="math-inline">\(H_n(x)\)</span>
                    <span class="equation-description">are the Hermite polynomials.</span>
                </div>

                <div class="equation-label" style="margin-top: 10px;">Energy Levels:</div>
                <div class="equation">\(E_n = \hbar\omega\left(n + \tfrac{1}{2}\right)\)</div>
                
                <h4>Current Quantum State</h4>
                <!-- State description -->
                <div class="equation-label" style="margin-top: 10px;">Current wavefunction: </div>
                <div class="equation" id="stateDescription">
                    \(\psi(x,t) = \psi_{0}(x)\,e^{-iE_{0}t/\hbar}\)
                </div>

                <div class="equation-label" style="margin-top: 10px;">Current energy eigenvalue:</div>
                <div class="equation" id="currentEnergy">\(E_0 = 0.5\,\hbar\omega\)</div>
                <!-- Placeholder for second energy when in superposition; JS will populate and show/hide -->
                <div class="equation" id="currentEnergy2" style="display: none;"></div>


            </div>
            
            <div class="control-group" id="statisticsPanel">
                <h3>Statistics</h3>
                <div class="stats-grid">
                    <div class="stat">
                        <div class="stat-label">FPS</div>
                        <div class="stat-value" id="fps">60</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Phase</div>
                        <div class="stat-value" id="phase">0.00</div>
                    </div>
                    <div class="stat">
                        <div class="stat-label">Parity</div>
                        <div class="stat-value" id="parity">Even</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Get canvas contexts
        const wavefunctionCanvas = document.getElementById('wavefunctionCanvas');
        const probabilityCanvas = document.getElementById('probabilityCanvas');
        const potentialCanvas = document.getElementById('potentialCanvas');
        
        const ctxWave = wavefunctionCanvas.getContext('2d');
        const ctxProb = probabilityCanvas.getContext('2d');
        const ctxPot = potentialCanvas.getContext('2d');
        
        // State variables
        let n = 0;        // primary quantum number
        let n2 = 1;       // second quantum number for superposition
        let useSuperposition = false;  // toggles superposition mode
        let scale = 4.0;
        let animate = true;
        let time = 0;
        let lastTime = performance.now();
        let frameCount = 0;
        let fps = 60;
        // Show/hide components
        let showReal = true;
        let showImag = true;
        
        // Physics constants (normalized units)
        const omega = 1;
        const hbar = 1;
        const m = 1;
        
        // Resize canvases
        function resizeCanvases() {
            const containers = document.querySelectorAll('.plot-container');
            containers.forEach((container) => {
                const canvas = container.querySelector('canvas');
                const rect = container.getBoundingClientRect();
                canvas.width = rect.width;
                canvas.height = rect.height;
            });
        }
        // NEW: helper to draw shared x-axis ticks and labels (not cut off)
        function drawXAxisTicks(ctx, width, height, xRange) {
            // Treat the "numerical x-axis" as being near the bottom,
            // with a bit of margin for labels.
            const axisY   = height - 20;  // same y as the bottom axis line in prob/potential
            const tickTop = axisY;
            const tickBot = axisY + 4;    // small tick downward
            const labelY  = height - 6;   // safely inside the canvas

            ctx.save();
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
            ctx.fillStyle   = '#94a3b8';
            ctx.lineWidth   = 1;
            ctx.font        = '10px -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif';

            const tickValues = [-xRange, -xRange / 2, 0, xRange / 2, xRange];

            tickValues.forEach((xVal) => {
                const px = ((xVal / (2 * xRange)) + 0.5) * width;

                // tick mark
                ctx.beginPath();
                ctx.moveTo(px, tickTop);
                ctx.lineTo(px, tickBot);
                ctx.stroke();

                // label
                const label = xVal.toFixed(1);
                const textWidth = ctx.measureText(label).width;
                ctx.fillText(label, px - textWidth / 2, labelY);
            });

            ctx.restore();
        }
        
        // Hermite polynomial calculation
        function hermite(n, x) {
            if (n === 0) return 1;
            if (n === 1) return 2 * x;
            
            let h0 = 1;
            let h1 = 2 * x;
            let hn = 0;
            
            for (let i = 2; i <= n; i++) {
                hn = 2 * x * h1 - 2 * (i - 1) * h0;
                h0 = h1;
                h1 = hn;
            }
            
            return hn;
        }
        
        // Calculate energy eigenstate wavefunction ψ_n(x,t)
        function wavefunction(n, x, t = 0) {
            const alpha = Math.sqrt(m * omega / hbar);
            const normalization = Math.pow(alpha / Math.PI, 0.25) / Math.sqrt(Math.pow(2, n) * factorial(n));
            const exponential = Math.exp(-alpha * alpha * x * x / 2);
            const hermitePoly = hermite(n, alpha * x);

            // Time evolution phase
            const energy = hbar * omega * (n + 0.5);
            const phase = animate ? -energy * t / hbar : 0;
            const reFactor = Math.cos(phase);
            const imFactor = Math.sin(phase);

            const base = normalization * exponential * hermitePoly;
            return { re: base * reFactor, im: base * imFactor };
        }

        // Total wavefunction (either pure eigenstate or superposition)
        function totalWavefunction(x, t = 0) {
            // If superposition is enabled and n2 != n, use equal-weight superposition
            if (useSuperposition && n2 !== n) {
                const psi1 = wavefunction(n, x, t);
                const psi2 = wavefunction(n2, x, t);
                const invSqrt2 = 1 / Math.sqrt(2);
                return {
                    re: (psi1.re + psi2.re) * invSqrt2,
                    im: (psi1.im + psi2.im) * invSqrt2
                };
            } else {
                // Just the single energy eigenstate
                return wavefunction(n, x, t);
            }
        }
        
        // Factorial function
        function factorial(n) {
            if (n <= 1) return 1;
            let result = 1;
            for (let i = 2; i <= n; i++) {
                result *= i;
            }
            return result;
        }
        
        // Draw wavefunction
        function drawWavefunction() {
            const width = wavefunctionCanvas.width;
            const height = wavefunctionCanvas.height;
            
            ctxWave.fillStyle = '#0f172a';
            ctxWave.fillRect(0, 0, width, height);
            
            // Draw axes (x=0 vertical, ψ=0 horizontal)
            ctxWave.strokeStyle = 'rgba(148, 163, 184, 0.2)';
            ctxWave.lineWidth = 1;
            ctxWave.beginPath();
            ctxWave.moveTo(0, height / 2);
            ctxWave.lineTo(width, height / 2);
            ctxWave.moveTo(width / 2, 0);
            ctxWave.lineTo(width / 2, height);
            ctxWave.stroke();
            
            const xRange = scale;

            // NEW: shared x-axis ticks and labels
            drawXAxisTicks(ctxWave, width, height, xRange);

            // Draw real and imaginary parts (overlayed)
            const rePoints = new Array(width);
            const imPoints = new Array(width);
            for (let px = 0; px < width; px++) {
                const x = (px / width - 0.5) * 2 * xRange;
                const psi = totalWavefunction(x, time);
                rePoints[px] = height / 2 - psi.re * height / 4;
                imPoints[px] = height / 2 - psi.im * height / 4;
            }

            // Real part
            if (showReal) {
                ctxWave.strokeStyle = '#60a5fa';
                ctxWave.lineWidth = 2;
                ctxWave.setLineDash([]);
                ctxWave.beginPath();
                for (let px = 0; px < width; px++) {
                    const py = rePoints[px];
                    if (px === 0) ctxWave.moveTo(px, py);
                    else ctxWave.lineTo(px, py);
                }
                ctxWave.stroke();
            }

            // Imaginary part (dashed)
            if (showImag) {
                ctxWave.strokeStyle = '#8b5cf6';
                ctxWave.lineWidth = 2;
                ctxWave.setLineDash([6, 4]);
                ctxWave.beginPath();
                for (let px = 0; px < width; px++) {
                    const py = imPoints[px];
                    if (px === 0) ctxWave.moveTo(px, py);
                    else ctxWave.lineTo(px, py);
                }
                ctxWave.stroke();
                ctxWave.setLineDash([]);
            }
        }
        
        // Draw probability density
        function drawProbability() {
            const width = probabilityCanvas.width;
            const height = probabilityCanvas.height;
            
            ctxProb.fillStyle = '#0f172a';
            ctxProb.fillRect(0, 0, width, height);
            
            // Axes (x=0 vertical, baseline at y = height - 20)
            ctxProb.strokeStyle = 'rgba(148, 163, 184, 0.2)';
            ctxProb.lineWidth = 1;
            ctxProb.beginPath();
            ctxProb.moveTo(0, height - 20);
            ctxProb.lineTo(width, height - 20);
            ctxProb.moveTo(width / 2, 0);
            ctxProb.lineTo(width / 2, height);
            ctxProb.stroke();
            
            const xRange = scale;

            // NEW: shared x-axis ticks and labels
            drawXAxisTicks(ctxProb, width, height, xRange);
            
            // Draw probability density
            ctxProb.fillStyle = 'rgba(52, 211, 153, 0.3)';
            ctxProb.strokeStyle = '#34d399';
            ctxProb.lineWidth = 2;
            ctxProb.beginPath();
            
            ctxProb.moveTo(0, height - 20);

            // If superposition with n2 != n, probability depends on time;
            // otherwise it is stationary (use t=0).
            const probTime = (useSuperposition && n2 !== n) ? time : 0;
            
            for (let px = 0; px < width; px++) {
                const x = (px / width - 0.5) * 2 * xRange;
                const psi = totalWavefunction(x, probTime);
                const prob = psi.re * psi.re + psi.im * psi.im;
                const py = height - 20 - prob * height * 0.7;
                ctxProb.lineTo(px, py);
            }
            
            ctxProb.lineTo(width, height - 20);
            ctxProb.closePath();
            ctxProb.fill();
            ctxProb.stroke();
        }
        // Draw potential and energy level(s)
        function drawPotential() {
            const width = potentialCanvas.width;
            const height = potentialCanvas.height;
            
            ctxPot.fillStyle = '#0f172a';
            ctxPot.fillRect(0, 0, width, height);
            
            // Axes
            ctxPot.strokeStyle = 'rgba(148, 163, 184, 0.2)';
            ctxPot.lineWidth = 1;
            ctxPot.beginPath();
            ctxPot.moveTo(0, height - 20);
            ctxPot.lineTo(width, height - 20);
            ctxPot.moveTo(width / 2, 0);
            ctxPot.lineTo(width / 2, height);
            ctxPot.stroke();
            
            const xRange = scale;
            const maxEnergy = (10 + 0.5) * hbar * omega; // Max n=10

            // Shared x-axis ticks and labels
            drawXAxisTicks(ctxPot, width, height, xRange);
            
            // Draw potential V(x) = 0.5 * m * omega^2 * x^2
            ctxPot.strokeStyle = '#fbbf24';
            ctxPot.lineWidth = 2;
            ctxPot.beginPath();
            
            for (let px = 0; px < width; px++) {
                const x = (px / width - 0.5) * 2 * xRange;
                const V = 0.5 * m * omega * omega * x * x;
                const py = height - 20 - (V / maxEnergy) * (height - 40);
                
                if (px === 0) {
                    ctxPot.moveTo(px, py);
                } else {
                    ctxPot.lineTo(px, py);
                }
            }
            ctxPot.stroke();
            
            // Energy levels
            const energy1 = hbar * omega * (n + 0.5);
            const energyY1 = height - 20 - (energy1 / maxEnergy) * (height - 40);

            ctxPot.strokeStyle = '#f472b6';
            ctxPot.lineWidth = 2;
            ctxPot.setLineDash([5, 5]);
            ctxPot.beginPath();
            ctxPot.moveTo(0, energyY1);
            ctxPot.lineTo(width, energyY1);
            ctxPot.stroke();

            // --- NEW: second energy level + turning points support ---
            let energy2 = null;
            let energyY2 = null;

            if (useSuperposition && n2 !== n) {
                energy2 = hbar * omega * (n2 + 0.5);
                energyY2 = height - 20 - (energy2 / maxEnergy) * (height - 40);

                ctxPot.beginPath();
                ctxPot.moveTo(0, energyY2);
                ctxPot.lineTo(width, energyY2);
                ctxPot.stroke();
            }

            ctxPot.setLineDash([]);
            
            // Classical turning points for primary n
            const turningPoint1 = Math.sqrt(2 * energy1 / (m * omega * omega));
            const tp1X1 = (width / 2) - (turningPoint1 / xRange) * (width / 2);
            const tp1X2 = (width / 2) + (turningPoint1 / xRange) * (width / 2);
            
            ctxPot.fillStyle = '#f472b6';
            ctxPot.beginPath();
            ctxPot.arc(tp1X1, energyY1, 4, 0, Math.PI * 2);
            ctxPot.fill();
            ctxPot.beginPath();
            ctxPot.arc(tp1X2, energyY1, 4, 0, Math.PI * 2);
            ctxPot.fill();

            // NEW: classical turning points for second energy level, if present
            if (energy2 !== null && energyY2 !== null) {
                const turningPoint2 = Math.sqrt(2 * energy2 / (m * omega * omega));
                const tp2X1 = (width / 2) - (turningPoint2 / xRange) * (width / 2);
                const tp2X2 = (width / 2) + (turningPoint2 / xRange) * (width / 2);

                ctxPot.beginPath();
                ctxPot.arc(tp2X1, energyY2, 4, 0, Math.PI * 2);
                ctxPot.fill();
                ctxPot.beginPath();
                ctxPot.arc(tp2X2, energyY2, 4, 0, Math.PI * 2);
                ctxPot.fill();
            }
        }


        // Update explanatory labels for state type and legend
        function updateStateLabels() {
            const stateTypeLabel = document.getElementById('stateTypeLabel');
            const stateDescription = document.getElementById('stateDescription');
            const energyLabelEl = document.getElementById('energyLegendLabel');
            const currentEnergyEl = document.getElementById('currentEnergy');
            const currentEnergy2El = document.getElementById('currentEnergy2');

            if (useSuperposition && n2 !== n) {
                stateTypeLabel.textContent =
                    'Superposition of two eigenstates: |ψ(x)|² oscillates in time.';
                stateDescription.textContent =
                    `\\(\\psi(x,t) = \\tfrac{1}{\\sqrt{2}}\\big(\\psi_{${n}}(x)e^{-iE_${n}t/\\hbar} + \\psi_{${n2}}(x)e^{-iE_${n2}t/\\hbar}\\big)\\)`;

                if (energyLabelEl) {
                    energyLabelEl.textContent = `\\(E_${n}, E_${n2}\\)`;
                }

                if (currentEnergyEl) {
                    currentEnergyEl.innerHTML = `\\(E_${n} = ${(n + 0.5).toFixed(1)}\\,\\hbar\\omega\\)`;
                }
                if (currentEnergy2El) {
                    currentEnergy2El.style.display = '';
                    currentEnergy2El.innerHTML = `\\(E_${n2} = ${(n2 + 0.5).toFixed(1)}\\,\\hbar\\omega\\)`;
                }
            } else {
                stateTypeLabel.textContent =
                    'For stationary eigenstates, probability density does not change in time.';
                stateDescription.textContent =
                    `\\(\\psi(x,t) = \\psi_{${n}}(x)e^{-iE_${n}t/\\hbar}\\)`;

                if (energyLabelEl) {
                    energyLabelEl.textContent = `\\(E_${n}\\)`;
                }

                if (currentEnergyEl) {
                    currentEnergyEl.innerHTML = `\\(E_${n} = ${(n + 0.5).toFixed(1)}\\,\\hbar\\omega\\)`;
                }
                if (currentEnergy2El) {
                    currentEnergy2El.style.display = 'none';
                    currentEnergy2El.innerHTML = '';
                }
            }

            // Ask MathJax to re-typeset just the equations box
            if (window.MathJax && window.MathJax.typesetPromise) {
                MathJax.typesetPromise([
                    stateDescription.parentElement,  // equations box
                    energyLabelEl                    // the legend label
                ]);
            }
        }

        // Animation loop
        function animationLoop() {
            const currentTime = performance.now();
            const deltaTime = (currentTime - lastTime) / 1000;
            
            if (animate) {
                time += deltaTime * 0.5; // Slow down time evolution
            }
            
            // Update FPS
            frameCount++;
            if (frameCount % 30 === 0) {
                fps = Math.round(1 / deltaTime);
                document.getElementById('fps').textContent = fps;
            }
            
            // Draw all plots
            drawWavefunction();
            drawProbability();
            drawPotential();
            
            // Update stats
            document.getElementById('phase').textContent = (time % (2 * Math.PI)).toFixed(2);
            document.getElementById('parity').textContent = n % 2 === 0 ? 'Even' : 'Odd';
            
            lastTime = currentTime;
            requestAnimationFrame(animationLoop);
        }
        
        // Event listeners
        document.getElementById('nSlider').addEventListener('input', (e) => {
            n = parseInt(e.target.value);
            document.getElementById('nValue').textContent = n;
            document.getElementById('currentEnergy').textContent = `E${n} = ${(n + 0.5).toFixed(1)} ℏω`;
            updateStateLabels();
        });

        // Superposition checkbox
        const superCheckbox = document.getElementById('superpositionCheckbox');
        const n2Slider = document.getElementById('n2Slider');
        const n2ValueSpan = document.getElementById('n2Value');
        const n2SliderContainer = document.getElementById('n2SliderContainer');

        superCheckbox.addEventListener('change', (e) => {
            useSuperposition = e.target.checked;
            n2Slider.disabled = !useSuperposition;
            if (useSuperposition) {
                n2SliderContainer.classList.remove('disabled');
            } else {
                n2SliderContainer.classList.add('disabled');
            }
            updateStateLabels();
        });

        // Second quantum number slider
        n2Slider.addEventListener('input', (e) => {
            n2 = parseInt(e.target.value);
            n2ValueSpan.textContent = n2;
            updateStateLabels();
        });
        
        document.getElementById('scaleSlider').addEventListener('input', (e) => {
            scale = parseFloat(e.target.value);
            document.getElementById('scaleValue').textContent = scale.toFixed(1);
        });
        
        document.getElementById('animateCheckbox').addEventListener('change', (e) => {
            animate = e.target.checked;
            if (!animate) time = 0;
        });

        document.getElementById('showRealCheckbox').addEventListener('change', (e) => {
            showReal = e.target.checked;
        });

        document.getElementById('showImagCheckbox').addEventListener('change', (e) => {
            showImag = e.target.checked;
        });
        
        // Initialize
        window.addEventListener('resize', resizeCanvases);
        resizeCanvases();
        updateStateLabels();
        animationLoop();
    </script>
</body>
</html>
